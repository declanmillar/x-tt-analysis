function differential_cross_section(x,wgt)

  ! computes the fully differential cross section for
  ! * pp -> tt,
  ! * pp -> tt -> bw^+bbarw^- -> bbbare^+nue^-nubarc
  ! matrix element and phase space integration function.
  ! called each time a phase space point is generated by vegas.
  ! calculates matrix element using helas subroutines, scales by phase
  ! space volume factor and populates distributions for set of defined
  ! observables accordingly.
  ! this is then passed to vegas in the main program.
  ! authors: declan millar, stefano moretti

  use mathematics, only: pi
  use configuration
  use modelling
  use kinematics
  use integration
  use distributions
  
  implicit none

  real :: x(100), wgt

  ! functions
  real :: differential_cross_section
  real :: alfas
  real :: sqqff_qcd
  real :: sggff_qcd
  real :: sqqff_ewp
  real :: sqqbbffff_qcd
  real :: sggbbffff_qcd
  real :: sqqbbffff_ewp
  real :: ctq6pdf
  real :: longitudinal_neutrino_momentum

  ! implict to explicit variable dump
  real :: a_s
  real :: arg356
  real :: arg478
  real :: beta
  real :: cf5
  real :: cf56
  real :: cf7
  real :: cf78
  real :: cosfl
  real :: cost
  real :: costheta5
  real :: costheta7
  real :: costheta_top_cm
  real :: costheta_top_star
  real :: ct
  real :: ct5
  real :: ct56
  real :: ct7
  real :: ct78
  real :: ct7ct5
  real :: d1, d2, dbar1, dbar2, u1, u2, ubar1, ubar2, str1, str2, chm1, chm2, btm1, btm2, glu1, glu2, ggd1, ggd2, p5xp, p5yp, p5zp
  real :: ffxn, fffxn, fffxn1, fffxn2
  real :: rmt, gamt
  real :: delta_absy
  real :: dphi
  real :: ecm, ecm_max, pcm, qcm2
  real :: hist, hist1, hist2
  real :: gs, gs2
  real :: et, et3, et4, et5, et7, etmiss, etmiss2, eta356, eta478, etvis, etvis2
  real :: pfx1tot, pfx2tot
  real :: gcol, qcm
  real :: pt356, pt478, phi356, phi478
  real :: phit
  real :: pq5, pq52, pq56, pq7, pq78, p5m, p5mp
  real :: phi_l
  real :: q2, qq
  real :: qqd1, qqd2
  real :: resall
  real :: rl356
  real :: rl478
  real :: rl56
  real :: rl78
  real :: m356
  real :: m356_2
  real :: m356max
  real :: m356min
  real :: m478
  real :: m478_2
  real :: m478max
  real :: m478min
  real :: m56
  real :: m56_2
  real :: m56max
  real :: m56min
  real :: m78
  real :: m78_2
  real :: m78max
  real :: m78min
  real :: rm_ct12
  real :: rm_ct22
  real :: rm_ct32
  real :: rm_t12
  real :: rm_t22
  real :: rm_t32
  real :: rmlct2
  real :: rmlt2
  real :: rmvis2
  real :: rpl356
  real :: rpl478
  real :: rps356
  real :: rps478
  real :: rq
  real :: rq2
  real :: rq5
  real :: rq52
  real :: rq56
  real :: rq562
  real :: rq7
  real :: rq72
  real :: rq78
  real :: rq782
  real :: sf5
  real :: sf56
  real :: sf7
  real :: sf78
  real :: shat
  real :: sigm
  real :: sigp
  real :: st
  real :: st5
  real :: st56
  real :: st7
  real :: st78
  real :: tau
  real :: vcol

  ! parton momentum fraction
  real :: x1
  real :: x2
  real :: xx
  real :: xx1
  real :: xx2

  ! 
  real :: xx356max
  real :: xx356min
  real :: xx478max
  real :: xx478min
  real :: xx56max
  real :: xx56min
  real :: xx78max
  real :: xx78min

  ! rapidity
  real :: yt
  real :: ytb
  real :: ytt

  ! square matrix elements
  real :: ewzuu1 ,ewzuu2, ewzdd1, ewzdd2, ewzbb1, ewzbb2, qcdqq1,qcdqq2,qcdgg1,qcdgg2,qcdbb1,qcdbb2

  ! iterators
  integer :: i, j, k, ii, jj, kk, jx, ix, nbin,  ibin, jbin, imode, ip, iphel, jphel, lam3, lam4, itrans

  ! phase space vectors.
  real :: q356(4), q478(4), p356(4), p478(4)
  real :: q56(4), q78(4), p56(4), p78(4)
  real :: q5(4), q7(4)
  real :: q(4, 8), qcol(4, 8)

  ! 4-momenta
  real :: p1(0:3), p2(0:3), p3(0:3), p4(0:3), p5(0:3), p6(0:3), p7(0:3), p8(0:3)
  real :: p1col(0:3), p2col(0:3), p3col(0:3), p4col(0:3), p5col(0:3), p6col(0:3), p7col(0:3), p8col(0:3)
  real :: p8col_reco(0:3)

  ! invarient masses
  real :: mtt, mtt_reco
  real :: mtt2, mtt_reco2

  ! Transverse momentum vectors   
  real :: pT8col(1:2)
  real :: ptvis(2), ptmiss(2)

  ! kinematic scalar arrays
  real :: pt2(8), pt(8), rps(8), rpl(8), arg(8), eta(8), phi(8), ycol(8)
  
  ! lepton azimuthal angle coordinate system
  real :: xp(3), yp(3), zp(3)

  ! polarised square matrix elements
  ! situation one: q-qbar collision
  real :: qcdpolqq1(-1:1, -1:1)
  real :: qcdpolbb1(-1:1, -1:1), qcdpolgg1(-1:1, -1:1)
  real :: ewzpoluu1(-1:1, -1:1), ewzpoldd1(-1:1, -1:1)
  real :: ewzpolbb1(-1:1, -1:1)
  real :: pfx1(-1:1, -1:1)
  ! situation two: qbar-q collision
  real :: qcdpolqq2(-1:1, -1:1)
  real :: qcdpolbb2(-1:1, -1:1), qcdpolgg2(-1:1, -1:1)
  real :: ewzpoluu2(-1:1, -1:1), ewzpoldd2(-1:1, -1:1)
  real :: ewzpolbb2(-1:1, -1:1)
  real :: pfx2(-1:1, -1:1)

  ! weight per polarisation
  real :: weight(20, -1:1, -1:1)

  ! pdfs
  real :: fx1(13), fx2(13)
  real :: x1x2(2, 2)
  real :: trans(ntrans)

  ! internal random number seed
  integer :: jseed
  data jseed/987654321/

  ! store top parameters
  rmt = tmass
  gamt = fwidth(11)

  ! centre of mass energy
  ecm_max = collider_energy
  ecm = x(2 + 12*tops_decay)*(ecm_max - m3 - m4 - m5 - m6 - m7 - m8) &
        + m3 + m4 + m5 + m6 + m7 + m8
  shat = ecm*ecm
  tau = shat/s

  ! x1 and x2 of the partons
  xx1 = x(3+12*tops_decay) * (1.d0-tau) + tau
  xx2 = tau/xx1
  x1x2(1, 1) = xx1
  x1x2(1, 2) = xx2
  x1x2(2, 1) = xx2
  x1x2(2, 2) = xx1

  ! loop over x1 and x2  
  differential_cross_section = 0.d0
  do ix = 1, ixmax
    ffxn = 0.d0
    x1 = x1x2(ix, 1)
    x2 = x1x2(ix, 2)

    ! loop over costheta_cm
    do jx = 1, jxmax
      fffxn = 0.d0
      
      ! scale for the pdfs
      qq = 2.d0*rmt

      ! construct hadronic structure functions.
      if (structure_function <= 4) then
        q2 = qq*qq
        if ((x1 <= 1.d-6) .or. (x1 >= 1.d0)) then
          fffxn=0.d0
          return
        end if
        if ((x2 <= 1.d-6) .or. (x2 >= 1.d0)) then
          fffxn=0.d0
          return
        end if
        if ((qq <= 1.3d0) .or. (qq >= 1.d4)) then
          fffxn=0.d0
          return
        end if

        ! note that for cteq pdfs we multiply by x1 below and then divide by
        ! it later. this is for compatibility with mrs, which return xf(x).)
        ! recent changes may screw up compatabilty with mrs. sea->bar in names
        ! below reflecting change in cteq61pdf iparton variable.

        u1 = x1*ctq6pdf(1, x1, qq)
        d1 = x1*ctq6pdf(2, x1, qq)
        ubar1 = x1*ctq6pdf(-1, x1, qq)
        dbar1 = x1*ctq6pdf(-2, x1, qq)
        str1 = x1*ctq6pdf(3, x1, qq)
        chm1 = x1*ctq6pdf(4, x1, qq)
        btm1 = x1*ctq6pdf(5, x1, qq)
        glu1 = x1*ctq6pdf(0, x1, qq)
        u2 = x2*ctq6pdf(1, x2, qq)
        d2 = x2*ctq6pdf(2, x2, qq)
        ubar2 = x2*ctq6pdf(-1, x2, qq)
        dbar2 = x2*ctq6pdf(-2, x2, qq)
        str2 = x2*ctq6pdf(3, x2, qq)
        chm2 = x2*ctq6pdf(4, x2, qq)
        btm2 = x2*ctq6pdf(5, x2, qq)
        glu2 = x2*ctq6pdf(0, x2, qq)


      else if (structure_function == 5) then
        imode=1
        if ((x1 <= 1.d-5) .or. (x1 >= 1.d0)) then
          fffxn=0.d0
          return
        end if
        if ((x2 <= 1.d-5) .or. (x2 >= 1.d0)) then
          fffxn=0.d0
          return
        end if
        if ((qq**2 <= 1.25d0) .or. (qq**2 >= 1.d7)) then
          fffxn=0.d0
          return
        end if
        call mrs99(x1, qq, imode, u1, d1, ubar1, dbar1, str1, chm1, btm1, glu1)
        call mrs99(x2, qq, imode, u2, d2, ubar2, dbar2, str2, chm2, btm2, glu2)
      else if (structure_function == 6) then
        imode=2
        if ((x1 <= 1.d-5) .or. (x1 >= 1.d0)) then
          fffxn=0.d0
          return
        end if
        if ((x2 <= 1.d-5) .or. (x2 >= 1.d0)) then
          fffxn=0.d0
          return
        end if
        if ((qq**2 <= 1.25d0) .or. (qq**2 >= 1.d7)) then
          fffxn=0.d0
          return
        end if
        call mrs99(x1, qq, imode, u1, d1, ubar1, dbar1, str1, chm1, btm1, glu1)
        call mrs99(x2, qq, imode, u2, d2, ubar2, dbar2, str2, chm2, btm2, glu2)
      else if (structure_function == 7) then
        imode=3
        if ((x1 <= 1.d-5) .or. (x1 >= 1.d0)) then
          fffxn=0.d0
          return
        end if
        if ((x2 <= 1.d-5) .or. (x2 >= 1.d0)) then
          fffxn=0.d0
          return
        end if
        if ((qq**2 <= 1.25d0) .or. (qq**2 >= 1.d7)) then
          fffxn=0.d0
          return
        end if
        call mrs99(x1, qq, imode, u1, d1, ubar1, dbar1, str1, chm1, btm1, glu1)
        call mrs99(x2, qq, imode, u2, d2, ubar2, dbar2, str2, chm2, btm2, glu2)
      else if (structure_function == 8) then
        imode=4
        if ((x1 <= 1.d-5) .or. (x1 >= 1.d0)) then
          fffxn=0.d0
          return
        end if
        if ((x2 <= 1.d-5) .or. (x2 >= 1.d0)) then
          fffxn=0.d0
          return
        end if
        if ((qq**2 <= 1.25d0) .or. (qq**2 >= 1.d7)) then
          fffxn=0.d0
          return
        end if
        call mrs99(x1, qq, imode, u1, d1, ubar1, dbar1, str1, chm1, btm1, glu1)
        call mrs99(x2, qq, imode, u2, d2, ubar2, dbar2, str2, chm2, btm2, glu2)
      else if (structure_function == 9) then
        imode=5
        if ((x1 <= 1.d-5) .or. (x1 >= 1.d0)) then
          fffxn=0.d0
          return
        end if
        if ((x2 <= 1.d-5) .or. (x2 >= 1.d0)) then
          fffxn=0.d0
          return
        end if
        if ((qq**2 <= 1.25d0) .or. (qq**2 >= 1.d7)) then
          fffxn=0.d0
          return
        end if
        call mrs99(x1, qq, imode, u1, d1, ubar1, dbar1, str1, chm1, btm1, glu1)
        call mrs99(x2, qq, imode, u2, d2, ubar2, dbar2, str2, chm2, btm2, glu2)

      ! note that mrs return valence and sea contributions automatically.)
      ! note that cteq do too now!)
      ! parton distribution functions (pdfs)
      end if
     
      ! initialise pdfs
      fx1(1) = d1
      fx1(2) = u1
      fx1(3) = str1
      fx1(4) = chm1
      fx1(5) = btm1
      fx1(6) = 0.d0
      fx1(7) = dbar1
      fx1(8) = ubar1
      fx1(9) = fx1(3)
      fx1(10) = fx1(4)
      fx1(11) = fx1(5)
      fx1(12) = fx1(6)
      fx1(13) = glu1
      do i = 1, 13
        fx1(i) = fx1(i)/x1
      end do
      fx2(1) = d2*(1 - initial_state) + dbar2*initial_state
      fx2(2) = u2*(1 - initial_state) + ubar2*initial_state
      fx2(3) = str2
      fx2(4) = chm2
      fx2(5) = btm2
      fx2(6) = 0.d0
      fx2(7) = d2*initial_state + dbar2*(1 - initial_state)
      fx2(8) = u2*initial_state + ubar2*(1 - initial_state)
      fx2(9) = fx2(3)
      fx2(10) = fx2(4)
      fx2(11) = fx2(5)
      fx2(12) = fx2(6)
      fx2(13) = glu2
      do i = 1, 13
        fx2(i) = fx2(i)/x2
      end do
    
      ! initial particle momenta (all approximately massless)
      pcm = ecm/2.d0
      q(4,1) = pcm
      q(3,1) = pcm
      q(2,1) = 0.d0
      q(1,1) = 0.d0
      q(4,2) = pcm
      q(3,2) = -pcm
      q(2,2) = 0.d0
      q(1,2) = 0.d0


      if (final_state == 0) then
        ! calculate 2to2 kinematics in parton cm frame
        phit = 2.d0*pi*ran(jseed)
        if (jx == 1) then
          ct = x(1)
        else if (jx == 2) then
          ct = -x(1)
        else
          print *, 'invalid jx.'
        end if
        st=sqrt(1.d0 - ct*ct)
        qcm2 = ((ecm*ecm - m3*m3 - m4*m4)**2 - (2.d0*m3*m4)**2)/(4.d0*ecm*ecm)
        if (qcm2 < 0.d0) then
          fffxn = 0.d0
          return
        else
          qcm = sqrt(qcm2)
        endif
        q(4,3) = sqrt(qcm2 + m3*m3)
        q(3,3) = qcm*ct
        q(2,3) = qcm*st*cos(phit)
        q(1,3) = qcm*st*sin(phit)
        q(4,4) = sqrt(qcm2 + m4*m4)
        q(3,4) = -qcm*ct
        q(2,4) = -qcm*st*cos(phit)
        q(1,4) = -qcm*st*sin(phit)
        do i = 1, 4
          q(i,5) = 0.d0
          q(i,6) = 0.d0
          q(i,7) = 0.d0
          q(i,8) = 0.d0
        end do
      else if (final_state > 0) then
        ! calculate 2to6 kinematics in parton cm frame
        phit = 2.d0*pi*ran(jseed)
        m356min = m3 + m5 + m6
        m356max = ecm - m4 - m7 - m8
        xx356min = atan(((m356min)**2 - rmt**2)/rmt/gamt)
        xx356max = atan(((m356max)**2 - rmt**2)/rmt/gamt)
        xx = x(13)*(xx356max - xx356min) + xx356min
        rl356 = tan(xx)*rmt*gamt
        m356_2 = (rmt**2 + rl356)
        if (m356_2 < 0.d0) then
          fffxn = 0.d0
          return
        else
          m356 = sqrt(m356_2)
        endif
        m478min = m4 + m7 + m8
        m478max = ecm - m356
        xx478min = atan(((m478min)**2 - rmt**2)/rmt/gamt)
        xx478max = atan(((m478max)**2 - rmt**2)/rmt/gamt)
        xx = x(12)*(xx478max - xx478min) + xx478min
        rl478 = tan(xx)*rmt*gamt
        m478_2 = (rmt**2 + rl478)
        if (m478_2 < 0.d0) then
          fffxn = 0.d0
          return
        else
          m478 = sqrt(m478_2)
        endif
        m56min = m5 + m6
        m56max = m356 - m3
        xx56min = atan(((m56min)**2 - rm_w**2)/rm_w/gamma_w)
        xx56max = atan(((m56max)**2 - rm_w**2)/rm_w/gamma_w)
        xx = x(11)*(xx56max - xx56min) + xx56min
        rl56 = tan(xx)*rm_w*gamma_w
        m56_2 = (rm_w**2 + rl56)
        if (m56_2 < 0.d0) then
          fffxn = 0.d0
          return
        else
          m56 = sqrt(m56_2)
        endif
        m78min = m7 + m8
        m78max = m478 - m4
        xx78min = atan(((m78min)**2 - rm_w**2)/rm_w/gamma_w)
        xx78max = atan(((m78max)**2 - rm_w**2)/rm_w/gamma_w)
        xx = x(10)*(xx78max - xx78min) + xx78min
        rl78 = tan(xx)*rm_w*gamma_w
        m78_2 = (rm_w**2 + rl78)
        if (m78_2 < 0.d0) then
          fffxn = 0.d0
          return
        else
          m78 = sqrt(m78_2)
        endif
        if (jx == 1) then
          ct = x(9)
        else if (jx == 2) then
          ct =  - x(9)
        else
          print *, 'invalid jx.'
        end if
        st = sqrt(abs(1.d0 - ct*ct))
        ct56 = x(8)
        st56 = sqrt(1.d0 - ct56*ct56)
        ct78 = x(7)
        st78 = sqrt(1.d0 - ct78*ct78)
        ct5 = x(6)
        st5 = sqrt(1.d0 - ct5*ct5)
        ct7 = x(5)
        st7 = sqrt(1.d0 - ct7*ct7)
        cf56 = cos(x(4))
        sf56 = sin(x(4))
        cf78 = cos(x(3))
        sf78 = sin(x(3))
        cf5 = cos(x(2))
        sf5 = sin(x(2))
        cf7 = cos(x(1))
        sf7 = sin(x(1))
        rq2 = ((ecm*ecm - m356*m356 - m478*m478)**2 &
         - (2.d0*m356*m478)**2)/(4.d0*ecm*ecm)
        if (rq2 < 0.d0) then
          fffxn = 0.d0
          return
        else
          rq = sqrt(rq2)
        endif
        p356(3) = rq*ct
        p356(2) = rq*st*cos(phit)
        p356(1) = rq*st*sin(phit)
        p356(4) = sqrt(rq2 + m356*m356)
        rq562 = ((m356*m356 - m3*m3 - m56*m56)**2 - (2.d0*m3*m56)**2)/(4.d0*m356*m356)
        if (rq562 < 0.d0) then
          fffxn = 0.d0
          return
        else
          rq56 = sqrt(rq562)
        endif
        q56(3) = rq56*st56*cf56
        q56(2) = rq56*st56*sf56
        q56(1) = rq56*ct56
        q56(4) = sqrt(rq562 + m56*m56)
        pq56 = 0.d0
        do i = 1,3
          pq56 = pq56 + p356(i)*q56(i)
        end do
        p56(4) = (p356(4)*q56(4) + pq56)/m356
        q(4,3) = p356(4) - p56(4)
        do i = 1,3
          p56(i) = q56(i) + p356(i)*(p56(4) + q56(4))/(p356(4) + m356)
          q(i,3) = p356(i) - p56(i)
        end do
        do i = 1,3
          p478(i) =  - p356(i)
        end do
        p478(4) = sqrt(rq2 + m478*m478)
        rq782 = ((m478*m478 - m4*m4 - m78*m78)**2 - (2.d0*m4*m78)**2)/(4.d0*m478*m478)
        if (rq782 < 0.d0) then
          fffxn = 0.d0
          return
        else
          rq78 = sqrt(rq782)
        endif
        q78(3) = rq78*st78*cf78
        q78(2) = rq78*st78*sf78
        q78(1) = rq78*ct78
        q78(4) = sqrt(rq782 + m78*m78)
        pq78 = 0.d0
        do i = 1,3
          pq78 = pq78 + p478(i)*q78(i)
        end do
        p78(4) = (p478(4)*q78(4) + pq78)/m478
        q(4,4) = p478(4) - p78(4)
        do i = 1,3
          p78(i) = q78(i) + p478(i)*(p78(4) + q78(4))/(p478(4) + m478)
          q(i,4) = p478(i) - p78(i)
        end do
        rq52 = ((m56*m56 - m5*m5 - m6*m6)**2 - (2.d0*m5*m6)**2)/(4.d0*m56*m56)
        if (rq52 < 0.d0) then
          fffxn = 0.d0
          return
        else
          rq5 = sqrt(rq52)
        endif
        q5(3) = rq5*st5*cf5
        q5(2) = rq5*st5*sf5
        q5(1) = rq5*ct5
        q5(4) = sqrt(rq52 + m5*m5)
        pq5 = 0.d0
        do i = 1,3
          pq5 = pq5 + p56(i)*q5(i)
        end do
        q(4,5) = (p56(4)*q5(4) + pq5)/m56
        q(4,6) = p56(4) - q(4,5)
        do i = 1,3
          q(i,5) = q5(i) + p56(i)*(q(4,5) + q5(4))/(p56(4) + m56)
          q(i,6) = p56(i) - q(i,5)
        end do
        rq72 = ((m78*m78 - m7*m7 - m8*m8)**2 - (2.d0*m7*m8)**2)/(4.d0*m78*m78)
        if (rq72 < 0.d0) then
          fffxn = 0.d0
          return
        else
          rq7 = sqrt(rq72)
        endif
        q7(3) = rq7*st7*cf7
        q7(2) = rq7*st7*sf7
        q7(1) = rq7*ct7
        q7(4) = sqrt(rq72 + m7*m7)
        pq7 = 0.d0
        do i = 1,3
          pq7 = pq7 + p78(i)*q7(i)
        end do
        q(4,7) = (p78(4)*q7(4) + pq7)/m78
        q(4,8) = p78(4) - q(4,7)
        do i = 1,3
          q(i,7) = q7(i) + p78(i)*(q(4,7) + q7(4))/(p78(4) + m78)
          q(i,8) = p78(i) - q(i,7)
        end do
      end if

      ! velocity of ttbar system in collider frame
      vcol = (x1 - x2)/(x1 + x2)

      ! 
      gcol = (x1 + x2)/2.d0/sqrt(x1*x2)

      ! boost initial and final state momenta to the collider frame
      do i = 1, n_final
        qcol(4, i) = gcol*(q(4, i) + vcol*q(3, i))
        qcol(3, i) = gcol*(q(3, i) + vcol*q(4, i))
        qcol(2, i) = q(2, i)
        qcol(1, i) = q(1, i)
      end do

      if (final_state == 0) then
        ! assign 2to2 madgraph momenta    
        do i = 1, 3
          p1(i) = q(i,1)
          p2(i) = q(i,2)
          p3(i) = q(i,3)
          p4(i) = q(i,4)
          p5(i) = 0.d0
          p6(i) = 0.d0
          p7(i) = 0.d0
          p8(i) = 0.d0
        end do
        p1(0) = q(4,1)
        p2(0) = q(4,2)
        p3(0) = q(4,3)
        p4(0) = q(4,4)
        p5(0) = 0.d0
        p6(0) = 0.d0
        p7(0) = 0.d0
        p8(0) = 0.d0

        ! check 2to2 kinematics
        ! print *,  'p1  =',p1
        ! print *,  'p2  =',p2
        ! print *,  'p3  =',p3
        ! print *,  'p4  =',p4
        ! delta_e=p1(0)+p2(0)-p3(0)-p4(0)
        ! delta_x=p1(1)+p2(1)-p3(1)-p4(1)
        ! delta_y=p1(2)+p2(2)-p3(2)-p4(2)
        ! delta_z=p1(3)+p2(3)-p3(3)-p4(3)
        ! print *,  'delta_e=',delta_e
        ! print *,  'delta_x=',delta_x
        ! print *,  'delta_y=',delta_y
        ! print *,  'delta_z=',delta_z
        ! rmassa1=sqrt(abs(p1(0)**2-p1(1)**2-p1(2)**2-p1(3)**2))
        ! rmassa2=sqrt(abs(p2(0)**2-p2(1)**2-p2(2)**2-p2(3)**2))
        ! rmassa3=sqrt(abs(p3(0)**2-p3(1)**2-p3(2)**2-p3(3)**2))
        ! rmassa4=sqrt(abs(p4(0)**2-p4(1)**2-p4(2)**2-p4(3)**2))
        ! print *,  'rm_1 =',rmassa1
        ! print *,  'rm_2 =',rmassa2
        ! print *,  'rm_3 =',rmassa3
        ! print *,  'rm_4 =',rmassa4


      else if (final_state > 0) then
        ! assign 2to6 madgraph momenta
        do i = 1, 3
          p1(i) = q(i,1)
          p2(i) = q(i,2)
          p3(i) = q(i,3)
          p4(i) = q(i,4)
          p5(i) = q(i,5)
          p6(i) = q(i,6)
          p7(i) = q(i,7)
          p8(i) = q(i,8)
        end do
        p1(0) = q(4,1)
        p2(0) = q(4,2)
        p3(0) = q(4,3)
        p4(0) = q(4,4)
        p5(0) = q(4,5)
        p6(0) = q(4,6)
        p7(0) = q(4,7)
        p8(0) = q(4,8)

        ! collider 4-momentum 
        do i = 1, 3
          p1col(i) = qcol(i,1)
          p2col(i) = qcol(i,2)
          p3col(i) = qcol(i,3)
          p4col(i) = qcol(i,4)
          p5col(i) = qcol(i,5)
          p6col(i) = qcol(i,6)
          p7col(i) = qcol(i,7)
          p8col(i) = qcol(i,8)
        end do
        p1col(0) = qcol(4,1)
        p2col(0) = qcol(4,2)
        p3col(0) = qcol(4,3)
        p4col(0) = qcol(4,4)
        p5col(0) = qcol(4,5)
        p6col(0) = qcol(4,6)
        p7col(0) = qcol(4,7)
        p8col(0) = qcol(4,8)

      ! check 6-body kinematics
      !       print *,  'p1  =',p1
      !       print *,  'p2  =',p2
      !       print *,  'p3  =',p3
      !       print *,  'p4  =',p4
      !       print *,  'p5  =',p5
      !       print *,  'p6  =',p6
      !       print *,  'p7  =',p7
      !       print *,  'p8  =',p8
      ! ! check conservation of 4-momentum.
      !       delta_e=p1(0)+p2(0)
      !    &         -p3(0)-p4(0)
      !    &         -p5(0)-p6(0)
      !    &         -p7(0)-p8(0)
      !       delta_x=p1(1)+p2(1)
      !    &         -p3(1)-p4(1)
      !    &         -p5(1)-p6(1)
      !    &         -p7(1)-p8(1)
      !       delta_y=p1(2)+p2(2)
      !    &         -p3(2)-p4(2)
      !    &         -p5(2)-p6(2)
      !    &         -p7(2)-p8(2)
      !       delta_z=p1(3)+p2(3)
      !    &         -p3(3)-p4(3)
      !    &         -p5(3)-p6(3)
      !    &         -p7(3)-p8(3)
      !       print *,  'delta_e=',delta_e
      !       print *,  'delta_px=',delta_x
      !       print *,  'delta_py=',delta_y
      !       print *,  'delta_pz=',delta_z
      ! ! check invarient mass.
      !       rmassa1=sqrt(abs(p1(0)**2-p1(1)**2-p1(2)**2-p1(3)**2))
      !       rmassa2=sqrt(abs(p2(0)**2-p2(1)**2-p2(2)**2-p2(3)**2))
      !       rmassa3=sqrt(abs(p3(0)**2-p3(1)**2-p3(2)**2-p3(3)**2))
      !       rmassa4=sqrt(abs(p4(0)**2-p4(1)**2-p4(2)**2-p4(3)**2))
      !       rmassa5=sqrt(abs(p5(0)**2-p5(1)**2-p5(2)**2-p5(3)**2))
      !       rmassa6=sqrt(abs(p6(0)**2-p6(1)**2-p6(2)**2-p6(3)**2))
      !       rmassa7=sqrt(abs(p7(0)**2-p7(1)**2-p7(2)**2-p7(3)**2))
      !       rmassa8=sqrt(abs(p8(0)**2-p8(1)**2-p8(2)**2-p8(3)**2))
      !       print *,  'rm_1 =',rmassa1
      !       print *,  'rm_2 =',rmassa2
      !       print *,  'rm_3 =',rmassa3
      !       print *,  'rm_4 =',rmassa4
      !       print *,  'rm_5 =',rmassa5
      !       print *,  'rm_6 =',rmassa6
      !       print *,  'rm_7 =',rmassa7
      !       print *,  'rm_8 =',rmassa8
      ! ! check missing momentum
      !       pt682=(qcol(1,6)+qcol(1,8))**2+(qcol(2,6)+qcol(2,8))**2
      !       pt68=sqrt(pt682)
      !       print *, 'etmiss :',etmiss
      !       print *, 'pt(v+v):',pt68
      end if

    
      ! additional kinematics
      ! these aren't required for the integration, but are used for
      ! distributions and cuts.

      if (final_state == 2) then
        ! reconstruct the neutrino momentum in the semi-hadronic channel
        do i = 1, 2
          pT8col(i) = p8col(i)
          p8col_reco = p8col(i)
        end do
        p8col_reco(3) = longitudinal_neutrino_momentum(p7col, pT8col)
        p8col_reco(0) = sqrt(p8col_reco(1)*p8col_reco(1) + p8col_reco(2)*p8col_reco(2) + p8col_reco(3)*p8col_reco(3))
      end if

      ! calculate transverse momenta (pt)
      do ip = 1, n_final
        pt2(ip) = qcol(1,ip)**2 + qcol(2,ip)**2
        pt(ip) = sqrt(pt2(ip))
      end do

      ! calculate rapidity (collider frame)
      do ip = 3, n_final
        ycol(ip) = 0.5d0*log((qcol(4,ip) + qcol(3,ip)) &
        /(qcol(4,ip) - qcol(3,ip)))
      end do

      ! calculate pseudorapidity (eta) com frame
      do ip = 1, n_final
        rps(ip) = (q(3, ip))/sqrt(q(1, ip)**2 + q(2, ip)**2 + q(3, ip)**2)
        if (rps(ip) < -1.d0) rps = -1.d0
        if (rps(ip) > +1.d0) rps = +1.d0
        rpl(ip) = acos(rps(ip))
        arg(ip) = tan(rpl(ip)/2d0)
        if (arg(ip) <= 0.d0) arg(ip) = 1.d-9
        eta(ip) = -log(arg(ip))
      end do

      ! calculate azimuthal angle (phi) in lab frame
      do ip = 1, n_final
        phi(ip) = atan2(qcol(2, ip), qcol(1, ip))
      end do

      ! calculate delta phi
      if (final_state == 1) then
        dphi = abs(phi(5) - phi(7))
      end if

      ! calculate visible and missing transverse momentum
      if (final_state == 1) then
        etvis2 = 0d0
        etmiss2 = 0d0
        do i = 1, 2
          ptvis(i) = qcol(i, 3) + qcol(i, 4) + qcol(i, 5) + qcol(i, 7)
          ptmiss(i) = -ptvis(i)
          etvis2 = etvis2 + ptvis(i)**2
          etmiss2 = etmiss2 + ptmiss(i)**2
        end do
        etvis = sqrt(etvis2)
        etmiss = sqrt(etmiss2)
      end if

      ! calculate truth level top/antitop pt, eta and phi
      if (final_state > 0) then
        pt356 = sqrt((qcol(1,3) + qcol(1,5) + qcol(1,6))**2 &
                     + (qcol(2,3) + qcol(2,5) + qcol(2,6))**2)

        pt478 = sqrt((qcol(1,4) + qcol(1,7) + qcol(1,8))**2 &
                     + (qcol(2,4) + qcol(2,7) + qcol(2,8))**2)

        rps356 = (q(3, 3) + q(3, 5) + q(3, 6)) &
        /sqrt((q(1, 3) + q(1, 5) + q(1, 6))**2 &
              +(q(2, 3) + q(2, 5) + q(2, 6))**2 &
              +(q(3, 3) + q(3, 5) + q(3, 6))**2)
        if (rps356 < -1.d0) rps = -1.d0
        if (rps356 > +1.d0) rps = +1.d0
        rpl356 = acos(rps356)
        arg356 = tan(rpl356/2d0)
        if (arg356 <= 0.d0)arg356 = 1.d-9
        eta356 = -log(arg356)

        rps478=(q(3,4)+q(3,7)+q(3,8)) &
        /sqrt((q(1,4)+q(1,7)+q(1,8))**2 &
        +(q(2,4)+q(2,7)+q(2,8))**2 &
        +(q(3,4)+q(3,7)+q(3,8))**2)
        if (rps478 < -1.d0)rps=-1.d0
        if (rps478 > +1.d0)rps=+1.d0
        rpl478=acos(rps478)
        arg478=tan(rpl478/2d0)
        if (arg478 <= 0.d0)arg478=1.d-9
        eta478=-log(arg478)

        phi356=atan2(qcol(2,3)+qcol(2,5)+qcol(2,6) &
        ,qcol(1,3)+qcol(1,5)+qcol(1,6))
        phi478=atan2(qcol(2,4)+qcol(2,7)+qcol(2,8) &
        ,qcol(1,4)+qcol(1,7)+qcol(1,8))
      end if
    ! calculate cos(theta_t)
      if (final_state == 0) then
        cost= &
        (qcol(1,3)*qcol(1,1) &
        +qcol(2,3)*qcol(2,1) &
        +qcol(3,3)*qcol(3,1)) &
        /sqrt(qcol(1,3)*qcol(1,3) &
        +qcol(2,3)*qcol(2,3) &
        +qcol(3,3)*qcol(3,3)) &
        /sqrt(qcol(1,1)*qcol(1,1) &
        +qcol(2,1)*qcol(2,1) &
        +qcol(3,1)*qcol(3,1))
      else if (final_state > 0) then
        cost= &
        ((qcol(1,3)+qcol(1,5)+qcol(1,6))*qcol(1,1) &
        +(qcol(2,3)+qcol(2,5)+qcol(2,6))*qcol(2,1) &
        +(qcol(3,3)+qcol(3,5)+qcol(3,6))*qcol(3,1)) &
        /sqrt((qcol(1,3)+qcol(1,5)+qcol(1,6)) &
        *(qcol(1,3)+qcol(1,5)+qcol(1,6)) &
        +(qcol(2,3)+qcol(2,5)+qcol(2,6)) &
        *(qcol(2,3)+qcol(2,5)+qcol(2,6)) &
        +(qcol(3,3)+qcol(3,5)+qcol(3,6)) &
        *(qcol(3,3)+qcol(3,5)+qcol(3,6))) &
        /sqrt(qcol(1,1)*qcol(1,1) &
        +qcol(2,1)*qcol(2,1) &
        +qcol(3,1)*qcol(3,1))
      end if
    ! calculate cos(theta^*_t)
      if (final_state == 0) then
        costheta_top_cm=(q(1,3)*q(1,1) &
        +q(2,3)*q(2,1) &
        +q(3,3)*q(3,1)) &
        /sqrt(q(1,3)*q(1,3) &
        +q(2,3)*q(2,3) &
        +q(3,3)*q(3,3)) &
        /sqrt(q(1,1)*q(1,1) &
        +q(2,1)*q(2,1) &
        +q(3,1)*q(3,1))
      else if (final_state > 0) then
        costheta_top_cm= &
        ((q(1,3)+q(1,5)+q(1,6))*q(1,1) &
        +(q(2,3)+q(2,5)+q(2,6))*q(2,1) &
        +(q(3,3)+q(3,5)+q(3,6))*q(3,1)) &
        /sqrt((q(1,3)+q(1,5)+q(1,6)) &
        *(q(1,3)+q(1,5)+q(1,6)) &
        +(q(2,3)+q(2,5)+q(2,6)) &
        *(q(2,3)+q(2,5)+q(2,6)) &
        +(q(3,3)+q(3,5)+q(3,6)) &
        *(q(3,3)+q(3,5)+q(3,6))) &
        /sqrt(q(1,1)*q(1,1) &
        +q(2,1)*q(2,1) &
        +q(3,1)*q(3,1))
      end if
    ! calculate the energy of the top
      if (final_state == 0) then
        et=qcol(4,3)
      else if (final_state > 0) then
        et=qcol(4,3)+qcol(4,5)+qcol(4,6)
      end if

    ! calculate rapidity of the tt system
      ytt = 0.5d0*log(x1/x2)

    ! calculate mtt
      if (final_state == 0) then
        mtt2=(qcol(4,3)+qcol(4,4))**2
        do i=1,3
          mtt2=mtt2-(qcol(i,3)+qcol(i,4))**2
        end do
      else if (final_state > 0) then
        mtt2=(qcol(4,3)+qcol(4,4) &
        +qcol(4,5)+qcol(4,6) &
        +qcol(4,7)+qcol(4,8))**2
        do i=1,3
          mtt2=mtt2-(qcol(i,3)+qcol(i,4) &
          +qcol(i,5)+qcol(i,6) &
          +qcol(i,7)+qcol(i,8))**2
        end do
      end if
      mtt=sqrt(abs(mtt2))

      if (final_state == 2) then
        ! calculate Mtt_reco
        mtt_reco2 = (qcol(4,3) + qcol(4,4) &
                + qcol(4,5) + qcol(4,6) &
                + qcol(4,7) + p8col_reco(0))**2
        do i=1,3
          mtt_reco2 = mtt_reco2-(qcol(i,3) + qcol(i,4) &
                       + qcol(i,5) + qcol(i,6) &
                       + qcol(i,7) + p8col_reco(i))**2
        end do
        mtt_reco = sqrt(mtt_reco2)
      end if

    ! calculate invariant mass of visible decay products
      if (o_tran(1) == 1) then
        rmvis2=(qcol(4,3)+qcol(4,4) &
        +qcol(4,5)+qcol(4,7))**2
        do i=1,3
          rmvis2=rmvis2-(qcol(i,3)+qcol(i,4) &
          +qcol(i,5)+qcol(i,7))**2
        end do
        trans(1)=sqrt(abs(rmvis2))
      end if

    ! calculate transverse energy energies of visible particles
      if (final_state > 0) then
        et3=sqrt(m3**2+pt2(3))
        et4=sqrt(m4**2+pt2(4))
        et5=sqrt(m5**2+pt2(5))
        et7=sqrt(m6**2+pt2(7))
      end if
    ! calculate ht
      if (o_tran(2) == 1) then
        trans(2)=et3+et4+et5+et7+etmiss
      end if

    ! calculate *full* transverse mass 1
      if (o_tran(3) == 1) then
        rm_t12=(et3+et4+et5+et7+etmiss)**2 &
        +(pt(3)+pt(4)+pt(5)+pt(7)+etmiss)**2
        trans(3)=sqrt(abs(rm_t12))
      end if
    ! calculate *full* transverse mass 2
      if (o_tran(4) == 1) then
        rm_t22=(et3+et4+et5+et7+etmiss)**2
        do i=1,2
          rm_t22=rm_t22-(ptvis(i)+ptmiss(i))**2
        end do
        trans(4)=sqrt(abs(rm_t22))
      end if
    ! calculate *full* transverse mass 3
      if (o_tran(5) == 1) then
        rm_t32=(etvis+etmiss)**2
        do i=1,2
          rm_t32=rm_t32-(ptvis(i)+ptmiss(i))**2
        end do
        trans(5)=sqrt(abs(rm_t32))
      end if
    ! calculate lepton transverse mass
      if (o_tran(6) == 1) then
        et5=sqrt(m5**2+pt2(5))
        et7=sqrt(m7**2+pt2(7))
        rmlt2=(et5+et7)**2
        do i=1,2
          rmlt2=rmlt2-(qcol(i,5)+qcol(i,7))**2
        end do
        trans(6)=sqrt(abs(rmlt2))
      end if
    ! calculate *full* contranverse mass 1
      if (o_tran(7) == 1) then
        rm_ct12=(et3+et4+et5+et7+etmiss)**2 &
        +(pt(3)+pt(4)+pt(5)+pt(7)-etmiss)**2
        trans(7)=sqrt(abs(rm_ct12))
      end if
    ! calculate *full* contranverse mass 2
      if (o_tran(8) == 1) then
        rm_ct22=(et3+et4+et5+et7+etmiss)**2
        do i=1,2
          rm_ct22=rm_ct22-(ptvis(i)-ptmiss(i))**2
        end do
        trans(8)=sqrt(abs(rm_ct22))
      end if
    ! calculate *full* contranverse mass 3
      if (o_tran(9) == 1) then
        rm_ct32=(etvis+etmiss)**2
        do i=1,2
          rm_ct32=rm_ct32-(ptvis(i)-ptmiss(i))**2
        end do
        trans(9)=sqrt(abs(rm_ct32))
      end if
    ! calculate lepton contransverse mass
      if (o_tran(10) == 1) then
        et5=sqrt(m5**2+pt2(5))
        et7=sqrt(m7**2+pt2(7))
        rmlct2=(et5+et7)**2
        do i=1,2
          rmlct2=rmlct2-(qcol(i,5)-qcol(i,7))**2
        end do
        trans(10)=sqrt(abs(rmlct2))
      end if
    ! calculate top pseudorapidity
      if (final_state > 0) then
        rps356=(q(3,3)+q(3,5)+q(3,6)) &
        /sqrt((q(1,3)+q(1,5)+q(1,6))**2 &
        +(q(2,3)+q(2,5)+q(2,6))**2 &
        +(q(3,3)+q(3,5)+q(3,6))**2)
        if (rps356 < -1.d0)rps=-1.d0
        if (rps356 > +1.d0)rps=+1.d0
        rpl356=acos(rps356)
        arg356=tan(rpl356/2d0)
        if (arg356 <= 0.d0)arg356=1.d-9
        eta356=-log(arg356)

        rps478=(q(3,4)+q(3,7)+q(3,8)) &
        /sqrt((q(1,4)+q(1,7)+q(1,8))**2 &
        +(q(2,4)+q(2,7)+q(2,8))**2 &
        +(q(3,4)+q(3,7)+q(3,8))**2)
        if (rps478 < -1.d0)rps=-1.d0
        if (rps478 > +1.d0)rps=+1.d0
        rpl478=acos(rps478)
        arg478=tan(rpl478/2d0)
        if (arg478 <= 0.d0)arg478=1.d-9
        eta478=-log(arg478)   ! no cuts on pseudorapidity yet
      end if
    ! calculate rapidity (y) of top and antitop
      if (final_state == 0) then
        yt= 0.5*log((qcol(4,3)+qcol(3,3))/(qcol(4,3)-qcol(3,3)))
        ytb=0.5*log((qcol(4,4)+qcol(3,4))/(qcol(4,4)-qcol(3,4)))
      else if (final_state > 0) then
        yt =0.5*log((qcol(4,3)+qcol(4,5)+qcol(4,6) &
        +qcol(3,3)+qcol(3,5)+qcol(3,6)) &
        /(qcol(4,3)+qcol(4,5)+qcol(4,6) &
        -qcol(3,3)-qcol(3,5)-qcol(3,6)))
        ytb=0.5*log((qcol(4,4)+qcol(4,7)+qcol(4,8) &
        +qcol(3,4)+qcol(3,7)+qcol(3,8)) &
        /(qcol(4,4)+qcol(4,7)+qcol(4,8) &
        -qcol(3,4)-qcol(3,7)-qcol(3,8)))
      end if

      ! calculate delta_absy for arfb
      delta_absy = abs(yt) - abs(ytb)

      ! calculate cos(theta_l+)
      if (final_state > 0) then
        costheta5=+(q(1,5)*q(1,1) &
        +q(2,5)*q(2,1) &
        +q(3,5)*q(3,1)) &
        /sqrt(q(1,5)*q(1,5) &
        +q(2,5)*q(2,5) &
        +q(3,5)*q(3,5)) &
        /sqrt(q(1,1)*q(1,1) &
        +q(2,1)*q(2,1) &
        +q(3,1)*q(3,1))
      end if
    ! calculate cos(theta_l-)
      if (final_state > 0) then
        costheta7=+(q(1,7)*q(1,1) &
        +q(2,7)*q(2,1) &
        +q(3,7)*q(3,1)) &
        /sqrt(q(1,7)*q(1,7) &
        +q(2,7)*q(2,7) &
        +q(3,7)*q(3,7)) &
        /sqrt(q(1,1)*q(1,1) &
        +q(2,1)*q(2,1) &
        +q(3,1)*q(3,1))
      end if

      if (final_state > 0) then
        ct7ct5=costheta7*costheta5
      end if

      costheta_top_star=int(ytt/abs(ytt))*costheta_top_cm
    ! calculate cos(phi_l) (lepton azimuthal angle)
      if (final_state > 0) then
        p5m=sqrt(q(1,5)*q(1,5)+q(2,5)*q(2,5)+q(3,5)*q(3,5))

      ! p(1)^ is z^
        do i=1,3
          zp(i)=q(i,1)/sqrt(q(1,1)*q(1,1)+q(2,1)*q(2,1)+q(3,1)*q(3,1))
        end do

      ! p(5)_t^ is x^
        do i=1,2
          xp(i)=p356(i)/sqrt(p356(1)*p356(1)+p356(2)*p356(2))
        end do
        xp(3)=0

      ! y^ obtained using cross product
        yp(1) = zp(2) * xp(3) - zp(3) * xp(2)
        yp(2) = zp(3) * xp(1) - zp(1) * xp(3)
        yp(3) = zp(1) * xp(2) - zp(2) * xp(1)

        p5xp=0
        do i=1,3
          p5xp=p5xp+q(i,5)*xp(i)
        end do
        p5yp=0
        do i=1,3
          p5yp=p5yp+q(i,5)*yp(i)
        end do
        p5zp=0
        do i=1,3
          p5zp=p5zp+q(i,5)*zp(i)
        end do

        p5mp=sqrt(p5xp*p5xp+p5yp*p5yp+p5zp*p5zp)

        if (abs(p5m-p5mp) >= 1e-11)print *, 'error in coord transform.'

        phi_l=atan2(p5yp,p5xp)

        if (phi_l < 0)phi_l=phi_l+2*pi

        cosfl=cos(phi_l)
      end if
    
    ! selections
    ! cut on top pt
      if (final_state == 0) then
        if (abs(eta(3)) > ytmax) then
          fffxn=0.d0
          return
        end if
      else if (abs(eta356) > ytmax) then
        fffxn=0.d0
        return
      end if

    ! matrix elements
    ! phase space only
    ! set |m|^2 =1 (for bug squishing) and skip matrix element calculation
      if (phase_space_only == 1) then
        if (ix == 1) then
          pfx1tot=0.5/x1
          pfx2tot=0.5/x1
        else if (ix == 2) then
          pfx1tot=0.5/x2
          pfx2tot=0.5/x2
        end if
        if (final_state == 0) then
          do lam3=-1,1,2
            do lam4=-1,1,2
              if (ix == 1) then
                pfx1(lam3,lam4)=0.5/x1/(pfx1tot+pfx2tot)
                pfx2(lam3,lam4)=0.5/x1/(pfx1tot+pfx2tot)
              else if (ix == 2) then
                pfx1(lam3,lam4)=0.5/x2/(pfx1tot+pfx2tot)
                pfx2(lam3,lam4)=0.5/x2/(pfx1tot+pfx2tot)
              end if
            end do
          end do
        end if
        go to 666
      end if
    
    ! square matrix elements
    ! calculate strong coupling
      a_s=alfas(qq,rlambdaqcd4,nloops)
      gs2=4.d0*pi*a_s
      gs=sqrt(gs2)

    ! (do not change the deliberate order of p6 and p7 in the ew code.)
    ! initilize
      qcdqq1=0
      qcdbb1=0
      qcdgg1=0
      ewzuu1=0
      ewzdd1=0
      ewzbb1=0
      qcdqq2=0
      qcdbb2=0
      qcdgg2=0
      ewzuu2=0
      ewzdd2=0
      ewzbb2=0
      do ii=-1,1,1
        do jj=-1,1,1
          qcdpolqq1(ii,jj)=0
          qcdpolbb1(ii,jj)=0
          qcdpolgg1(ii,jj)=0
          ewzpoluu1(ii,jj)=0
          ewzpoldd1(ii,jj)=0
          ewzpolbb1(ii,jj)=0
          qcdpolqq2(ii,jj)=0
          qcdpolbb2(ii,jj)=0
          qcdpolgg2(ii,jj)=0
          ewzpoluu2(ii,jj)=0
          ewzpoldd2(ii,jj)=0
          ewzpolbb2(ii,jj)=0
          do kk=1,20
            weight(kk,ii,jj)=0.d0
          end do
        end do
      end do
      resall=0
      if (final_state == 0) then
        ! compute 2to2 mes
        if (include_qcd == 1) then
          ! compute qcd square matrix elements
          do lam3=-1,1,2
            do lam4=-1,1,2
              qcdpolgg1(lam3,lam4)=sggff_qcd(   p1,p2,p3,p4,lam3,lam4)*gs**4
              qcdpolgg2(lam3,lam4)=sggff_qcd(   p2,p1,p3,p4,lam3,lam4)*gs**4
              qcdpolqq1(lam3,lam4)=sqqff_qcd(3 ,p1,p2,p3,p4,lam3,lam4)*gs**4
              qcdpolqq2(lam3,lam4)=sqqff_qcd(3 ,p2,p1,p3,p4,lam3,lam4)*gs**4
              qcdpolbb1(lam3,lam4)=sqqff_qcd(12,p1,p2,p3,p4,lam3,lam4)*gs**4
              qcdpolbb2(lam3,lam4)=sqqff_qcd(12,p2,p1,p3,p4,lam3,lam4)*gs**4
              resall=resall &
              +qcdpolgg1(lam3,lam4) &
              +qcdpolgg2(lam3,lam4) &
              +qcdpolqq1(lam3,lam4) &
              +qcdpolqq2(lam3,lam4) &
              +qcdpolbb1(lam3,lam4) &
              +qcdpolbb2(lam3,lam4)
            end do
          end do
        end if
        if ((include_ew == 1) .or. (include_bsm == 1)) then
          ! compute ew and z' square matrix elements
          do lam3=-1,1,2
            do lam4=-1,1,2
              ewzpoluu1(lam3,lam4)=sqqff_ewp( 3,11,p1,p2,p3,p4,lam3,lam4)
              ewzpoluu2(lam3,lam4)=sqqff_ewp( 3,11,p2,p1,p3,p4,lam3,lam4)
              ewzpoldd1(lam3,lam4)=sqqff_ewp( 4,11,p1,p2,p3,p4,lam3,lam4)
              ewzpoldd2(lam3,lam4)=sqqff_ewp( 4,11,p2,p1,p3,p4,lam3,lam4)
              ewzpolbb1(lam3,lam4)=sqqff_ewp(12,11,p1,p2,p3,p4,lam3,lam4)
              ewzpolbb2(lam3,lam4)=sqqff_ewp(12,11,p2,p1,p3,p4,lam3,lam4)
              resall=resall &
             +ewzpoluu1(lam3,lam4) &
             +ewzpoluu2(lam3,lam4) &
             +ewzpoldd1(lam3,lam4) &
             +ewzpoldd2(lam3,lam4) &
             +ewzpolbb1(lam3,lam4) &
             +ewzpolbb2(lam3,lam4)
            end do
          end do
        end if

      else if (final_state > 0) then
        ! 6-body mes
        if (include_qcd == 1) then
          ! compute qcd square matrix elements
          qcdqq1=sqqbbffff_qcd(3 , p1, p2, p3, p4, p5, p7, p6, p8 )
          qcdqq2=sqqbbffff_qcd(3 , p2, p1, p3, p4, p5, p7, p6, p8 )
          qcdbb1=sqqbbffff_qcd(12, p1, p2, p3, p4, p5, p7, p6, p8 )
          qcdbb2=sqqbbffff_qcd(12, p2, p1, p3, p4, p5, p7, p6, p8 )
          qcdgg1=sggbbffff_qcd(    p1, p2, p3, p4, p5, p7, p6, p8 )
          qcdgg2=sggbbffff_qcd(    p2, p1, p3, p4, p5, p7, p6, p8 )
        end if
        if ((include_ew == 1) .or. (include_bsm == 1)) then
          ! compute ew and z' square matrix elements
          ewzuu1=sqqbbffff_ewp( 3,11, p1, p2, p3, p4, p5, p7, p6, p8)
          ewzuu2=sqqbbffff_ewp( 3,11, p2, p1, p3, p4, p5, p7, p6, p8)
          ewzdd1=sqqbbffff_ewp( 4,11, p1, p2, p3, p4, p5, p7, p6, p8)
          ewzdd2=sqqbbffff_ewp( 4,11, p2, p1, p3, p4, p5, p7, p6, p8)
          ewzbb1=sqqbbffff_ewp(12,11, p1, p2, p3, p4, p5, p7, p6, p8)
          ewzbb2=sqqbbffff_ewp(12,11, p2, p1, p3, p4, p5, p7, p6, p8)
        end if
        resall=qcdqq1+qcdgg1+qcdbb1+ewzuu1+ewzdd1+ewzbb1 &
        +qcdqq2+qcdgg2+qcdbb2+ewzuu2+ewzdd2+ewzbb2
      end if

      if ((resall) == 0.d0) then
        ! print *, '|m|^2 = 0 for phase space point ',npoints
        fffxn=0.d0
        return
      end if

      ! multiple qcd |m|^2 by g_s^4 (madgraph gs is set to one due to scale dependence.)
      qcdqq1=qcdqq1*gs**4
      qcdgg1=qcdgg1*gs**4
      qcdqq2=qcdqq2*gs**4
      qcdgg2=qcdgg2*gs**4

      ! sum over |m|^2 with pdfs for all initial partons    
      pfx1tot=0.d0
      pfx2tot=0.d0
      if (final_state == 0) then
        ! sum over all polarised |m|^2
        do lam3=-1,1,2
          do lam4=-1,1,2
            pfx1(lam3,lam4)=qcdpolgg1(lam3,lam4) *fx1(13)*fx2(13)/2.d0 &
            +(qcdpolqq1(lam3,lam4)+ewzpoldd1(lam3,lam4))*fx1( 1)*fx2( 7) &
            +(qcdpolqq1(lam3,lam4)+ewzpoluu1(lam3,lam4))*fx1( 2)*fx2( 8) &
            +(qcdpolqq1(lam3,lam4)+ewzpoldd1(lam3,lam4))*fx1( 3)*fx2( 9) &
            +(qcdpolqq1(lam3,lam4)+ewzpoluu1(lam3,lam4))*fx1( 4)*fx2(10) &
            +(qcdpolbb1(lam3,lam4)+ewzpolbb1(lam3,lam4))*fx1( 5)*fx2(11)
            pfx2(lam3,lam4)=qcdpolgg2(lam3,lam4) *fx1(13)*fx2(13)/2.d0 &
            +(qcdpolqq2(lam3,lam4)+ewzpoldd2(lam3,lam4))*fx1( 7)*fx2( 1) &
            +(qcdpolqq2(lam3,lam4)+ewzpoluu2(lam3,lam4))*fx1( 8)*fx2( 2) &
            +(qcdpolqq2(lam3,lam4)+ewzpoldd2(lam3,lam4))*fx1( 9)*fx2( 3) &
            +(qcdpolqq2(lam3,lam4)+ewzpoluu2(lam3,lam4))*fx1(10)*fx2( 4) &
            +(qcdpolbb2(lam3,lam4)+ewzpolbb2(lam3,lam4))*fx1(11)*fx2( 5)
            if (ix == 1) then
              pfx1(lam3,lam4)=pfx1(lam3,lam4)/x1
              pfx2(lam3,lam4)=pfx2(lam3,lam4)/x1
            else if (ix == 2) then
              pfx1(lam3,lam4)=pfx1(lam3,lam4)/x2
              pfx2(lam3,lam4)=pfx2(lam3,lam4)/x2
            end if
            pfx1tot=pfx1tot &
            +pfx1(lam3,lam4)
            pfx2tot=pfx2tot &
            +pfx2(lam3,lam4)
          end do
        end do

      else if (final_state > 0) then
        qqd1=fx1( 1)*fx2( 7)*(qcdqq1+ewzdd1) &
        +fx1( 2)*fx2( 8)*(qcdqq1+ewzuu1) &
        +fx1( 3)*fx2( 9)*(qcdqq1+ewzdd1) &
        +fx1( 4)*fx2(10)*(qcdqq1+ewzuu1) &
        +fx1( 5)*fx2(11)*(qcdbb1+ewzbb1)
        qqd2=fx1( 7)*fx2( 1)*(qcdqq2+ewzdd2) &
        +fx1( 8)*fx2( 2)*(qcdqq2+ewzuu2) &
        +fx1( 9)*fx2( 3)*(qcdqq2+ewzdd2) &
        +fx1(10)*fx2( 4)*(qcdqq2+ewzuu2) &
        +fx1(11)*fx2( 5)*(qcdbb2+ewzbb2)
        ggd1=fx1(13)*fx2(13)*qcdgg1/2.d0
        ggd2=fx1(13)*fx2(13)*qcdgg2/2.d0
        if (ix == 1) then
          pfx1tot=(qqd1+ggd1)/x1
          pfx2tot=(qqd2+ggd2)/x1
        else if (ix == 2) then
          pfx1tot=(qqd1+ggd1)/x2
          pfx2tot=(qqd2+ggd2)/x2
        end if
      end if

      if (pfx1tot == 0.d0 .and. pfx2tot == 0.d0) then
          ! print *, 'f(x1)f(x2)|m|^2 = 0 for phase space point ',npoints
          fffxn=0.d0
        return
      end if

      if (final_state == 0) then
        ! weight for distributions
        do lam3=-1,1,2
          do lam4=-1,1,2
            pfx1(lam3,lam4)=pfx1(lam3,lam4)/(pfx1tot+pfx2tot)
            pfx2(lam3,lam4)=pfx2(lam3,lam4)/(pfx1tot+pfx2tot)
          end do
        end do
      end if

      666 continue
    ! phase space volume
    ! jacobians from dx1 dx2 -> dx(2) dx(3)
      pfx1tot=pfx1tot*(1.d0-tau)*2.d0*ecm/s &
      *(ecm_max-m3-m4-m5-m6-m7-m8)
      pfx2tot=pfx2tot*(1.d0-tau)*2.d0*ecm/s &
      *(ecm_max-m3-m4-m5-m6-m7-m8)
    ! fffxn is now m*m*pdfs
      fffxn1=pfx1tot
      fffxn2=pfx2tot
    ! multiply by 2pi from phit integration and convert from gev^-2 to pb
      fffxn1=fffxn1*2.d0*pi*unit_conv
      fffxn2=fffxn2*2.d0*pi*unit_conv
      if (final_state == 0) then
      ! 2-body phase space factor
        fffxn1=fffxn1*qcm/(2.d0*pcm)*2.d0**(4-3*(2))
        fffxn1=fffxn1/2.d0/ecm/ecm*(2.d0*pi)**(4-3*(2))
        fffxn2=fffxn2*qcm/(2.d0*pcm)*2.d0**(4-3*(2))
        fffxn2=fffxn2/2.d0/ecm/ecm*(2.d0*pi)**(4-3*(2))
      else if (final_state > 0) then
      ! 6-body flux factor, pi's and phase space integral
        fffxn1=fffxn1*rq*rq56*rq78*rq5*rq7/ecm*256.d0*2.d0**(4-3*(6)) &
        /(2.d0*m356) &
        /rmt/gamt &
        *((m356*m356-rmt*rmt)**2+rmt**2*gamt**2)
        fffxn1=fffxn1*(xx356max-xx356min) &
        /(2.d0*m478) &
        /rmt/gamt &
        *((m478*m478-rmt*rmt)**2+rmt**2*gamt**2)
        fffxn1=fffxn1*(xx478max-xx478min) &
        /(2.d0*m56) &
        /rm_w/gamma_w &
        *((m56*m56-rm_w*rm_w)**2+rm_w**2*gamma_w**2)
        fffxn1=fffxn1*(xx56max-xx56min) &
        /(2.d0*m78) &
        /rm_w/gamma_w &
        *((m78*m78-rm_w*rm_w)**2+rm_w**2*gamma_w**2)
        fffxn1=fffxn1*(xx78max-xx78min)
      ! nwa
        fffxn1=fffxn1 &
        *gamt/gamma_t &
        *gamt/gamma_t
      ! flux and pi factors.
        fffxn1=fffxn1/2.d0/ecm/ecm*(2.d0*pi)**(4-3*(6))

        fffxn2=fffxn2*rq*rq56*rq78*rq5*rq7/ecm*256.d0*2.d0**(4-3*(6)) &
        /(2.d0*m356) &
        /rmt/gamt &
        *((m356*m356-rmt*rmt)**2+rmt**2*gamt**2)
        fffxn2=fffxn2*(xx356max-xx356min) &
        /(2.d0*m478) &
        /rmt/gamt &
        *((m478*m478-rmt*rmt)**2+rmt**2*gamt**2)
        fffxn2=fffxn2*(xx478max-xx478min) &
        /(2.d0*m56) &
        /rm_w/gamma_w &
        *((m56*m56-rm_w*rm_w)**2+rm_w**2*gamma_w**2)
        fffxn2=fffxn2*(xx56max-xx56min) &
        /(2.d0*m78) &
        /rm_w/gamma_w &
        *((m78*m78-rm_w*rm_w)**2+rm_w**2*gamma_w**2)
        fffxn2=fffxn2*(xx78max-xx78min)
      ! nwa
        fffxn2=fffxn2 &
        *gamt/gamma_t &
        *gamt/gamma_t
      ! flux and pi factors.
        fffxn2=fffxn2/2.d0/ecm/ecm*(2.d0*pi)**(4-3*(6))
      end if
      fffxn1=fffxn1/real(ixmax)/real(jxmax)
      fffxn2=fffxn2/real(ixmax)/real(jxmax)
      fffxn=fffxn1+fffxn2
    
    ! categorised cross sections / asymmetries
         
    ! polarised total cross sections
    ! polarised cross section for each point is calculated.
    ! (note that above pfx was divided by fffxn.)
      if (final_state == 0) then
        do iphel=-1,+1,2
          do jphel=-1,+1,2
            xsec_polar(it,iphel,jphel)=xsec_polar(it,iphel,jphel) &
            +fffxn &
            *wgt &
            *(pfx1(iphel,jphel) &
            +pfx2(iphel,jphel))
            weight(it,iphel,jphel)=+fffxn &
            *wgt &
            *(pfx1(iphel,jphel) &
            +pfx2(iphel,jphel))
            error_polar(it,iphel,jphel)=error_polar(it,iphel,jphel) &
            +xsec_polar(it,iphel,jphel)**2
          end do
        end do
      end if


    ! afb
      if (o_asym(4) == 1) then
        if (costheta_top_cm > 0.d0) then
          xsec_fb(1,it,+1)=xsec_fb(1,it,+1) &
          +fffxn &
          *wgt
          error_fb(1,it,+1)=error_fb(1,it,+1) &
          +xsec_fb(1,it,+1)**2
        else if (costheta_top_cm < 0.d0) then
          xsec_fb(1,it,-1)=xsec_fb(1,it,-1) &
          +fffxn &
          *wgt
          error_fb(1,it,-1)=error_fb(1,it,-1) &
          +xsec_fb(1,it,-1)**2
        end if
      end if

    ! afbstar
      if (o_asym(5) == 1) then
        if (costheta_top_star > 0.d0) then
          xsec_fb(2,it,+1)=xsec_fb(2,it,+1) &
          +fffxn &
          *wgt
          error_fb(2,it,+1)=error_fb(2,it,+1) &
          +xsec_fb(2,it,+1)**2
        else if (costheta_top_star < 0.d0) then
          xsec_fb(2,it,-1)=xsec_fb(2,it,-1) &
          +fffxn &
          *wgt
          error_fb(2,it,-1)=error_fb(2,it,-1) &
          +xsec_fb(2,it,-1)**2
        end if
      end if

    ! atrfb
      if (o_asym(6) == 1) then
        if (yt > 0.d0) then
          xsec_fb(3,it,+1)=xsec_fb(3,it,+1) &
          +fffxn &
          *wgt
          error_fb(3,it,+1)=error_fb(3,it,+1) &
          +xsec_fb(3,it,+1)**2
        else if (yt < 0.d0) then
          xsec_fb(3,it,-1)=xsec_fb(3,it,-1) &
          +fffxn &
          *wgt
          error_fb(3,it,-1)=error_fb(3,it,-1) &
          +xsec_fb(3,it,-1)**2
        end if
      end if

    ! attbrfb/a
      if (o_asym(7) == 1) then
        if (yt >= 0.d0) then
          xsec_fb(4,it,+1)=xsec_fb(4,it,+1) &
          +fffxn &
          *wgt
          error_fb(4,it,+1)=error_fb(4,it,+1) &
          +xsec_fb(4,it,+1)**2
        end if
        if (ytb >= 0.d0) then
          xsec_fb(4,it,-1)=xsec_fb(4,it,-1) &
          +fffxn &
          *wgt
          error_fb(4,it,-1)=error_fb(4,it,-1) &
          +xsec_fb(4,it,-1)**2
        end if
      end if

    ! arfb/a'

      if ((o_asym(8) == 1) .and. (abs(ytt) > yttmin)) then
        if (delta_absy == 0.d0) then
          continue
        else if (delta_absy > 0.d0) then
          xsec_fb(5,it,+1)=xsec_fb(5,it,+1) &
          +fffxn &
          *wgt
          error_fb(5,it,+1)=error_fb(5,it,+1) &
          +xsec_fb(5,it,+1)**2
        else if (delta_absy < 0.d0) then
          xsec_fb(5,it,-1)=xsec_fb(5,it,-1) &
          +fffxn &
          *wgt
          error_fb(5,it,-1)=error_fb(5,it,-1) &
          +xsec_fb(5,it,-1)**2
        end if
      end if

    ! a_l
      if (o_asym(9) == 1) then
        if (cosfl > 0.d0) then
          xsec_fb(6,it,+1)=xsec_fb(6,it,+1) &
          +fffxn &
          *wgt
          error_fb(6,it,+1)=error_fb(6,it,+1) &
          +xsec_fb(6,it,+1)**2
        else if (cosfl < 0.d0) then
          xsec_fb(6,it,-1)=xsec_fb(6,it,-1) &
          +fffxn &
          *wgt
          error_fb(6,it,-1)=error_fb(6,it,-1) &
          +xsec_fb(6,it,-1)**2
        end if
      end if
    
    ! binning
    ! scale by weight
      hist1=fffxn1*wgt
      hist2=fffxn2*wgt
      hist=hist1+hist2
      do ip=3,n_final
      ! generate distribution in pt
        if (o_pt(ip) == 1) then
          nbin=int((pt(ip)-ptmin(ip))/ptw(ip))+1
          if (nbin >= (ndiv_pt(ip)+1)) then
            continue
          else if (nbin < 1) then
            continue
          else
            fxpt(ip,nbin,it)=fxpt(ip,nbin,it)+hist
            ! print *, fxpt(ip,nbin,it)
          end if
        end if
      ! generate distribution in eta
        if (o_eta(ip) == 1) then
          nbin=int((eta(ip)-etamin(ip))/etaw(ip))+1
          if (nbin >= (ndiv_eta(ip)+1)) then
            continue
          else if (nbin < 1) then
            continue
          else
            fxeta(ip,nbin,it)=fxeta(ip,nbin,it)+hist
          end if
        end if
      ! generate distribution in phi
        if (o_phi(ip) == 1) then
          nbin=int((phi(ip)-phimin(ip))/phiw(ip))+1
          if (nbin >= (ndiv_phi(ip)+1)) then
            continue
          else if (nbin < 1) then
            continue
          else
            fxphi(ip,nbin,it)=fxphi(ip,nbin,it)+hist
          end if
        end if
      ! generate distribution in ycol
        if (o_ycol(ip) == 1) then
          nbin=int((ycol(ip)-ycolmin(ip))/ycolw(ip))+1
          if (nbin >= (ndiv_ycol(ip)+1)) then
            continue
          else if (nbin < 1) then
            continue
          else
            fxycol(ip,nbin,it)=fxycol(ip,nbin,it)+hist
          end if
        end if
      end do

      if (o_pt356 == 1) then
        ! generate distribution in pt356.
        nbin=int((pt356-pt356min)/pt356w)+1
        if (nbin >= (ndiv_pt356+1)) then
          continue
        else if (nbin < 1) then
          continue
        else
          fxpt356(nbin,it)=fxpt356(nbin,it)+hist
        end if
      end if

      if (o_eta356 == 1) then
      ! generate distribution in eta356.
        nbin=int((eta356-eta356min)/eta356w)+1
        if (nbin >= (ndiv_eta356+1)) then
          continue
        else if (nbin < 1) then
          continue
        else
          fxeta356(nbin,it)=fxeta356(nbin,it)+hist
        end if
      end if

      if (o_phi356 == 1) then
        ! generate distribution in phi356.
        nbin=int((phi356-phi356min)/phi356w)+1
        if (nbin >= (ndiv_phi356+1)) then
          continue
        else if (nbin < 1) then
          continue
        else
          fxphi356(nbin,it)=fxphi356(nbin,it)+hist
        end if
      end if

      if (o_pt478 == 1) then
      ! generate distribution in pt478.
        nbin=int((pt478-pt478min)/pt478w)+1
        if (nbin >= (ndiv_pt478+1)) then
          continue
        else if (nbin < 1) then
          continue
        else
          fxpt478(nbin,it)=fxpt478(nbin,it)+hist
        end if
      end if

      if (o_eta478 == 1) then
      ! generate distribution in eta478.
        nbin=int((eta478-eta478min)/eta478w)+1
        if (nbin >= (ndiv_eta478+1)) then
          continue
        else if (nbin < 1) then
          continue
        else
          fxeta478(nbin,it)=fxeta478(nbin,it)+hist
        end if
      end if

      if (o_phi478 == 1) then
      ! generate distribution in phi478.
        nbin=int((phi478-phi478min)/phi478w)+1
        if (nbin >= (ndiv_phi478+1)) then
          continue
        else if (nbin < 1) then
          continue
        else
          fxphi478(nbin,it)=fxphi478(nbin,it)+hist
        end if
      end if

      if (o_etmiss == 1) then
      ! generate distribution in etmiss.
        nbin=int((etmiss-etmissmin)/etmissw)+1
        if (nbin >= (ndiv_etmiss+1)) then
          continue
        else if (nbin < 1) then
          continue
        else
          fxetmiss(nbin,it)=fxetmiss(nbin,it)+hist
        end if
      end if

      if (o_mtt == 1) then
        ! generate distribution in mtt.
        nbin=int((mtt-mttmin)/mttw)+1
        if (nbin >= (ndiv_mtt+1)) then
          continue
        else if (nbin < 1) then
          continue
        else
          fxmtt(nbin,it)=fxmtt(nbin,it)+hist
        end if
      end if

      if (o_mtt_reco == 1) then
        ! generate distribution in mtt.
        nbin=int((mtt_reco-mtt_recomin)/mtt_recow)+1
        if (nbin >= (ndiv_mtt_reco+1)) then
          continue
        else if (nbin < 1) then
          continue
        else
          fxmtt_reco(nbin,it)=fxmtt_reco(nbin,it)+hist
        end if
      end if

      if (o_beta == 1) then
        ! generate distribution in beta.
        beta=shat/4.d0/rmt**2-1.d0
        nbin=int((beta-betamin)/betaw)+1
        if (nbin >= (ndiv_beta+1)) then
          continue
        else if (nbin < 1) then
          continue
        else
          fxbeta(nbin,it)=fxbeta(nbin,it)+hist
        end if
      end if

      if (o_cost == 1) then
      ! generate distribution in cost.
        nbin=int((cost-costmin)/costw)+1
        if (nbin >= (ndiv_cost+1)) then
          continue
        else if (nbin < 1) then
          continue
        else
          fxcost(nbin,it)=fxcost(nbin,it)+hist
        end if
      end if

      if (o_et == 1) then   
        ! generate distribution in et.
        nbin=int((et-etmin)/etw)+1
        if (nbin >= (ndiv_et+1)) then
          continue
        else if (nbin < 1) then
          continue
        else
          fxet(nbin,it)=fxet(nbin,it)+hist
        end if
      end if

      if (o_delta_y == 1) then   
        ! generate distribution in delta_absy.
        nbin=int((delta_absy-delta_ymin)/delta_yw)+1
        if (nbin >= (ndiv_delta_y+1)) then
          continue
        else if (nbin < 1) then
          continue
        else
          fxdelta_y(nbin,it)=fxdelta_y(nbin,it)+hist
        end if
      end if

      do itrans=1,ntrans
        if (o_tran(itrans) == 1) then
        ! generate distribution in trans.
          nbin=int((trans(itrans)-transmin(itrans))/transw(itrans))+1
          if (nbin >= (ndiv_trans(itrans)+1)) then
            continue
          else if (nbin < 1) then
            continue
          else
            fxtrans(itrans,nbin,it)=fxtrans(itrans,nbin,it)+hist
          end if
        end if
      end do

      if (o_fl == 1) then
        ! generate distribution in phi_l.
        nbin=int((phi_l-flmin)/flw)+1
        if (nbin >= (ndiv_fl+1)) then
          continue
        else if (nbin < 1) then
          continue
        else
          fxfl(nbin,it)=fxfl(nbin,it)+hist
        end if
      end if


      if (o_cosfl == 1) then
        ! generate distribution in cosfl.
        nbin=int((cosfl-cosflmin)/cosflw)+1
        if (nbin >= (ndiv_cosfl+1)) then
          continue
        else if (nbin < 1) then
          continue
        else
          fxcosfl(nbin,it)=fxcosfl(nbin,it)+hist
        end if
      end if


      if (o_dphi == 1) then
        ! generate distribution in dphi.
        nbin=int((dphi-dphimin)/dphiw)+1
        if (nbin >= (ndiv_dphi+1)) then
          continue
        else if (nbin < 1) then
          continue
        else
          fxdphi(nbin,it)=fxdphi(nbin,it)+hist
        end if
      end if

      if (o_cost5 == 1) then
        ! generate distribution in costheta5.
        nbin=int((costheta5-cost5min)/cost5w)+1
        if (nbin >= (ndiv_cost5+1)) then
          continue
        else if (nbin < 1) then
          continue
        else
          fxcost5(nbin,it)=fxcost5(nbin,it)+hist
        end if
      end if

      if (o_cost7 == 1) then
        ! generate distribution in costheta7.
        nbin=int((costheta7-cost7min)/cost7w)+1
        if (nbin >= (ndiv_cost7+1)) then
          continue
        else if (nbin < 1) then
          continue
        else
          fxcost7(nbin,it)=fxcost7(nbin,it)+hist
        end if
      end if

      if (o_ct7ct5 == 1) then
        nbin=int((ct7ct5-ct7ct5min)/ct7ct5w)+1
        if (nbin >= (ndiv_ct7ct5+1)) then
          continue
        else if (nbin < 1) then
          continue
        else
          fxct7ct5(nbin,it)=fxct7ct5(nbin,it)+hist
        end if
      end if

      if (o_dphi2d == 1) then
        ! generate distribution in dphi2d.
        ibin=int((dphi-dphimin)/dphiw)+1
        jbin=int((mtt-mttmin)/mttw)+1
        if ((ibin > ndiv_dphi) .or. (jbin > ndiv_mtt)) then
          continue
        else if ((ibin < 1) .or. (jbin < 1)) then
          continue
        else
          fxdphi2d(ibin,jbin,it)=fxdphi2d(ibin,jbin,it)+hist
        end if
      end if



      do itrans=1,ntrans
        if (include_transversedp(itrans) == 1) then
        ! generate distribution in transdp.
          ibin=int((dphi-dphimin)/dphiw)+1
          jbin=int((trans(itrans)-transmin(itrans))/transw(itrans))+1
          if ((ibin > ndiv_dphi) .or. (jbin >= (ndiv_trans(itrans)+1))) then
            continue
          else if ((ibin < 1) .or. (jbin < 1)) then
            continue
          else
            fxtransdp(itrans,ibin,jbin,it)= &
            fxtransdp(itrans,ibin,jbin,it)+hist
          end if
        end if
      end do

      if (o_asym(1) == 1) then
        if (o_sigp == 1) then
        ! generate distribution in sigp for all.
          sigp=ecm
          nbin=int((sigp-sigpmin)/sigpw)+1
          if (nbin >= (ndiv_sigp+1)) then
            continue
          else if (nbin < 1) then
            continue
          else
            fxsigp(1,nbin,it)=fxsigp(1,nbin,it)+ &
            (weight(it,+1,+1)+weight(it,-1,-1))   !ction happens
          end if
        end if
        if (o_sigm == 1) then
        ! generate distribution in sigm for all.
          sigm=ecm
          nbin=int((sigm-sigmmin)/sigmw)+1
          if (nbin >= (ndiv_sigm+1)) then
            continue
          else if (nbin < 1) then
            continue
          else
            fxsigm(1,nbin,it)=fxsigm(1,nbin,it)+ &
            (weight(it,+1,-1)+weight(it,-1,+1))
          end if
        end if
      end if

      if (o_asym(2) == 1) then
        if (o_sigp == 1) then
        ! generate distribution in sigp for al.
          sigp=ecm
          nbin=int((sigp-sigpmin)/sigpw)+1
          if (nbin >= (ndiv_sigp+1)) then
            continue
          else if (nbin < 1) then
            continue
          else
            fxsigp(2,nbin,it)=fxsigp(2,nbin,it)+ &
            (weight(it,-1,-1)+weight(it,-1,+1))
          end if
        end if
        if (o_sigm == 1) then
        ! generate distribution in sigm for al.
          sigm=ecm
          nbin=int((sigm-sigmmin)/sigmw)+1
          if (nbin >= (ndiv_sigm+1)) then
            continue
          else if (nbin < 1) then
            continue
          else
            fxsigm(2,nbin,it)=fxsigm(2,nbin,it)+ &
            (weight(it,+1,-1)+weight(it,+1,+1))
          end if
        end if
      end if

      if (o_asym(3) == 1) then
        if (o_sigp == 1) then
        ! generate distribution in sigp for apv.
          sigp=ecm
          nbin=int((sigp-sigpmin)/sigpw)+1
          if (nbin >= (ndiv_sigp+1)) then
            continue
          else if (nbin < 1) then
            continue
          else
            fxsigp(3,nbin,it)=fxsigp(3,nbin,it)+ &
            (weight(it,-1,-1))
          end if
        end if
        if (o_sigm == 1) then
        ! generate distribution in sigm for apv.
          sigm=ecm
          nbin=int((sigm-sigmmin)/sigmw)+1
          if (nbin >= (ndiv_sigm+1)) then
            continue
          else if (nbin < 1) then
            continue
          else
            fxsigm(3,nbin,it)=fxsigm(3,nbin,it)+ &
            (weight(it,+1,+1))
          end if
        end if
      end if

      if (o_asym(4) == 1) then
        if ((o_sigp == 1) .and. (costheta_top_cm > 0.d0)) then
        ! generate distribution in sigp for afbcm.
          sigp=ecm
          nbin=int((sigp-sigpmin)/sigpw)+1
          if (nbin >= (ndiv_sigp+1)) then
            continue
          else if (nbin < 1) then
            continue
          else
            fxsigp(4,nbin,it)=fxsigp(4,nbin,it)+hist
          end if
        end if
        if ((o_sigm == 1) .and. (costheta_top_cm < 0.d0)) then
        ! generate distribution in sigm for afbcm.
          sigm=ecm
          nbin=int((sigm-sigmmin)/sigmw)+1
          if (nbin >= (ndiv_sigm+1)) then
            continue
          else if (nbin < 1) then
            continue
          else
            fxsigm(4,nbin,it)=fxsigm(4,nbin,it)+hist
          end if
        end if
      end if

      if (o_asym(5) == 1) then
        if ((o_sigp == 1) .and. (costheta_top_star > 0.d0)) then
        ! generate distribution in sigp for afbstar.
          sigp=ecm
          nbin=int((sigp-sigpmin)/sigpw)+1
          if (nbin >= (ndiv_sigp+1)) then
            continue
          else if (nbin < 1) then
            continue
          else
            fxsigp(5,nbin,it)=fxsigp(5,nbin,it)+hist
          end if
        end if
        if ((o_sigm == 1) .and. (costheta_top_star < 0.d0)) then
        ! generate distribution in sigm for afbstar.
          sigm=ecm
          nbin=int((sigm-sigmmin)/sigmw)+1
          if (nbin >= (ndiv_sigm+1)) then
            continue
          else if (nbin < 1) then
            continue
          else
            fxsigm(5,nbin,it)=fxsigm(5,nbin,it)+hist
          end if
        end if
      end if

      if (o_asym(6) == 1) then
        if ((o_sigp == 1) .and. (yt > 0.d0)) then
        ! generate distribution in sigp for atfb.
          sigp=ecm
          nbin=int((sigp-sigpmin)/sigpw)+1
          if (nbin >= (ndiv_sigp+1)) then
            continue
          else if (nbin < 1) then
            continue
          else
            fxsigp(6,nbin,it)=fxsigp(6,nbin,it)+hist
          end if
        end if
        if ((o_sigm == 1) .and. (yt < 0.d0)) then
        ! generate distribution in sigm for atfb.
          sigm=ecm
          nbin=int((sigm-sigmmin)/sigmw)+1
          if (nbin >= (ndiv_sigm+1)) then
            continue
          else if (nbin < 1) then
            continue
          else
            fxsigm(6,nbin,it)=fxsigm(6,nbin,it)+hist
          end if
        end if
      end if

      if (o_asym(7) == 1) then
        if ((o_sigp == 1) .and. (yt >= 0.d0)) then
        ! generate distribution in sigp for a.
          sigp=ecm
          nbin=int((sigp-sigpmin)/sigpw)+1
          if (nbin >= (ndiv_sigp+1)) then
            continue
          else if (nbin < 1) then
            continue
          else
            fxsigp(7,nbin,it)=fxsigp(7,nbin,it)+hist
          end if
        end if
        if ((o_sigm == 1) .and. (ytb >= 0.d0)) then
        ! generate distribution in sigm for a.
          sigm=ecm
          nbin=int((sigm-sigmmin)/sigmw)+1
          if (nbin >= (ndiv_sigm+1)) then
            continue
          else if (nbin < 1) then
            continue
          else
            fxsigm(7,nbin,it)=fxsigm(7,nbin,it)+hist
          end if
        end if
      end if

      if (o_asym(8) == 1) then
        if ((o_sigp == 1) .and. (delta_absy > 0.d0)) then
        ! generate distribution in sigp for arfb.
          sigp=ecm
          nbin=int((sigp-sigpmin)/sigpw)+1
          if (nbin >= (ndiv_sigp+1)) then
            continue
          else if (nbin < 1) then
            continue
          else
            if (abs(ytt) > yttmin)fxsigp(8,nbin,it)=fxsigp(8,nbin,it)+hist
          end if
        end if
        if ((o_sigm == 1) .and. (delta_absy < 0.d0)) then
        ! generate distribution in sigm for arfb.
          sigm=ecm
          nbin=int((sigm-sigmmin)/sigmw)+1
          if (nbin >= (ndiv_sigm+1)) then
            continue
          else if (nbin < 1) then
            continue
          else
            if (abs(ytt) > yttmin)fxsigm(8,nbin,it)=fxsigm(8,nbin,it)+hist
          end if
        end if
      end if

      if (o_asym(9) == 1) then
        if ((o_sigp == 1) .and. (cosfl > 0.d0)) then
          ! generate distribution in sigp for a_l.
          sigp=ecm
          nbin=int((sigp-sigpmin)/sigpw)+1
          if (nbin >= (ndiv_sigp+1)) then
            continue
          else if (nbin < 1) then
            continue
          else
            fxsigp(9,nbin,it)=fxsigp(9,nbin,it)+hist
          end if
        end if
        if ((o_sigm == 1) .and. (cosfl < 0.d0)) then
          ! generate distribution in sigm for a_l.
          sigm=ecm
          nbin=int((sigm-sigmmin)/sigmw)+1
          if (nbin >= (ndiv_sigm+1)) then
            continue
          else if (nbin < 1) then
            continue
          else
            fxsigm(9,nbin,it)=fxsigm(9,nbin,it)+hist
          end if
        end if
      end if
    
      ! stats
      npoints = npoints+1
      
      ffxn = ffxn + fffxn
    end do ! end loop costheta_t<->-cost
    differential_cross_section = differential_cross_section + ffxn  
  end do ! end loop x1 <-> x2
  return
end function differential_cross_section
