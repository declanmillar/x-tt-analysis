function dxsec(x,wgt)

  ! computes the fully differential cross section for
  ! * pp -> tt,
  ! * pp -> tt -> bW^+bbarW^- -> bbbare^+nue^-nubarc
  ! Matrix element and phase space integration function.
  ! Called each time a phase space point is generated by VEGAS.
  ! Calculates matrix element using HELAS subroutines, scales by phase
  ! space volume factor and populates distributions for set of defined
  ! observables accordingly.
  ! This is then passed to VEGAS in the main program.
  ! Authors: Declan Millar, Stefano Moretti

  use Configuration
  use Kinematics
  use Distributions

  implicit real (a-h,p-z)
  implicit integer (l-o)

  ! Argument arrays
  ! Integration variables
  dimension x(100)

  ! Global variables
  common/limfac/fac
  common/stat/npoints
  common/fermions/ fmass,     fwidth
  dimension fmass(12), fwidth(12)
  common/vmass1/rm_W,Gamma_W,rm_Z,Gamma_Z
  common/vmass2/rm_A,Gamma_a,rm_h,Gamma_h
  ! Narrow Width Approximation (NWA)
  common/Gammas/Gamma_t
  ! Common for decay ME
  common/polarqq/polqq(-1:1,-1:1)
  common/polargg/polgg(-1:1,-1:1)
  common/qcd/rlambdaQCD4,nloops
  ! Polarised/Spatial cross sections
  common/polarised/polcross(20,-1:1,-1:1),polerror(20,-1:1,-1:1)
  common/spatial/spatcross(nspat,20,-1:1),spaterror(nspat,20,-1:1)

  ! phase space vectors.
  real :: q356(4),q478(4),p356(4),p478(4)
  real :: q56(4),q78(4),p56(4),p78(4)
  real :: q5(4),q7(4)
  real :: q(4,8),qcol(4,8)
  ! momentum 4-vectors
  real :: p1(0:3),p2(0:3),p3(0:3),p4(0:3),p5(0:3),p6(0:3),p7(0:3),p8(0:3)
  ! kinematic vectors
  real :: pT2(8),pT(8),rps(8),rpl(8),arg(8),eta(8),phi(8),ycol(8)
  real :: pTvis(2),pTmiss(2)
  ! lepton azimuthal angle coordinate system
  real :: xp(3),yp(3),zp(3)

  ! polarised square matrix elements
  ! situation one: q-qbar collision
  real :: qcdpolqq1(-1:1,-1:1)
  real :: qcdpolbb1(-1:1,-1:1),qcdpolgg1(-1:1,-1:1)
  real :: ewzpoluu1(-1:1,-1:1),ewzpoldd1(-1:1,-1:1)
  real :: ewzpolbb1(-1:1,-1:1)
  real :: pfx1(-1:1,-1:1)
  ! situation two: qbar-q collision
  real :: qcdpolqq2(-1:1,-1:1)
  real :: qcdpolbb2(-1:1,-1:1),qcdpolgg2(-1:1,-1:1)
  real :: ewzpoluu2(-1:1,-1:1),ewzpoldd2(-1:1,-1:1)
  real :: ewzpolbb2(-1:1,-1:1)
  real :: pfx2(-1:1,-1:1)

  ! weight per polarisation
  real :: weight(20,-1:1,-1:1)

  ! PDFs
  real :: fx1(13),fx2(13)
  real :: x1x2(2,2)
  real :: trans(ntrans)

  ! Local constants
  real :: pi
  parameter (pi=3.14159265358979323846d0)
  ! Internal random number seed
  integer :: jseed
  data jseed/987654321/

  ! EXECUTE

  ! Maximum centre of mass energy
  Ecm_max=collider_energy
  ! Centre of mass energy
  Ecm=x(2+12*o_decay)*(Ecm_max-rm3-rm4-rm5-rm6-rm7-rm8) &
  +rm3+rm4+rm5+rm6+rm7+rm8
  shat=Ecm*Ecm
  tau=shat/s
  ! x1 and x2 of the partons
  xx1=x(3+12*o_decay)*(1.d0-tau)+tau
  xx2=tau/xx1
  x1x2(1,1)=xx1
  x1x2(1,2)=xx2
  x1x2(2,1)=xx2
  x1x2(2,2)=xx1
  ! Loop over x1 and x2
  dxsec=0.d0
  do ix=1,ixmax
    ffxn=0.d0
    x1=x1x2(ix,1)
    x2=x1x2(ix,2)
    ! Loop over costheta_cm
    do jx=1,jxmax
      fffxn=0.d0
      ! Structure functions
      ! Scale for the PDFs
      rmt=fmass(11)
      gamt=fwidth(11)
      QQ=2.d0*rmt
      ! construct hadronic structure functions.
      if(o_structure <= 4)then
        q2=QQ*QQ
        if((x1 <= 1.d-6) .OR. (x1 >= 1.d0))then
          fffxn=0.d0
          return
        end if
        if((x2 <= 1.d-6) .OR. (x2 >= 1.d0))then
          fffxn=0.d0
          return
        end if
        if((QQ <= 1.3d0) .OR. (QQ >= 1.d4))then
          fffxn=0.d0
          return
        end if

        ! note that for cteq PDFs we multiply by x1 below and then divide by
        ! it later. This is for compatibility with MRS, which return xf(x).)
        ! recent changes may screw up compatabilty with MRS. sea->bar in names
        ! below reflecting change in cteq61Pdf iparton variable.

        ! 
        u1=x1*ctq6pdf(1,x1,QQ)
        d1=x1*ctq6pdf(2,x1,QQ)
        ubar1=x1*ctq6pdf(-1,x1,QQ)
        dbar1=x1*ctq6pdf(-2,x1,QQ)
        str1=x1*ctq6pdf(3,x1,QQ)
        chm1=x1*ctq6pdf(4,x1,QQ)
        btm1=x1*ctq6pdf(5,x1,QQ)
        g1=x1*ctq6pdf(0,x1,QQ)
        u2=x2*ctq6pdf(1,x2,QQ)
        d2=x2*ctq6pdf(2,x2,QQ)
        ubar2=x2*ctq6pdf(-1,x2,QQ)
        dbar2=x2*ctq6pdf(-2,x2,QQ)
        str2=x2*ctq6pdf(3,x2,QQ)
        chm2=x2*ctq6pdf(4,x2,QQ)
        btm2=x2*ctq6pdf(5,x2,QQ)
        g2=x2*ctq6pdf(0,x2,QQ)

      else if(o_structure == 5)then
        imode=1
        if((x1 <= 1.d-5) .OR. (x1 >= 1.d0))then
          fffxn=0.d0
          return
        end if
        if((x2 <= 1.d-5) .OR. (x2 >= 1.d0))then
          fffxn=0.d0
          return
        end if
        if((QQ**2 <= 1.25d0) .OR. (QQ**2 >= 1.d7))then
          fffxn=0.d0
          return
        end if
        call mrs99(x1,QQ,imode,u1,d1,ubar1,dbar1,str1,chm1,btm1,g1)
        call mrs99(x2,QQ,imode,u2,d2,ubar2,dbar2,str2,chm2,btm2,g2)
      else if(o_structure == 6)then
        imode=2
        if((x1 <= 1.d-5) .OR. (x1 >= 1.d0))then
          fffxn=0.d0
          return
        end if
        if((x2 <= 1.d-5) .OR. (x2 >= 1.d0))then
          fffxn=0.d0
          return
        end if
        if((QQ**2 <= 1.25d0) .OR. (QQ**2 >= 1.d7))then
          fffxn=0.d0
          return
        end if
        call mrs99(x1,QQ,imode,u1,d1,ubar1,dbar1,str1,chm1,btm1,g1)
        call mrs99(x2,QQ,imode,u2,d2,ubar2,dbar2,str2,chm2,btm2,g2)
      else if(o_structure == 7)then
        imode=3
        if((x1 <= 1.d-5) .OR. (x1 >= 1.d0))then
          fffxn=0.d0
          return
        end if
        if((x2 <= 1.d-5) .OR. (x2 >= 1.d0))then
          fffxn=0.d0
          return
        end if
        if((QQ**2 <= 1.25d0) .OR. (QQ**2 >= 1.d7))then
          fffxn=0.d0
          return
        end if
        call mrs99(x1,QQ,imode,u1,d1,ubar1,dbar1,str1,chm1,btm1,g1)
        call mrs99(x2,QQ,imode,u2,d2,ubar2,dbar2,str2,chm2,btm2,g2)
      else if(o_structure == 8)then
        imode=4
        if((x1 <= 1.d-5) .OR. (x1 >= 1.d0))then
          fffxn=0.d0
          return
        end if
        if((x2 <= 1.d-5) .OR. (x2 >= 1.d0))then
          fffxn=0.d0
          return
        end if
        if((QQ**2 <= 1.25d0) .OR. (QQ**2 >= 1.d7))then
          fffxn=0.d0
          return
        end if
        call mrs99(x1,QQ,imode,u1,d1,ubar1,dbar1,str1,chm1,btm1,g1)
        call mrs99(x2,QQ,imode,u2,d2,ubar2,dbar2,str2,chm2,btm2,g2)
      else if(o_structure == 9)then
        imode=5
        if((x1 <= 1.d-5) .OR. (x1 >= 1.d0))then
          fffxn=0.d0
          return
        end if
        if((x2 <= 1.d-5) .OR. (x2 >= 1.d0))then
          fffxn=0.d0
          return
        end if
        if((QQ**2 <= 1.25d0) .OR. (QQ**2 >= 1.d7))then
          fffxn=0.d0
          return
        end if
        call mrs99(x1,QQ,imode,u1,d1,ubar1,dbar1,str1,chm1,btm1,g1)
        call mrs99(x2,QQ,imode,u2,d2,ubar2,dbar2,str2,chm2,btm2,g2)

      ! Note that MRS return valence and sea contributions automatically.)
      ! Note that cteq do too now!)
      ! Parton distribution functions (PDFs)
      end if
     
      ! initialise PDFs
      fx1(1)=d1
      fx1(2)=u1
      fx1(3)=str1
      fx1(4)=chm1
      fx1(5)=btm1
      fx1(6)=0.d0
      fx1(7)=dbar1
      fx1(8)=ubar1
      fx1(9)=fx1(3)
      fx1(10)=fx1(4)
      fx1(11)=fx1(5)
      fx1(12)=fx1(6)
      fx1(13)=g1
      do i=1,13
        fx1(i)=fx1(i)/x1
      end do
      fx2(1)=d2*(1-initial_state)+dbar2*initial_state
      fx2(2)=u2*(1-initial_state)+ubar2*initial_state
      fx2(3)=str2
      fx2(4)=chm2
      fx2(5)=btm2
      fx2(6)=0.d0
      fx2(7)=d2*initial_state+dbar2*(1-initial_state)
      fx2(8)=u2*initial_state+ubar2*(1-initial_state)
      fx2(9)=fx2(3)
      fx2(10)=fx2(4)
      fx2(11)=fx2(5)
      fx2(12)=fx2(6)
      fx2(13)=g2
      do i=1,13
        fx2(i)=fx2(i)/x2
      end do
    
      ! initial particle momenta (all approximately massless)
      pcm=Ecm/2.d0
      q(4,1)=pcm
      q(3,1)=pcm
      q(2,1)=0.d0
      q(1,1)=0.d0
      q(4,2)=pcm
      q(3,2)=-pcm
      q(2,2)=0.d0
      q(1,2)=0.d0

      if(ifinal_state == 0)then
        ! calculate 2to2 kinematics in parton CM frame
        phit=2.d0*pi*ran(jseed)
        if(jx == 1)then
          ct=x(1)
        else if(jx == 2)then
          ct=-x(1)
        else
          write(*,*)'Invalid jx.'
        end if
        st=sqrt(1.d0-ct*ct)
        qcm2=((Ecm*Ecm-rm3*rm3-rm4*rm4)**2-(2.d0*rm3*rm4)**2)/ &
        (4.d0*Ecm*Ecm)
        if (qcm2 < 0.d0) then
          fffxn=0.d0
          return
        else
          qcm=sqrt(qcm2)
        endif
        q(4,3)=sqrt(qcm2+rm3*rm3)
        q(3,3)=qcm*ct
        q(2,3)=qcm*st*cos(phit)
        q(1,3)=qcm*st*sin(phit)
        q(4,4)=sqrt(qcm2+rm4*rm4)
        q(3,4)=-qcm*ct
        q(2,4)=-qcm*st*cos(phit)
        q(1,4)=-qcm*st*sin(phit)
        do i=1,4
          q(i,5)=0.d0
          q(i,6)=0.d0
          q(i,7)=0.d0
          q(i,8)=0.d0
        end do
      else if(ifinal_state > 0)then
        ! calculate 2to6 kinematics in parton CM frame
        phit=2.d0*pi*ran(jseed)
        rm356min=rm3+rm5+rm6
        rm356max=Ecm-rm4-rm7-rm8
        XX356min=datan(((rm356min)**2-rmt**2)/rmt/gamt)
        XX356max=datan(((rm356max)**2-rmt**2)/rmt/gamt)
        xx=x(13)*(XX356max-XX356min)+XX356min
        rl356=dtan(xx)*rmt*gamt
        rm356_2=(rmt**2+rl356)
        if(rm356_2 < 0.d0)then
          fffxn=0.d0
          return
        else
          rm356=sqrt(rm356_2)
        endif
        rm478min=rm4+rm7+rm8
        rm478max=Ecm-rm356
        XX478min=datan(((rm478min)**2-rmt**2)/rmt/gamt)
        XX478max=datan(((rm478max)**2-rmt**2)/rmt/gamt)
        xx=x(12)*(XX478max-XX478min)+XX478min
        rl478=dtan(xx)*rmt*gamt
        rm478_2=(rmt**2+rl478)
        if(rm478_2 < 0.d0)then
          fffxn=0.d0
          return
        else
          rm478=sqrt(rm478_2)
        endif
        rm56min=rm5+rm6
        rm56max=rm356-rm3
        XX56min=datan(((rm56min)**2-rm_W**2)/rm_W/gamma_W)
        XX56max=datan(((rm56max)**2-rm_W**2)/rm_W/gamma_W)
        xx=x(11)*(XX56max-XX56min)+XX56min
        rl56=dtan(xx)*rm_W*gamma_W
        rm56_2=(rm_W**2+rl56)
        if(rm56_2 < 0.d0)then
          fffxn=0.d0
          return
        else
          rm56=sqrt(rm56_2)
        endif
        rm78min=rm7+rm8
        rm78max=rm478-rm4
        XX78min=datan(((rm78min)**2-rm_W**2)/rm_W/gamma_W)
        XX78max=datan(((rm78max)**2-rm_W**2)/rm_W/gamma_W)
        xx=x(10)*(XX78max-XX78min)+XX78min
        rl78=dtan(xx)*rm_W*gamma_W
        rm78_2=(rm_W**2+rl78)
        if(rm78_2 < 0.d0)then
          fffxn=0.d0
          return
        else
          rm78=sqrt(rm78_2)
        endif
        if(jx == 1)then
          ct=x(9)
        else if(jx == 2)then
          ct=-x(9)
        else
          write(*,*)'Invalid jx.'
        end if
        st=sqrt(abs(1.d0-ct*ct))
        ct56=x(8)
        st56=sqrt(1.d0-ct56*ct56)
        ct78=x(7)
        st78=sqrt(1.d0-ct78*ct78)
        ct5=x(6)
        st5=sqrt(1.d0-ct5*ct5)
        ct7=x(5)
        st7=sqrt(1.d0-ct7*ct7)
        cf56=cos(x(4))
        sf56=sin(x(4))
        cf78=cos(x(3))
        sf78=sin(x(3))
        cf5=cos(x(2))
        sf5=sin(x(2))
        cf7=cos(x(1))
        sf7=sin(x(1))
        rq2=((Ecm*Ecm-rm356*rm356-rm478*rm478)**2 &
        -(2.d0*rm356*rm478)**2)/ &
        (4.d0*Ecm*Ecm)
        if(rq2 < 0.d0)then
          fffxn=0.d0
          return
        else
          rq=sqrt(rq2)
        endif
        p356(3)=rq*ct
        p356(2)=rq*st*cos(phit)
        p356(1)=rq*st*sin(phit)
        p356(4)=sqrt(rq2+rm356*rm356)
        rq562=((rm356*rm356-rm3*rm3-rm56*rm56)**2-(2.d0*rm3*rm56)**2)/ &
        (4.d0*rm356*rm356)
        if(rq562 < 0.d0)then
          fffxn=0.d0
          return
        else
          rq56=sqrt(rq562)
        endif
        q56(3)=rq56*st56*cf56
        q56(2)=rq56*st56*sf56
        q56(1)=rq56*ct56
        q56(4)=sqrt(rq562+rm56*rm56)
        pq56=0.d0
        do i=1,3
          pq56=pq56+p356(i)*q56(i)
        end do
        p56(4)=(p356(4)*q56(4)+pq56)/rm356
        q(4,3)=p356(4)-p56(4)
        do i=1,3
          p56(i)=q56(i)+p356(i)*(p56(4)+q56(4))/(p356(4)+rm356)
          q(i,3)=p356(i)-p56(i)
        end do
        do i=1,3
          p478(i)=-p356(i)
        end do
        p478(4)=sqrt(rq2+rm478*rm478)
        rq782=((rm478*rm478-rm4*rm4-rm78*rm78)**2-(2.d0*rm4*rm78)**2)/ &
        (4.d0*rm478*rm478)
        if(rq782 < 0.d0)then
          fffxn=0.d0
          return
        else
          rq78=sqrt(rq782)
        endif
        q78(3)=rq78*st78*cf78
        q78(2)=rq78*st78*sf78
        q78(1)=rq78*ct78
        q78(4)=sqrt(rq782+rm78*rm78)
        pq78=0.d0
        do i=1,3
          pq78=pq78+p478(i)*q78(i)
        end do
        p78(4)=(p478(4)*q78(4)+pq78)/rm478
        q(4,4)=p478(4)-p78(4)
        do i=1,3
          p78(i)=q78(i)+p478(i)*(p78(4)+q78(4))/(p478(4)+rm478)
          q(i,4)=p478(i)-p78(i)
        end do
        rq52=((rm56*rm56-rm5*rm5-rm6*rm6)**2-(2.d0*rm5*rm6)**2)/ &
        (4.d0*rm56*rm56)
        if(rq52 < 0.d0)then
          fffxn=0.d0
          return
        else
          rq5=sqrt(rq52)
        endif
        q5(3)=rq5*st5*cf5
        q5(2)=rq5*st5*sf5
        q5(1)=rq5*ct5
        q5(4)=sqrt(rq52+rm5*rm5)
        pq5=0.d0
        do i=1,3
          pq5=pq5+p56(i)*q5(i)
        end do
        q(4,5)=(p56(4)*q5(4)+pq5)/rm56
        q(4,6)=p56(4)-q(4,5)
        do i=1,3
          q(i,5)=q5(i)+p56(i)*(q(4,5)+q5(4))/(p56(4)+rm56)
          q(i,6)=p56(i)-q(i,5)
        end do
        rq72=((rm78*rm78-rm7*rm7-rm8*rm8)**2-(2.d0*rm7*rm8)**2)/ &
        (4.d0*rm78*rm78)
        if(rq72 < 0.d0)then
          fffxn=0.d0
          return
        else
          rq7=sqrt(rq72)
        endif
        q7(3)=rq7*st7*cf7
        q7(2)=rq7*st7*sf7
        q7(1)=rq7*ct7
        q7(4)=sqrt(rq72+rm7*rm7)
        pq7=0.d0
        do i=1,3
          pq7=pq7+p78(i)*q7(i)
        end do
        q(4,7)=(p78(4)*q7(4)+pq7)/rm78
        q(4,8)=p78(4)-q(4,7)
        do i=1,3
          q(i,7)=q7(i)+p78(i)*(q(4,7)+q7(4))/(p78(4)+rm78)
          q(i,8)=p78(i)-q(i,7)
        end do
      end if

      ! boost initial and final state momenta to the collider frame
      vcol=(x1-x2)/(x1+x2)
      gcol=(x1+x2)/2.d0/sqrt(x1*x2)
      do i=1,nfinal
        qcol(4,i)=gcol*(q(4,i)+vcol*q(3,i))
        qcol(3,i)=gcol*(q(3,i)+vcol*q(4,i))
        qcol(2,i)=q(2,i)
        qcol(1,i)=q(1,i)
      end do
    
      ! Additional kinematics
      ! These aren't required for the integration, but are used for
      ! distributions and cuts.

      ! Calculate transverse momenta (pT)
      do ip=1,nfinal
        pT2(ip)=qcol(1,ip)**2+qcol(2,ip)**2
        pT(ip)=sqrt(pT2(ip))
      end do

      ! Calculate rapidity (collider frame)
      do ip=3,nfinal
        ycol(ip)=0.5d0*log((qcol(4,ip)+qcol(3,ip)) &
        /(qcol(4,ip)-qcol(3,ip)))
      end do

      ! Calculate pseudorapidity (eta) CoM frame
      do ip=1,nfinal
        rps(ip)=(q(3,ip))/sqrt(q(1,ip)**2+q(2,ip)**2+q(3,ip)**2)
        if(rps(ip) < -1.d0)rps=-1.d0
        if(rps(ip) > +1.d0)rps=+1.d0
        rpl(ip)=dacos(rps(ip))
        arg(ip)=tan(rpl(ip)/2d0)
        if(arg(ip) <= 0.d0)arg(ip)=1.d-9
        eta(ip)=-log(arg(ip))
      end do

      ! Calculate azimuthal angle (phi) in lab frame
      do ip=1,nfinal
        phi(ip)=atan2(qcol(2,ip),qcol(1,ip))
      end do

      ! calculate delta phi
      if(ifinal_state == 1)then
        dphi=abs(phi(5)-phi(7))
      end if

      ! calculate visible and missing transverse momentum
      if(ifinal_state == 1)then
        ETvis2=0d0
        ETmiss2=0d0
        do i=1,2
          pTvis(i)=qcol(i,3)+qcol(i,4)+qcol(i,5)+qcol(i,7)
          pTmiss(i)=-pTvis(i)
          ETvis2=ETvis2+pTvis(i)**2
          ETmiss2=ETmiss2+pTmiss(i)**2
        end do
        ETvis=sqrt(ETvis2)
        ETmiss=sqrt(ETmiss2)
      end if

      ! calculate truth level top/antitop pT, eta and phi
      if(ifinal_state > 0)then
        pT356=sqrt((qcol(1,3)+qcol(1,5)+qcol(1,6))**2 &
                  +(qcol(2,3)+qcol(2,5)+qcol(2,6))**2)

        pT478=sqrt((qcol(1,4)+qcol(1,7)+qcol(1,8))**2 &
                  +(qcol(2,4)+qcol(2,7)+qcol(2,8))**2)

        rps356=(q(3,3)+q(3,5)+q(3,6)) &
        /sqrt((q(1,3)+q(1,5)+q(1,6))**2 &
        +(q(2,3)+q(2,5)+q(2,6))**2 &
        +(q(3,3)+q(3,5)+q(3,6))**2)
        if(rps356 < -1.d0)rps=-1.d0
        if(rps356 > +1.d0)rps=+1.d0
        rpl356=dacos(rps356)
        arg356=tan(rpl356/2d0)
        if(arg356 <= 0.d0)arg356=1.d-9
        eta356=-log(arg356)

        rps478=(q(3,4)+q(3,7)+q(3,8)) &
        /sqrt((q(1,4)+q(1,7)+q(1,8))**2 &
        +(q(2,4)+q(2,7)+q(2,8))**2 &
        +(q(3,4)+q(3,7)+q(3,8))**2)
        if(rps478 < -1.d0)rps=-1.d0
        if(rps478 > +1.d0)rps=+1.d0
        rpl478=dacos(rps478)
        arg478=tan(rpl478/2d0)
        if(arg478 <= 0.d0)arg478=1.d-9
        eta478=-log(arg478)

        phi356=atan2(qcol(2,3)+qcol(2,5)+qcol(2,6) &
        ,qcol(1,3)+qcol(1,5)+qcol(1,6))
        phi478=atan2(qcol(2,4)+qcol(2,7)+qcol(2,8) &
        ,qcol(1,4)+qcol(1,7)+qcol(1,8))
      end if
    ! Calculate cos(theta_t)
      if(ifinal_state == 0)then
        cost= &
        (qcol(1,3)*qcol(1,1) &
        +qcol(2,3)*qcol(2,1) &
        +qcol(3,3)*qcol(3,1)) &
        /sqrt(qcol(1,3)*qcol(1,3) &
        +qcol(2,3)*qcol(2,3) &
        +qcol(3,3)*qcol(3,3)) &
        /sqrt(qcol(1,1)*qcol(1,1) &
        +qcol(2,1)*qcol(2,1) &
        +qcol(3,1)*qcol(3,1))
      else if(ifinal_state > 0)then
        cost= &
        ((qcol(1,3)+qcol(1,5)+qcol(1,6))*qcol(1,1) &
        +(qcol(2,3)+qcol(2,5)+qcol(2,6))*qcol(2,1) &
        +(qcol(3,3)+qcol(3,5)+qcol(3,6))*qcol(3,1)) &
        /sqrt((qcol(1,3)+qcol(1,5)+qcol(1,6)) &
        *(qcol(1,3)+qcol(1,5)+qcol(1,6)) &
        +(qcol(2,3)+qcol(2,5)+qcol(2,6)) &
        *(qcol(2,3)+qcol(2,5)+qcol(2,6)) &
        +(qcol(3,3)+qcol(3,5)+qcol(3,6)) &
        *(qcol(3,3)+qcol(3,5)+qcol(3,6))) &
        /sqrt(qcol(1,1)*qcol(1,1) &
        +qcol(2,1)*qcol(2,1) &
        +qcol(3,1)*qcol(3,1))
      end if
    ! calculate cos(theta^*_t)
      if(ifinal_state == 0)then
        costcm=(q(1,3)*q(1,1) &
        +q(2,3)*q(2,1) &
        +q(3,3)*q(3,1)) &
        /sqrt(q(1,3)*q(1,3) &
        +q(2,3)*q(2,3) &
        +q(3,3)*q(3,3)) &
        /sqrt(q(1,1)*q(1,1) &
        +q(2,1)*q(2,1) &
        +q(3,1)*q(3,1))
      else if(ifinal_state > 0)then
        costcm= &
        ((q(1,3)+q(1,5)+q(1,6))*q(1,1) &
        +(q(2,3)+q(2,5)+q(2,6))*q(2,1) &
        +(q(3,3)+q(3,5)+q(3,6))*q(3,1)) &
        /sqrt((q(1,3)+q(1,5)+q(1,6)) &
        *(q(1,3)+q(1,5)+q(1,6)) &
        +(q(2,3)+q(2,5)+q(2,6)) &
        *(q(2,3)+q(2,5)+q(2,6)) &
        +(q(3,3)+q(3,5)+q(3,6)) &
        *(q(3,3)+q(3,5)+q(3,6))) &
        /sqrt(q(1,1)*q(1,1) &
        +q(2,1)*q(2,1) &
        +q(3,1)*q(3,1))
      end if
    ! calculate the energy of the top
      if(ifinal_state == 0)then
        Et=qcol(4,3)
      else if(ifinal_state > 0)then
        Et=qcol(4,3)+qcol(4,5)+qcol(4,6)
      end if

    ! calculate boost of the tt system
      ytt = 0.5d0*log(x1/x2)

    ! calculate rMtt
      if(ifinal_state == 0)then
        rMtt2=(qcol(4,3)+qcol(4,4))**2
        do i=1,3
          rMtt2=rMtt2-(qcol(i,3)+qcol(i,4))**2
        end do
      else if(ifinal_state > 0)then
        rMtt2=(qcol(4,3)+qcol(4,4) &
        +qcol(4,5)+qcol(4,6) &
        +qcol(4,7)+qcol(4,8))**2
        do i=1,3
          rMtt2=rMtt2-(qcol(i,3)+qcol(i,4) &
          +qcol(i,5)+qcol(i,6) &
          +qcol(i,7)+qcol(i,8))**2
        end do
      end if
      rMtt=sqrt(abs(rMtt2))
    ! calculate invariant mass of visible decay products
      if(o_tran(1) == 1)then
        rMvis2=(qcol(4,3)+qcol(4,4) &
        +qcol(4,5)+qcol(4,7))**2
        do i=1,3
          rMvis2=rMvis2-(qcol(i,3)+qcol(i,4) &
          +qcol(i,5)+qcol(i,7))**2
        end do
        trans(1)=sqrt(abs(rMvis2))
      end if
    ! calculate transverse energy energies of visible particles
      if(ifinal_state > 0)then
        ET3=sqrt(rm3**2+pT2(3))
        ET4=sqrt(rm4**2+pT2(4))
        ET5=sqrt(rm5**2+pT2(5))
        ET7=sqrt(rm6**2+pT2(7))
      end if
    ! calculate HT
      if(o_tran(2) == 1)then
        trans(2)=ET3+ET4+ET5+ET7+ETmiss
      end if

    ! calculate *full* transverse mass 1
      if(o_tran(3) == 1)then
        rM_T12=(ET3+ET4+ET5+ET7+ETmiss)**2 &
        +(pT(3)+pT(4)+pT(5)+pT(7)+ETmiss)**2
        trans(3)=sqrt(abs(rM_T12))
      end if
    ! calculate *full* transverse mass 2
      if(o_tran(4) == 1)then
        rM_T22=(ET3+ET4+ET5+ET7+ETmiss)**2
        do i=1,2
          rM_T22=rM_T22-(pTvis(i)+pTmiss(i))**2
        end do
        trans(4)=sqrt(abs(rM_T22))
      end if
    ! calculate *full* transverse mass 3
      if(o_tran(5) == 1)then
        rM_T32=(ETvis+ETmiss)**2
        do i=1,2
          rM_T32=rM_T32-(pTvis(i)+pTmiss(i))**2
        end do
        trans(5)=sqrt(abs(rM_T32))
      end if
    ! calculate lepton transverse mass
      if(o_tran(6) == 1)then
        ET5=sqrt(rm5**2+pT2(5))
        ET7=sqrt(rm7**2+pT2(7))
        rMlT2=(ET5+ET7)**2
        do i=1,2
          rMlT2=rMlT2-(qcol(i,5)+qcol(i,7))**2
        end do
        trans(6)=sqrt(abs(rMlT2))
      end if
    ! calculate *full* contranverse mass 1
      if(o_tran(7) == 1)then
        rM_CT12=(ET3+ET4+ET5+ET7+ETmiss)**2 &
        +(pT(3)+pT(4)+pT(5)+pT(7)-ETmiss)**2
        trans(7)=sqrt(abs(rM_CT12))
      end if
    ! calculate *full* contranverse mass 2
      if(o_tran(8) == 1)then
        rM_CT22=(ET3+ET4+ET5+ET7+ETmiss)**2
        do i=1,2
          rM_CT22=rM_CT22-(pTvis(i)-pTmiss(i))**2
        end do
        trans(8)=sqrt(abs(rM_CT22))
      end if
    ! calculate *full* contranverse mass 3
      if(o_tran(9) == 1)then
        rM_CT32=(ETvis+ETmiss)**2
        do i=1,2
          rM_CT32=rM_CT32-(pTvis(i)-pTmiss(i))**2
        end do
        trans(9)=sqrt(abs(rM_CT32))
      end if
    ! calculate lepton contransverse mass
      if(o_tran(10) == 1)then
        ET5=sqrt(rm5**2+pT2(5))
        ET7=sqrt(rm7**2+pT2(7))
        rMlCT2=(ET5+ET7)**2
        do i=1,2
          rMlCT2=rMlCT2-(qcol(i,5)-qcol(i,7))**2
        end do
        trans(10)=sqrt(abs(rMlCT2))
      end if
    ! calculate top pseudorapidity
      if(ifinal_state > 0)then
        rps356=(q(3,3)+q(3,5)+q(3,6)) &
        /sqrt((q(1,3)+q(1,5)+q(1,6))**2 &
        +(q(2,3)+q(2,5)+q(2,6))**2 &
        +(q(3,3)+q(3,5)+q(3,6))**2)
        if(rps356 < -1.d0)rps=-1.d0
        if(rps356 > +1.d0)rps=+1.d0
        rpl356=dacos(rps356)
        arg356=tan(rpl356/2d0)
        if(arg356 <= 0.d0)arg356=1.d-9
        eta356=-log(arg356)

        rps478=(q(3,4)+q(3,7)+q(3,8)) &
        /sqrt((q(1,4)+q(1,7)+q(1,8))**2 &
        +(q(2,4)+q(2,7)+q(2,8))**2 &
        +(q(3,4)+q(3,7)+q(3,8))**2)
        if(rps478 < -1.d0)rps=-1.d0
        if(rps478 > +1.d0)rps=+1.d0
        rpl478=dacos(rps478)
        arg478=tan(rpl478/2d0)
        if(arg478 <= 0.d0)arg478=1.d-9
        eta478=-log(arg478)   ! no cuts on pseudorapidity yet
      end if
    ! Calculate rapdity (y) of top and antitop
      if(ifinal_state == 0)then
        yt= 0.5*log((qcol(4,3)+qcol(3,3))/(qcol(4,3)-qcol(3,3)))
        ytb=0.5*log((qcol(4,4)+qcol(3,4))/(qcol(4,4)-qcol(3,4)))
      else if(ifinal_state > 0)then
        yt =0.5*log((qcol(4,3)+qcol(4,5)+qcol(4,6) &
        +qcol(3,3)+qcol(3,5)+qcol(3,6)) &
        /(qcol(4,3)+qcol(4,5)+qcol(4,6) &
        -qcol(3,3)-qcol(3,5)-qcol(3,6)))
        ytb=0.5*log((qcol(4,4)+qcol(4,7)+qcol(4,8) &
        +qcol(3,4)+qcol(3,7)+qcol(3,8)) &
        /(qcol(4,4)+qcol(4,7)+qcol(4,8) &
        -qcol(3,4)-qcol(3,7)-qcol(3,8)))
      end if

    ! calculate Delta_absy for ARFB
      Delta_absy=abs(yt)-abs(ytb)

    ! calculate cos(theta_l+)
      if(ifinal_state > 0)then
        cost5=+(q(1,5)*q(1,1) &
        +q(2,5)*q(2,1) &
        +q(3,5)*q(3,1)) &
        /sqrt(q(1,5)*q(1,5) &
        +q(2,5)*q(2,5) &
        +q(3,5)*q(3,5)) &
        /sqrt(q(1,1)*q(1,1) &
        +q(2,1)*q(2,1) &
        +q(3,1)*q(3,1))
      end if
    ! calculate cos(theta_l-)
      if(ifinal_state > 0)then
        cost7=+(q(1,7)*q(1,1) &
        +q(2,7)*q(2,1) &
        +q(3,7)*q(3,1)) &
        /sqrt(q(1,7)*q(1,7) &
        +q(2,7)*q(2,7) &
        +q(3,7)*q(3,7)) &
        /sqrt(q(1,1)*q(1,1) &
        +q(2,1)*q(2,1) &
        +q(3,1)*q(3,1))
      end if

      if(ifinal_state > 0)then
        ct7ct5=cost7*cost5
      end if
    ! calculate costst
      costst=int(ytt/abs(ytt))*costcm
    ! Calculate cos(phi_l) (lepton azimuthal angle)
      if(ifinal_state > 0)then
        p5m=sqrt(q(1,5)*q(1,5)+q(2,5)*q(2,5)+q(3,5)*q(3,5))

      ! p(1)^ is z^
        do i=1,3
          zp(i)=q(i,1)/sqrt(q(1,1)*q(1,1)+q(2,1)*q(2,1)+q(3,1)*q(3,1))
        end do

      ! p(5)_T^ is x^
        do i=1,2
          xp(i)=p356(i)/sqrt(p356(1)*p356(1)+p356(2)*p356(2))
        end do
        xp(3)=0

      ! y^ obtained using cross product
        yp(1) = zp(2) * xp(3) - zp(3) * xp(2)
        yp(2) = zp(3) * xp(1) - zp(1) * xp(3)
        yp(3) = zp(1) * xp(2) - zp(2) * xp(1)

        p5xp=0
        do i=1,3
          p5xp=p5xp+q(i,5)*xp(i)
        end do
        p5yp=0
        do i=1,3
          p5yp=p5yp+q(i,5)*yp(i)
        end do
        p5zp=0
        do i=1,3
          p5zp=p5zp+q(i,5)*zp(i)
        end do

        p5mp=sqrt(p5xp*p5xp+p5yp*p5yp+p5zp*p5zp)

        if(abs(p5m-p5mp) >= 1E-11)write(*,*)'Error in coord transform.'

        fl=atan2(p5yp,p5xp)

        if(fl < 0)fl=fl+2*pi

        cosfl=cos(fl)
      end if
    
    ! Selections
    ! Cut on top pT
      if(ifinal_state == 0)then
        if(abs(eta(3)) > ytmax)then
          fffxn=0.d0
          return
        end if
      else if(abs(eta356) > ytmax)then
        fffxn=0.d0
        return
      end if

    ! Matrix elements
    ! Phase space only
    ! Set |M|^2 =1 (for bug squishing) and skip matrix element calculation
      if(o_M_eq_1 == 1)then
        if(ix == 1)then
          pfx1tot=0.5/x1
          pfx2tot=0.5/x1
        else if(ix == 2)then
          pfx1tot=0.5/x2
          pfx2tot=0.5/x2
        end if
        if(ifinal_state == 0)then
          do lam3=-1,1,2
            do lam4=-1,1,2
              if(ix == 1)then
                pfx1(lam3,lam4)=0.5/x1/(pfx1tot+pfx2tot)
                pfx2(lam3,lam4)=0.5/x1/(pfx1tot+pfx2tot)
              else if(ix == 2)then
                pfx1(lam3,lam4)=0.5/x2/(pfx1tot+pfx2tot)
                pfx2(lam3,lam4)=0.5/x2/(pfx1tot+pfx2tot)
              end if
            end do
          end do
        end if
        go to 666
      end if
    
      if(ifinal_state == 0)then
        ! Assign 2to2 MadGraph momenta    
        do i=1,3
          p1(i)=q(i,1)
          p2(i)=q(i,2)
          p3(i)=q(i,3)
          p4(i)=q(i,4)
          p5(i)=0.d0
          p6(i)=0.d0
          p7(i)=0.d0
          p8(i)=0.d0
        end do
        p1(0)=q(4,1)
        p2(0)=q(4,2)
        p3(0)=q(4,3)
        p4(0)=q(4,4)
        p5(0)=0.d0
        p6(0)=0.d0
        p7(0)=0.d0
        p8(0)=0.d0

        ! Check 2to2 kinematics
        ! write(*,*) 'p1  =',p1
        ! write(*,*) 'p2  =',p2
        ! write(*,*) 'p3  =',p3
        ! write(*,*) 'p4  =',p4
        ! delta_E=p1(0)+p2(0)-p3(0)-p4(0)
        ! delta_x=p1(1)+p2(1)-p3(1)-p4(1)
        ! delta_y=p1(2)+p2(2)-p3(2)-p4(2)
        ! delta_z=p1(3)+p2(3)-p3(3)-p4(3)
        ! write(*,*) 'delta_E=',delta_E
        ! write(*,*) 'delta_x=',delta_x
        ! write(*,*) 'delta_y=',delta_y
        ! write(*,*) 'delta_z=',delta_z
        ! rmassa1=sqrt(abs(p1(0)**2-p1(1)**2-p1(2)**2-p1(3)**2))
        ! rmassa2=sqrt(abs(p2(0)**2-p2(1)**2-p2(2)**2-p2(3)**2))
        ! rmassa3=sqrt(abs(p3(0)**2-p3(1)**2-p3(2)**2-p3(3)**2))
        ! rmassa4=sqrt(abs(p4(0)**2-p4(1)**2-p4(2)**2-p4(3)**2))
        ! write(*,*) 'rm_1 =',rmassa1
        ! write(*,*) 'rm_2 =',rmassa2
        ! write(*,*) 'rm_3 =',rmassa3
        ! write(*,*) 'rm_4 =',rmassa4


      else if(ifinal_state > 0)then
      ! Assign 2to6 MadGraph momenta
        do i=1,3
          p1(i)=q(i,1)
          p2(i)=q(i,2)
          p3(i)=q(i,3)
          p4(i)=q(i,4)
          p5(i)=q(i,5)
          p6(i)=q(i,6)
          p7(i)=q(i,7)
          p8(i)=q(i,8)
        end do
        p1(0)=q(4,1)
        p2(0)=q(4,2)
        p3(0)=q(4,3)
        p4(0)=q(4,4)
        p5(0)=q(4,5)
        p6(0)=q(4,6)
        p7(0)=q(4,7)
        p8(0)=q(4,8)

      ! Check 6-body kinematics
      !       write(*,*) 'p1  =',p1
      !       write(*,*) 'p2  =',p2
      !       write(*,*) 'p3  =',p3
      !       write(*,*) 'p4  =',p4
      !       write(*,*) 'p5  =',p5
      !       write(*,*) 'p6  =',p6
      !       write(*,*) 'p7  =',p7
      !       write(*,*) 'p8  =',p8
      ! ! check conservation of 4-momentum.
      !       delta_E=p1(0)+p2(0)
      !    &         -p3(0)-p4(0)
      !    &         -p5(0)-p6(0)
      !    &         -p7(0)-p8(0)
      !       delta_x=p1(1)+p2(1)
      !    &         -p3(1)-p4(1)
      !    &         -p5(1)-p6(1)
      !    &         -p7(1)-p8(1)
      !       delta_y=p1(2)+p2(2)
      !    &         -p3(2)-p4(2)
      !    &         -p5(2)-p6(2)
      !    &         -p7(2)-p8(2)
      !       delta_z=p1(3)+p2(3)
      !    &         -p3(3)-p4(3)
      !    &         -p5(3)-p6(3)
      !    &         -p7(3)-p8(3)
      !       write(*,*) 'delta_E=',delta_E
      !       write(*,*) 'delta_px=',delta_x
      !       write(*,*) 'delta_py=',delta_y
      !       write(*,*) 'delta_pz=',delta_z
      ! ! check invarient mass.
      !       rmassa1=sqrt(abs(p1(0)**2-p1(1)**2-p1(2)**2-p1(3)**2))
      !       rmassa2=sqrt(abs(p2(0)**2-p2(1)**2-p2(2)**2-p2(3)**2))
      !       rmassa3=sqrt(abs(p3(0)**2-p3(1)**2-p3(2)**2-p3(3)**2))
      !       rmassa4=sqrt(abs(p4(0)**2-p4(1)**2-p4(2)**2-p4(3)**2))
      !       rmassa5=sqrt(abs(p5(0)**2-p5(1)**2-p5(2)**2-p5(3)**2))
      !       rmassa6=sqrt(abs(p6(0)**2-p6(1)**2-p6(2)**2-p6(3)**2))
      !       rmassa7=sqrt(abs(p7(0)**2-p7(1)**2-p7(2)**2-p7(3)**2))
      !       rmassa8=sqrt(abs(p8(0)**2-p8(1)**2-p8(2)**2-p8(3)**2))
      !       write(*,*) 'rm_1 =',rmassa1
      !       write(*,*) 'rm_2 =',rmassa2
      !       write(*,*) 'rm_3 =',rmassa3
      !       write(*,*) 'rm_4 =',rmassa4
      !       write(*,*) 'rm_5 =',rmassa5
      !       write(*,*) 'rm_6 =',rmassa6
      !       write(*,*) 'rm_7 =',rmassa7
      !       write(*,*) 'rm_8 =',rmassa8
      ! ! check missing momentum
      !       pT682=(qcol(1,6)+qcol(1,8))**2+(qcol(2,6)+qcol(2,8))**2
      !       pT68=sqrt(pT682)
      !       write(*,*)'ETmiss :',ETmiss
      !       write(*,*)'pT(v+v):',pT68
      end if

    ! Square Matrix elements
    ! Calculate strong coupling
      a_s=alfas(QQ,rLambdaQCD4,nloops)
      gs2=4.d0*pi*a_s
      gs=sqrt(gs2)

    ! (Do not change the deliberate order of p6 and p7 in the EW code.)
    ! Initilize
      qcdqq1=0
      qcdbb1=0
      qcdgg1=0
      ewzuu1=0
      ewzdd1=0
      ewzbb1=0
      qcdqq2=0
      qcdbb2=0
      qcdgg2=0
      ewzuu2=0
      ewzdd2=0
      ewzbb2=0
      do ii=-1,1,1
        do jj=-1,1,1
          qcdpolqq1(-1:1,-1:1)=0
          qcdpolbb1(-1:1,-1:1)=0
          qcdpolgg1(-1:1,-1:1)=0
          ewzpoluu1(-1:1,-1:1)=0
          ewzpoldd1(-1:1,-1:1)=0
          ewzpolbb1(-1:1,-1:1)=0
          qcdpolqq2(-1:1,-1:1)=0
          qcdpolbb2(-1:1,-1:1)=0
          qcdpolgg2(-1:1,-1:1)=0
          ewzpoluu2(-1:1,-1:1)=0
          ewzpoldd2(-1:1,-1:1)=0
          ewzpolbb2(-1:1,-1:1)=0
          do kk=1,20
            weight(kk,ii,jj)=0.d0
          end do
        end do
      end do
      resall=0
      if(ifinal_state == 0)then
        ! compute 2to2 MEs
        if(include_QCD == 1)then
          ! compute QCD square matrix elements
          do lam3=-1,1,2
            do lam4=-1,1,2
              qcdpolgg1(lam3,lam4)=sggff_qcd(   p1,p2,p3,p4,lam3,lam4)*gs**4
              qcdpolgg2(lam3,lam4)=sggff_qcd(   p2,p1,p3,p4,lam3,lam4)*gs**4
              qcdpolqq1(lam3,lam4)=sqqff_qcd(3 ,p1,p2,p3,p4,lam3,lam4)*gs**4
              qcdpolqq2(lam3,lam4)=sqqff_qcd(3 ,p2,p1,p3,p4,lam3,lam4)*gs**4
              qcdpolbb1(lam3,lam4)=sqqff_qcd(12,p1,p2,p3,p4,lam3,lam4)*gs**4
              qcdpolbb2(lam3,lam4)=sqqff_qcd(12,p2,p1,p3,p4,lam3,lam4)*gs**4
              resall=resall &
              +qcdpolgg1(lam3,lam4) &
              +qcdpolgg2(lam3,lam4) &
              +qcdpolqq1(lam3,lam4) &
              +qcdpolqq2(lam3,lam4) &
              +qcdpolbb1(lam3,lam4) &
              +qcdpolbb2(lam3,lam4)
            end do
          end do
        end if
        if((include_EW == 1) .OR. (include_BSM == 1))then
          ! compute EW and Z' square matrix elements
          do lam3=-1,1,2
            do lam4=-1,1,2
              ewzpoluu1(lam3,lam4)=sqqff_EWp( 3,11,p1,p2,p3,p4,lam3,lam4)
              ewzpoluu2(lam3,lam4)=sqqff_EWp( 3,11,p2,p1,p3,p4,lam3,lam4)
              ewzpoldd1(lam3,lam4)=sqqff_EWp( 4,11,p1,p2,p3,p4,lam3,lam4)
              ewzpoldd2(lam3,lam4)=sqqff_EWp( 4,11,p2,p1,p3,p4,lam3,lam4)
              ewzpolbb1(lam3,lam4)=sqqff_EWp(12,11,p1,p2,p3,p4,lam3,lam4)
              ewzpolbb2(lam3,lam4)=sqqff_EWp(12,11,p2,p1,p3,p4,lam3,lam4)
              resall=resall &
             +ewzpoluu1(lam3,lam4) &
             +ewzpoluu2(lam3,lam4) &
             +ewzpoldd1(lam3,lam4) &
             +ewzpoldd2(lam3,lam4) &
             +ewzpolbb1(lam3,lam4) &
             +ewzpolbb2(lam3,lam4)
            end do
          end do
        end if

      else if(ifinal_state > 0)then
        ! 6-body MEs
        if(include_QCD == 1)then
          ! compute QCD square matrix elements
          qcdqq1=sqqbbffff_qcd(3 , p1, p2, p3, p4, p5, p7, p6, p8 )
          qcdqq2=sqqbbffff_qcd(3 , p2, p1, p3, p4, p5, p7, p6, p8 )
          qcdbb1=sqqbbffff_qcd(12, p1, p2, p3, p4, p5, p7, p6, p8 )
          qcdbb2=sqqbbffff_qcd(12, p2, p1, p3, p4, p5, p7, p6, p8 )
          qcdgg1=sggbbffff_qcd(    p1, p2, p3, p4, p5, p7, p6, p8 )
          qcdgg2=sggbbffff_qcd(    p2, p1, p3, p4, p5, p7, p6, p8 )
        end if
        if((include_EW == 1) .or. (include_BSM == 1))then
          ! compute EW and Z' square matrix elements
          ewzuu1=sqqbbffff_ewp( 3,11, p1, p2, p3, p4, p5, p7, p6, p8)
          ewzuu2=sqqbbffff_ewp( 3,11, p2, p1, p3, p4, p5, p7, p6, p8)
          ewzdd1=sqqbbffff_ewp( 4,11, p1, p2, p3, p4, p5, p7, p6, p8)
          ewzdd2=sqqbbffff_ewp( 4,11, p2, p1, p3, p4, p5, p7, p6, p8)
          ewzbb1=sqqbbffff_ewp(12,11, p1, p2, p3, p4, p5, p7, p6, p8)
          ewzbb2=sqqbbffff_ewp(12,11, p2, p1, p3, p4, p5, p7, p6, p8)
        end if
        resall=qcdqq1+qcdgg1+qcdbb1+ewzuu1+ewzdd1+ewzbb1 &
        +qcdqq2+qcdgg2+qcdbb2+ewzuu2+ewzdd2+ewzbb2
      end if

      if((resall) == 0.d0)then
        write(*,*)'|M|^2 = 0 for phase space point ',npoints
        fffxn=0.d0
        return
      end if

      ! multiple QCD |M|^2 by g_s^4 (Madgraph gs is set to one due to scale dependence.)
      qcdqq1=qcdqq1*gs**4
      qcdgg1=qcdgg1*gs**4
      qcdqq2=qcdqq2*gs**4
      qcdgg2=qcdgg2*gs**4

      ! sum over |M|^2 with PDFs for all initial partons    
      pfx1tot=0.d0
      pfx2tot=0.d0
      if(ifinal_state == 0) then
        ! sum over all polarised |M|^2
        do lam3=-1,1,2
          do lam4=-1,1,2
            pfx1(lam3,lam4)=qcdpolgg1(lam3,lam4) *fx1(13)*fx2(13)/2.d0 &
            +(qcdpolqq1(lam3,lam4)+ewzpoldd1(lam3,lam4))*fx1( 1)*fx2( 7) &
            +(qcdpolqq1(lam3,lam4)+ewzpoluu1(lam3,lam4))*fx1( 2)*fx2( 8) &
            +(qcdpolqq1(lam3,lam4)+ewzpoldd1(lam3,lam4))*fx1( 3)*fx2( 9) &
            +(qcdpolqq1(lam3,lam4)+ewzpoluu1(lam3,lam4))*fx1( 4)*fx2(10) &
            +(qcdpolbb1(lam3,lam4)+ewzpolbb1(lam3,lam4))*fx1( 5)*fx2(11)
            pfx2(lam3,lam4)=qcdpolgg2(lam3,lam4) *fx1(13)*fx2(13)/2.d0 &
            +(qcdpolqq2(lam3,lam4)+ewzpoldd2(lam3,lam4))*fx1( 7)*fx2( 1) &
            +(qcdpolqq2(lam3,lam4)+ewzpoluu2(lam3,lam4))*fx1( 8)*fx2( 2) &
            +(qcdpolqq2(lam3,lam4)+ewzpoldd2(lam3,lam4))*fx1( 9)*fx2( 3) &
            +(qcdpolqq2(lam3,lam4)+ewzpoluu2(lam3,lam4))*fx1(10)*fx2( 4) &
            +(qcdpolbb2(lam3,lam4)+ewzpolbb2(lam3,lam4))*fx1(11)*fx2( 5)
            if(ix == 1)then
              pfx1(lam3,lam4)=pfx1(lam3,lam4)/x1
              pfx2(lam3,lam4)=pfx2(lam3,lam4)/x1
            else if(ix == 2)then
              pfx1(lam3,lam4)=pfx1(lam3,lam4)/x2
              pfx2(lam3,lam4)=pfx2(lam3,lam4)/x2
            end if
            pfx1tot=pfx1tot &
            +pfx1(lam3,lam4)
            pfx2tot=pfx2tot &
            +pfx2(lam3,lam4)
          end do
        end do

      else if (ifinal_state > 0) then
        qqd1=fx1( 1)*fx2( 7)*(qcdqq1+ewzdd1) &
        +fx1( 2)*fx2( 8)*(qcdqq1+ewzuu1) &
        +fx1( 3)*fx2( 9)*(qcdqq1+ewzdd1) &
        +fx1( 4)*fx2(10)*(qcdqq1+ewzuu1) &
        +fx1( 5)*fx2(11)*(qcdbb1+ewzbb1)
        qqd2=fx1( 7)*fx2( 1)*(qcdqq2+ewzdd2) &
        +fx1( 8)*fx2( 2)*(qcdqq2+ewzuu2) &
        +fx1( 9)*fx2( 3)*(qcdqq2+ewzdd2) &
        +fx1(10)*fx2( 4)*(qcdqq2+ewzuu2) &
        +fx1(11)*fx2( 5)*(qcdbb2+ewzbb2)
        ggd1=fx1(13)*fx2(13)*qcdgg1/2.d0
        ggd2=fx1(13)*fx2(13)*qcdgg2/2.d0
        if(ix == 1)then
          pfx1tot=(qqd1+ggd1)/x1
          pfx2tot=(qqd2+ggd2)/x1
        else if(ix == 2)then
          pfx1tot=(qqd1+ggd1)/x2
          pfx2tot=(qqd2+ggd2)/x2
        end if
      end if

      write(*,*)pfxt1tot

      if(pfx1tot == 0.d0 .and. pfx2tot == 0.d0)then
          write(*,*)'f(x1)f(x2)|M|^2 = 0 for phase space point ',npoints
          fffxn=0.d0
        return
      end if

      if(ifinal_state == 0)then
        ! weight for distributions
        do lam3=-1,1,2
          do lam4=-1,1,2
            pfx1(lam3,lam4)=pfx1(lam3,lam4)/(pfx1tot+pfx2tot)
            pfx2(lam3,lam4)=pfx2(lam3,lam4)/(pfx1tot+pfx2tot)
          end do
        end do
      end if

      666 continue
    ! Phase space volume
    ! Jacobians from dx1 dx2 -> dx(2) dx(3)
      pfx1tot=pfx1tot*(1.d0-tau)*2.d0*Ecm/s &
      *(ecm_max-rm3-rm4-rm5-rm6-rm7-rm8)
      pfx2tot=pfx2tot*(1.d0-tau)*2.d0*Ecm/s &
      *(ecm_max-rm3-rm4-rm5-rm6-rm7-rm8)
    ! fffxn is now M*M*PDFs
      fffxn1=pfx1tot
      fffxn2=pfx2tot
    ! Multiply by 2pi from phit integration and convert from GeV^-2 to pb
      fffxn1=fffxn1*fac
      fffxn2=fffxn2*fac
      if(ifinal_state == 0)then
      ! 2-body phase space factor
        fffxn1=fffxn1*qcm/(2.d0*pcm)*2.d0**(4-3*(2))
        fffxn1=fffxn1/2.d0/Ecm/Ecm*(2.d0*pi)**(4-3*(2))
        fffxn2=fffxn2*qcm/(2.d0*pcm)*2.d0**(4-3*(2))
        fffxn2=fffxn2/2.d0/Ecm/Ecm*(2.d0*pi)**(4-3*(2))
      else if(ifinal_state > 0)then
      ! 6-body flux factor, pi's and phase space integral
        fffxn1=fffxn1*rq*rq56*rq78*rq5*rq7/Ecm*256.d0*2.d0**(4-3*(6)) &
        /(2.d0*rm356) &
        /rmt/gamt &
        *((rm356*rm356-rmt*rmt)**2+rmt**2*gamt**2)
        fffxn1=fffxn1*(XX356max-XX356min) &
        /(2.d0*rm478) &
        /rmt/gamt &
        *((rm478*rm478-rmt*rmt)**2+rmt**2*gamt**2)
        fffxn1=fffxn1*(XX478max-XX478min) &
        /(2.d0*rm56) &
        /rm_W/gamma_W &
        *((rm56*rm56-rm_W*rm_W)**2+rm_W**2*gamma_W**2)
        fffxn1=fffxn1*(XX56max-XX56min) &
        /(2.d0*rm78) &
        /rm_W/gamma_W &
        *((rm78*rm78-rm_W*rm_W)**2+rm_W**2*gamma_W**2)
        fffxn1=fffxn1*(XX78max-XX78min)
      ! NWA
        fffxn1=fffxn1 &
        *gamt/Gamma_t &
        *gamt/Gamma_t
      ! flux and pi factors.
        fffxn1=fffxn1/2.d0/Ecm/Ecm*(2.d0*pi)**(4-3*(6))

        fffxn2=fffxn2*rq*rq56*rq78*rq5*rq7/Ecm*256.d0*2.d0**(4-3*(6)) &
        /(2.d0*rm356) &
        /rmt/gamt &
        *((rm356*rm356-rmt*rmt)**2+rmt**2*gamt**2)
        fffxn2=fffxn2*(XX356max-XX356min) &
        /(2.d0*rm478) &
        /rmt/gamt &
        *((rm478*rm478-rmt*rmt)**2+rmt**2*gamt**2)
        fffxn2=fffxn2*(XX478max-XX478min) &
        /(2.d0*rm56) &
        /rm_W/gamma_W &
        *((rm56*rm56-rm_W*rm_W)**2+rm_W**2*gamma_W**2)
        fffxn2=fffxn2*(XX56max-XX56min) &
        /(2.d0*rm78) &
        /rm_W/gamma_W &
        *((rm78*rm78-rm_W*rm_W)**2+rm_W**2*gamma_W**2)
        fffxn2=fffxn2*(XX78max-XX78min)
      ! NWA
        fffxn2=fffxn2 &
        *gamt/Gamma_t &
        *gamt/Gamma_t
      ! flux and pi factors.
        fffxn2=fffxn2/2.d0/Ecm/Ecm*(2.d0*pi)**(4-3*(6))
      end if
      fffxn1=fffxn1/real(ixmax)/real(jxmax)
      fffxn2=fffxn2/real(ixmax)/real(jxmax)
      fffxn=fffxn1+fffxn2
    
    ! Categorised cross sections / Asymmetries
         
    ! Polarised total cross sections
    ! Polarised cross section for each point is calculated.
    ! (Note that above pfx was divided by fffxn.)
      if(ifinal_state == 0)then
        do iphel=-1,+1,2
          do jphel=-1,+1,2
            polcross(it,iphel,jphel)=polcross(it,iphel,jphel) &
            +fffxn &
            *wgt &
            *(pfx1(iphel,jphel) &
            +pfx2(iphel,jphel))
            weight(it,iphel,jphel)=+fffxn &
            *wgt &
            *(pfx1(iphel,jphel) &
            +pfx2(iphel,jphel))
            polerror(it,iphel,jphel)=polerror(it,iphel,jphel) &
            +polcross(it,iphel,jphel)**2
          end do
        end do
      end if

    ! AFB
      if(o_asym(4) == 1)then
        if(costcm > 0.d0)then
          spatcross(1,it,+1)=spatcross(1,it,+1) &
          +fffxn &
          *wgt
          spaterror(1,it,+1)=spaterror(1,it,+1) &
          +spatcross(1,it,+1)**2
        else if(costcm < 0.d0)then
          spatcross(1,it,-1)=spatcross(1,it,-1) &
          +fffxn &
          *wgt
          spaterror(1,it,-1)=spaterror(1,it,-1) &
          +spatcross(1,it,-1)**2
        end if
      end if

    ! AFBstar
      if(o_asym(5) == 1)then
        if(costst > 0.d0)then
          spatcross(2,it,+1)=spatcross(2,it,+1) &
          +fffxn &
          *wgt
          spaterror(2,it,+1)=spaterror(2,it,+1) &
          +spatcross(2,it,+1)**2
        else if(costst < 0.d0)then
          spatcross(2,it,-1)=spatcross(2,it,-1) &
          +fffxn &
          *wgt
          spaterror(2,it,-1)=spaterror(2,it,-1) &
          +spatcross(2,it,-1)**2
        end if
      end if

    ! AtRFB
      if(o_asym(6) == 1)then
        if(yt > 0.d0)then
          spatcross(3,it,+1)=spatcross(3,it,+1) &
          +fffxn &
          *wgt
          spaterror(3,it,+1)=spaterror(3,it,+1) &
          +spatcross(3,it,+1)**2
        else if(yt < 0.d0)then
          spatcross(3,it,-1)=spatcross(3,it,-1) &
          +fffxn &
          *wgt
          spaterror(3,it,-1)=spaterror(3,it,-1) &
          +spatcross(3,it,-1)**2
        end if
      end if

    ! AttbRFB/A
      if(o_asym(7) == 1)then
        if(yt >= 0.d0)then
          spatcross(4,it,+1)=spatcross(4,it,+1) &
          +fffxn &
          *wgt
          spaterror(4,it,+1)=spaterror(4,it,+1) &
          +spatcross(4,it,+1)**2
        end if
        if(ytb >= 0.d0)then
          spatcross(4,it,-1)=spatcross(4,it,-1) &
          +fffxn &
          *wgt
          spaterror(4,it,-1)=spaterror(4,it,-1) &
          +spatcross(4,it,-1)**2
        end if
      end if

    ! ARFB/A'

      if((o_asym(8) == 1) .AND. (abs(ytt) > yttmin))then
        if(Delta_absy == 0.d0)then
          continue
        else if(Delta_absy > 0.d0)then
          spatcross(5,it,+1)=spatcross(5,it,+1) &
          +fffxn &
          *wgt
          spaterror(5,it,+1)=spaterror(5,it,+1) &
          +spatcross(5,it,+1)**2
        !       write(*,*)'asy(8)=+1'
        else if(Delta_absy < 0.d0)then
          spatcross(5,it,-1)=spatcross(5,it,-1) &
          +fffxn &
          *wgt
          spaterror(5,it,-1)=spaterror(5,it,-1) &
          +spatcross(5,it,-1)**2
        !       write(*,*)'asy(8)=-1'
        end if
      end if

    ! A_l
      if(o_asym(9) == 1)then
        if(cosfl > 0.d0)then
          spatcross(6,it,+1)=spatcross(6,it,+1) &
          +fffxn &
          *wgt
          spaterror(6,it,+1)=spaterror(6,it,+1) &
          +spatcross(6,it,+1)**2
        else if(cosfl < 0.d0)then
          spatcross(6,it,-1)=spatcross(6,it,-1) &
          +fffxn &
          *wgt
          spaterror(6,it,-1)=spaterror(6,it,-1) &
          +spatcross(6,it,-1)**2
        end if
      end if
    
    ! Binning
    ! scale by weight
      hist1=fffxn1*wgt
      hist2=fffxn2*wgt
      hist=hist1+hist2
      do ip=3,nfinal
      ! generate distribution in pT
        if(o_pT(ip) == 1)then
          nbin=int((pT(ip)-pTmin(ip))/pTw(ip))+1
          if(nbin >= (ndiv_pT(ip)+1))then
            continue
          else if(nbin < 1)then
            continue
          else
            fxpT(ip,nbin,it)=fxpT(ip,nbin,it)+hist
          end if
        end if
      ! generate distribution in eta
        if(o_eta(ip) == 1)then
          nbin=int((eta(ip)-etamin(ip))/etaw(ip))+1
          if(nbin >= (ndiv_eta(ip)+1))then
            continue
          else if(nbin < 1)then
            continue
          else
            fxeta(ip,nbin,it)=fxeta(ip,nbin,it)+hist
          end if
        end if
      ! generate distribution in phi
        if(o_phi(ip) == 1)then
          nbin=int((phi(ip)-phimin(ip))/phiw(ip))+1
          if(nbin >= (ndiv_phi(ip)+1))then
            continue
          else if(nbin < 1)then
            continue
          else
            fxphi(ip,nbin,it)=fxphi(ip,nbin,it)+hist
          end if
        end if
      ! generate distribution in ycol
        if(o_ycol(ip) == 1)then
          nbin=int((ycol(ip)-ycolmin(ip))/ycolw(ip))+1
          if(nbin >= (ndiv_ycol(ip)+1))then
            continue
          else if(nbin < 1)then
            continue
          else
            fxycol(ip,nbin,it)=fxycol(ip,nbin,it)+hist
          end if
        end if
      end do
    ! generate distribution in pT356.
      if(o_pT356 == 1)then
        nbin=int((pT356-pT356min)/pT356w)+1
        if(nbin >= (ndiv_pT356+1))then
          continue
        else if(nbin < 1)then
          continue
        else
          fxpT356(nbin,it)=fxpT356(nbin,it)+hist
        end if
      end if

      if(o_eta356 == 1)then
      ! generate distribution in eta356.
        nbin=int((eta356-eta356min)/eta356w)+1
        if(nbin >= (ndiv_eta356+1))then
          continue
        else if(nbin < 1)then
          continue
        else
          fxeta356(nbin,it)=fxeta356(nbin,it)+hist
        end if
      end if

      if(o_phi356 == 1)then
      ! generate distribution in phi356.
        nbin=int((phi356-phi356min)/phi356w)+1
        if(nbin >= (ndiv_phi356+1))then
          continue
        else if(nbin < 1)then
          continue
        else
          fxphi356(nbin,it)=fxphi356(nbin,it)+hist
        end if
      end if

      if(o_pT478 == 1)then
      ! generate distribution in pT478.
        nbin=int((pT478-pT478min)/pT478w)+1
        if(nbin >= (ndiv_pT478+1))then
          continue
        else if(nbin < 1)then
          continue
        else
          fxpT478(nbin,it)=fxpT478(nbin,it)+hist
        end if
      end if

      if(o_eta478 == 1)then
      ! generate distribution in eta478.
        nbin=int((eta478-eta478min)/eta478w)+1
        if(nbin >= (ndiv_eta478+1))then
          continue
        else if(nbin < 1)then
          continue
        else
          fxeta478(nbin,it)=fxeta478(nbin,it)+hist
        end if
      end if

      if(o_phi478 == 1)then
      ! generate distribution in phi478.
        nbin=int((phi478-phi478min)/phi478w)+1
        if(nbin >= (ndiv_phi478+1))then
          continue
        else if(nbin < 1)then
          continue
        else
          fxphi478(nbin,it)=fxphi478(nbin,it)+hist
        end if
      end if

      if(o_ETmiss == 1)then
      ! generate distribution in ETmiss.
        nbin=int((ETmiss-ETmissmin)/ETmissw)+1
        if(nbin >= (ndiv_ETmiss+1))then
          continue
        else if(nbin < 1)then
          continue
        else
          fxETmiss(nbin,it)=fxETmiss(nbin,it)+hist
        end if
      end if

      if(o_rMtt == 1)then
        ! generate distribution in Mtt.
        nbin=int((rMtt-rMttmin)/rMttw)+1
        if(nbin >= (ndiv_rMtt+1))then
          continue
        else if(nbin < 1)then
          continue
        else
          fxrMtt(nbin,it)=fxrMtt(nbin,it)+hist
        end if
      end if

      if(o_beta == 1)then
      ! generate distribution in beta.
        beta=shat/4.d0/rmt**2-1.d0
        nbin=int((beta-betamin)/betaw)+1
        if(nbin >= (ndiv_beta+1))then
          continue
        else if(nbin < 1)then
          continue
        else
          fxbeta(nbin,it)=fxbeta(nbin,it)+hist
        end if
      end if

      if(o_cost == 1)then
      ! generate distribution in cost.
        nbin=int((cost-costmin)/costw)+1
        if(nbin >= (ndiv_cost+1))then
          continue
        else if(nbin < 1)then
          continue
        else
          fxcost(nbin,it)=fxcost(nbin,it)+hist
        end if
      end if

      if(o_Et == 1)then   !enerate distribution in Et.
        nbin=int((Et-Etmin)/Etw)+1
        if(nbin >= (ndiv_Et+1))then
          continue
        else if(nbin < 1)then
          continue
        else
          fxEt(nbin,it)=fxEt(nbin,it)+hist
        end if
      end if

      if(o_Delta_y == 1)then   !enerate distribution in Delta_absy.
        nbin=int((Delta_absy-Delta_ymin)/Delta_yw)+1
        if(nbin >= (ndiv_Delta_y+1))then
          continue
        else if(nbin < 1)then
          continue
        else
          fxDelta_y(nbin,it)=fxDelta_y(nbin,it)+hist
        end if
      end if

      do itrans=1,ntrans
        if(o_tran(itrans) == 1)then
        ! generate distribution in trans.
          nbin=int((trans(itrans)-transmin(itrans))/transw(itrans))+1
          if(nbin >= (ndiv_trans(itrans)+1))then
            continue
          else if(nbin < 1)then
            continue
          else
            fxtrans(itrans,nbin,it)=fxtrans(itrans,nbin,it)+hist
          end if
        end if
      end do

      if(o_fl == 1)then
      ! generate distribution in fl.
        nbin=int((fl-flmin)/flw)+1
        if(nbin >= (ndiv_fl+1))then
          continue
        else if(nbin < 1)then
          continue
        else
          fxfl(nbin,it)=fxfl(nbin,it)+hist
        end if
      end if


      if(o_cosfl == 1)then
      ! generate distribution in cosfl.
        nbin=int((cosfl-cosflmin)/cosflw)+1
        if(nbin >= (ndiv_cosfl+1))then
          continue
        else if(nbin < 1)then
          continue
        else
          fxcosfl(nbin,it)=fxcosfl(nbin,it)+hist
        end if
      end if


      if(o_dphi == 1)then
      ! generate distribution in dphi.
        nbin=int((dphi-dphimin)/dphiw)+1
        if(nbin >= (ndiv_dphi+1))then
          continue
        else if(nbin < 1)then
          continue
        else
          fxdphi(nbin,it)=fxdphi(nbin,it)+hist
        end if
      end if

      if(o_cost5 == 1)then
      ! generate distribution in cost5.
        nbin=int((cost5-cost5min)/cost5w)+1
        if(nbin >= (ndiv_cost5+1))then
          continue
        else if(nbin < 1)then
          continue
        else
          fxcost5(nbin,it)=fxcost5(nbin,it)+hist
        end if
      end if

      if(o_cost7 == 1)then
      ! generate distribution in cost7.
        nbin=int((cost7-cost7min)/cost7w)+1
        if(nbin >= (ndiv_cost7+1))then
          continue
        else if(nbin < 1)then
          continue
        else
          fxcost7(nbin,it)=fxcost7(nbin,it)+hist
        end if
      end if

      if(o_ct7ct5 == 1)then
        nbin=int((ct7ct5-ct7ct5min)/ct7ct5w)+1
        if(nbin >= (ndiv_ct7ct5+1))then
          continue
        else if(nbin < 1)then
          continue
        else
          fxct7ct5(nbin,it)=fxct7ct5(nbin,it)+hist
        end if
      end if

      if(o_dphi2d == 1)then
      ! generate distribution in dphi2d.
        ibin=int((dphi-dphimin)/dphiw)+1
        jbin=int((rMtt-rMttmin)/rMttw)+1
        if((ibin > ndiv_dphi) .OR. (jbin > ndiv_rMtt))then
          continue
        else if((ibin < 1) .OR. (jbin < 1))then
          continue
        else
          fxdphi2d(ibin,jbin,it)=fxdphi2d(ibin,jbin,it)+hist
        end if
      end if

      do itrans=1,ntrans
        if(o_transdp(itrans) == 1)then
        ! generate distribution in transdp.
          ibin=int((dphi-dphimin)/dphiw)+1
          jbin=int((trans(itrans)-transmin(itrans))/transw(itrans))+1
          if((ibin > ndiv_dphi) .OR. (jbin >= (ndiv_trans(itrans)+1)))then
            continue
          else if((ibin < 1) .OR. (jbin < 1))then
            continue
          else
            fxtransdp(itrans,ibin,jbin,it)= &
            fxtransdp(itrans,ibin,jbin,it)+hist
          end if
        end if
      end do

      if(o_asym(1) == 1)then
        if(o_sigp == 1)then
        ! generate distribution in sigp for ALL.
          sigp=Ecm
          nbin=int((sigp-sigpmin)/sigpw)+1
          if(nbin >= (ndiv_sigp+1))then
            continue
          else if(nbin < 1)then
            continue
          else
            fxsigp(1,nbin,it)=fxsigp(1,nbin,it)+ &
            (weight(it,+1,+1)+weight(it,-1,-1))   !ction happens
          end if
        end if
        if(o_sigm == 1)then
        ! generate distribution in sigm for ALL.
          sigm=Ecm
          nbin=int((sigm-sigmmin)/sigmw)+1
          if(nbin >= (ndiv_sigm+1))then
            continue
          else if(nbin < 1)then
            continue
          else
            fxsigm(1,nbin,it)=fxsigm(1,nbin,it)+ &
            (weight(it,+1,-1)+weight(it,-1,+1))
          end if
        end if
      end if

      if(o_asym(2) == 1)then
        if(o_sigp == 1)then
        ! generate distribution in sigp for AL.
          sigp=Ecm
          nbin=int((sigp-sigpmin)/sigpw)+1
          if(nbin >= (ndiv_sigp+1))then
            continue
          else if(nbin < 1)then
            continue
          else
            fxsigp(2,nbin,it)=fxsigp(2,nbin,it)+ &
            (weight(it,-1,-1)+weight(it,-1,+1))
          end if
        end if
        if(o_sigm == 1)then
        ! generate distribution in sigm for AL.
          sigm=Ecm
          nbin=int((sigm-sigmmin)/sigmw)+1
          if(nbin >= (ndiv_sigm+1))then
            continue
          else if(nbin < 1)then
            continue
          else
            fxsigm(2,nbin,it)=fxsigm(2,nbin,it)+ &
            (weight(it,+1,-1)+weight(it,+1,+1))
          end if
        end if
      end if

      if(o_asym(3) == 1)then
        if(o_sigp == 1)then
        ! generate distribution in sigp for APV.
          sigp=Ecm
          nbin=int((sigp-sigpmin)/sigpw)+1
          if(nbin >= (ndiv_sigp+1))then
            continue
          else if(nbin < 1)then
            continue
          else
            fxsigp(3,nbin,it)=fxsigp(3,nbin,it)+ &
            (weight(it,-1,-1))
          end if
        end if
        if(o_sigm == 1)then
        ! generate distribution in sigm for APV.
          sigm=Ecm
          nbin=int((sigm-sigmmin)/sigmw)+1
          if(nbin >= (ndiv_sigm+1))then
            continue
          else if(nbin < 1)then
            continue
          else
            fxsigm(3,nbin,it)=fxsigm(3,nbin,it)+ &
            (weight(it,+1,+1))
          end if
        end if
      end if

      if(o_asym(4) == 1)then
        if((o_sigp == 1) .AND. (costcm > 0.d0))then
        ! generate distribution in sigp for AFBcm.
          sigp=Ecm
          nbin=int((sigp-sigpmin)/sigpw)+1
          if(nbin >= (ndiv_sigp+1))then
            continue
          else if(nbin < 1)then
            continue
          else
            fxsigp(4,nbin,it)=fxsigp(4,nbin,it)+hist
          end if
        end if
        if((o_sigm == 1) .AND. (costcm < 0.d0))then
        ! generate distribution in sigm for AFBcm.
          sigm=Ecm
          nbin=int((sigm-sigmmin)/sigmw)+1
          if(nbin >= (ndiv_sigm+1))then
            continue
          else if(nbin < 1)then
            continue
          else
            fxsigm(4,nbin,it)=fxsigm(4,nbin,it)+hist
          end if
        end if
      end if

      if(o_asym(5) == 1)then
        if((o_sigp == 1) .AND. (costst > 0.d0))then
        ! generate distribution in sigp for AFBstar.
          sigp=Ecm
          nbin=int((sigp-sigpmin)/sigpw)+1
          if(nbin >= (ndiv_sigp+1))then
            continue
          else if(nbin < 1)then
            continue
          else
            fxsigp(5,nbin,it)=fxsigp(5,nbin,it)+hist
          end if
        end if
        if((o_sigm == 1) .AND. (costst < 0.d0))then
        ! generate distribution in sigm for AFBstar.
          sigm=Ecm
          nbin=int((sigm-sigmmin)/sigmw)+1
          if(nbin >= (ndiv_sigm+1))then
            continue
          else if(nbin < 1)then
            continue
          else
            fxsigm(5,nbin,it)=fxsigm(5,nbin,it)+hist
          end if
        end if
      end if

      if(o_asym(6) == 1)then
        if((o_sigp == 1) .AND. (yt > 0.d0))then
        ! generate distribution in sigp for AtFB.
          sigp=Ecm
          nbin=int((sigp-sigpmin)/sigpw)+1
          if(nbin >= (ndiv_sigp+1))then
            continue
          else if(nbin < 1)then
            continue
          else
            fxsigp(6,nbin,it)=fxsigp(6,nbin,it)+hist
          end if
        end if
        if((o_sigm == 1) .AND. (yt < 0.d0))then
        ! generate distribution in sigm for AtFB.
          sigm=Ecm
          nbin=int((sigm-sigmmin)/sigmw)+1
          if(nbin >= (ndiv_sigm+1))then
            continue
          else if(nbin < 1)then
            continue
          else
            fxsigm(6,nbin,it)=fxsigm(6,nbin,it)+hist
          end if
        end if
      end if

      if(o_asym(7) == 1)then
        if((o_sigp == 1) .AND. (yt >= 0.d0))then
        ! generate distribution in sigp for A.
          sigp=Ecm
          nbin=int((sigp-sigpmin)/sigpw)+1
          if(nbin >= (ndiv_sigp+1))then
            continue
          else if(nbin < 1)then
            continue
          else
            fxsigp(7,nbin,it)=fxsigp(7,nbin,it)+hist
          end if
        end if
        if((o_sigm == 1) .AND. (ytb >= 0.d0))then
        ! generate distribution in sigm for A.
          sigm=Ecm
          nbin=int((sigm-sigmmin)/sigmw)+1
          if(nbin >= (ndiv_sigm+1))then
            continue
          else if(nbin < 1)then
            continue
          else
            fxsigm(7,nbin,it)=fxsigm(7,nbin,it)+hist
          end if
        end if
      end if

      if(o_asym(8) == 1)then
        if((o_sigp == 1) .AND. (Delta_absy > 0.d0))then
        ! generate distribution in sigp for ARFB.
          sigp=Ecm
          nbin=int((sigp-sigpmin)/sigpw)+1
          if(nbin >= (ndiv_sigp+1))then
            continue
          else if(nbin < 1)then
            continue
          else
            if(abs(ytt) > yttmin)fxsigp(8,nbin,it)=fxsigp(8,nbin,it)+hist
          end if
        end if
        if((o_sigm == 1) .AND. (Delta_absy < 0.d0))then
        ! generate distribution in sigm for ARFB.
          sigm=Ecm
          nbin=int((sigm-sigmmin)/sigmw)+1
          if(nbin >= (ndiv_sigm+1))then
            continue
          else if(nbin < 1)then
            continue
          else
            if(abs(ytt) > yttmin)fxsigm(8,nbin,it)=fxsigm(8,nbin,it)+hist
          end if
        end if
      end if


      if(o_asym(9) == 1)then
        if((o_sigp == 1) .AND. (cosfl > 0.d0))then
        ! generate distribution in sigp for A_l.
          sigp=Ecm
          nbin=int((sigp-sigpmin)/sigpw)+1
          if(nbin >= (ndiv_sigp+1))then
            continue
          else if(nbin < 1)then
            continue
          else
            fxsigp(9,nbin,it)=fxsigp(9,nbin,it)+hist
          end if
        end if
        if((o_sigm == 1) .AND. (cosfl < 0.d0))then
        ! generate distribution in sigm for A_l.
          sigm=Ecm
          nbin=int((sigm-sigmmin)/sigmw)+1
          if(nbin >= (ndiv_sigm+1))then
            continue
          else if(nbin < 1)then
            continue
          else
            fxsigm(9,nbin,it)=fxsigm(9,nbin,it)+hist
          end if
        end if
      end if
    
      ! stats
      npoints=npoints+1
      
      ffxn=ffxn+fffxn
    end do ! end loop costheta_t<->-cost
    dxsec=dxsec+ffxn  
  end do ! end loop x1 <-> x2
  return
end function dxsec
