c ======================================================================
      function fxn(x,wgt)
! ----------------------------------------------------------------------
! Header
  ! Authors: Declan Millar, Stefano Moretti 

  ! Returns the fully differential cross section for
  !   pp -> tt,
  !   pp -> tt -> bW^+bbarW^- -> bbbare^+nue^-nubarc 
  ! This is then passed to VEGAS in the main program.

  ! Matrix element and phase space integration function.
  ! Called each time a phase space point is generated by VEGAS.
  ! Calculates matrix element using HELAS subroutines, scales by phase 
  ! space volume factor and populates distributions for set of defined 
  ! observables accordingly.
! ----------------------------------------------------------------------
! Declarations
  !implicit
      implicit real*8 (a-h,o-z)
  ! Argument arrays
  !   Integration variables
      dimension x(100)

  ! Global variables
  !   Vegas
      common/bveg1/ncall,itmx,nprn,ndev,xl(100),xu(100),acc
      common/bveg2/it,ndo,si,swgt,schi,xi(50,100)
      common/rndm/iseed
      common/reslocal/resl(20),standdevl(20)
  !   Kinematics
      common/par/rm3,rm4,rm5,rm6,rm7,rm8,s
      common/limfac/fac
      common/EW/a_em,s2w
      common/final/ifinal,ipmax
      common/top/rmt,gamt
      common/W/rmW,gamW
      common/Z/rmZ,gamZ
      common/H/rmH,gamH      
      common/stat/npoints
      common/symint/ixmax,jxmax
      common/coll/ecm_coll
      common/cuts/ytcut,yttcut
  !   Narrow Width Approximation (NWA)
      common/NWA/gNWA
  !   Z' masses and LR couplings
      common/Zp/rmZp(5),gamZp(5)
      common/ZpLRcoup/gZpd(2,5),gZpu(2,5)
  !   Active gauge sectors
      common/igauge/iQCD,iEW,iBSM
  !   Common for decay ME
      common/polarqq/polqq(-1:1,-1:1)
      common/polargg/polgg(-1:1,-1:1)
  !   structure functions
      common/partdist/istructure
      common/alfastrong/rlambdaQCD4,nloops
      common/collider/icoll
  ! Polarised/Spatial cross sections
      integer nasy
      parameter (nasy=9)
      integer nspat
      parameter (nspat=6) !nasy-3
      common/polarised/polcross(20,-1:1,-1:1),polerror(20,-1:1,-1:1)
      common/spatial/spatcross(nspat,20,-1:1),spaterror(nspat,20,-1:1)
  !   Switch for all distributions
      common/distros/idist
  !   Distributions in pTs of particles
      common/ext_pT/pTmax(8),pTmin(8),pTw(8)
      common/dist_pT/xpT(8,500),fxpT(8,500,20),fxpTtot(8,500)
      common/inp_pT/m_pT(8)
      common/div_pT/ndiv_pT(8)
  !   Distributions in etas of external particles
      common/ext_eta/etamax(8),etamin(8),etaw(8)
      common/dist_eta/xeta(8,500),fxeta(8,500,20),fxetatot(8,500)
      common/inp_eta/m_eta(8)
      common/div_eta/ndiv_eta(8)
  !   Distributions in phis of external particles
      common/ext_phi/phimax(8),phimin(8),phiw(8)
      common/dist_phi/xphi(8,500),fxphi(8,500,20),fxphitot(8,500)
      common/inp_phi/m_phi(8)
      common/div_phi/ndiv_phi(8)
  !   Distribution in ETmiss
      common/ext_ETmiss/ETmissmax,ETmissmin,ETmissw
      common/dist_ETmiss/xETmiss(500),fxETmiss(500,20),fxETmisstot(500)
      common/inp_ETmiss/m_ETmiss
      common/div_ETmiss/ndiv_ETmiss
  !   Distribution in pT of the top
      common/ext_pT356/pT356max,pT356min,pT356w
      common/dist_pT356/xpT356(500),fxpT356(500,20),fxpT356tot(500)
      common/inp_pT356/m_pT356
      common/div_pT356/ndiv_pT356
  !   Distribution in eta of the top
      common/ext_eta356/eta356max,eta356min,eta356w
      common/dist_eta356/xeta356(500),fxeta356(500,20),fxeta356tot(500)
      common/inp_eta356/m_eta356
      common/div_eta356/ndiv_eta356
  !   Distribution in phi of the top
      common/ext_phi356/phi356max,phi356min,phi356w
      common/dist_phi356/xphi356(500),fxphi356(500,20),fxphi356tot(500)
      common/inp_phi356/m_phi356
      common/div_phi356/ndiv_phi356
  !   Distribution in pT of the anti-top
      common/ext_pT478/pT478max,pT478min,pT478w
      common/dist_pT478/xpT478(500),fxpT478(500,20),fxpT478tot(500)
      common/inp_pT478/m_pT478
      common/div_pT478/ndiv_pT478
  !   Distribution in eta of the anti-top
      common/ext_eta478/eta478max,eta478min,eta478w
      common/dist_eta478/xeta478(500),fxeta478(500,20),fxeta478tot(500)
      common/inp_eta478/m_eta478
      common/div_eta478/ndiv_eta478
  !   Distribution in phi of the anti-top
      common/ext_phi478/phi478max,phi478min,phi478w
      common/dist_phi478/xphi478(500),fxphi478(500,20),fxphi478tot(500)
      common/inp_phi478/m_phi478
      common/div_phi478/ndiv_phi478 
  !   Distribution in invarient mass of the top pair
      common/ext_rMtt/rMttmax,rMttmin,rMttw
      common/dist_rMtt/xrMtt(500),fxrMtt(500,20),fxrMtttot(500)
      common/inp_rMtt/m_rMtt
      common/div_rMtt/ndiv_rMtt
  !   Distribution in invarient mass of all visible decay products
      common/ext_rmvis/rmvismax,rmvismin,rmvisw
      common/dist_rmvis/xrmvis(500),fxrmvis(500,20),fxrmvistot(500)
      common/inp_rmvis/m_rmvis
      common/div_rmvis/ndiv_rmvis  
  !   Distribution in  boost of top pair centre of mass frame
      common/ext_beta/betamax,betamin,betaw
      common/dist_beta/xbeta(500),fxbeta(500,20),fxbetatot(500)
      common/inp_beta/m_beta
      common/div_beta/ndiv_beta
  !   Distribution in cos(theta_t)
      common/ext_cost/costmax,costmin,costw
      common/dist_cost/xcost(500),fxcost(500,20),fxcosttot(500)
      common/inp_cost/m_cost
      common/div_cost/ndiv_cost
  !   Distribution in top energy
      common/ext_Et/Etmax,Etmin,Etw
      common/dist_Et/xEt(500),fxEt(500,20),fxEttot(500)
      common/inp_Et/m_Et
      common/div_Et/ndiv_Et
  !   Distributions in transverse variables
      integer ntrans
      parameter (ntrans=10)
      common/ext_trans/transmax(ntrans),transmin(ntrans),transw(ntrans)
      common/dist_trans/xtrans(ntrans,500),fxtrans(ntrans,500,20)
     &                                           ,fxtranstot(ntrans,500)
      common/inp_trans/m_trans(ntrans)
      common/div_trans/ndiv_trans(ntrans)
      dimension trans(ntrans)
  !   Distribution in phi_l (lepton azimuthal angle)
      common/ext_fl/flmax,flmin,flw
      common/dist_fl/xfl(500),fxfl(500,20),fxfltot(500)
      common/inp_fl/m_fl
      common/div_fl/ndiv_fl
  !   Distribution in cos_phi_l
      common/ext_cosfl/cosflmax,cosflmin,cosflw
      common/dist_cosfl/xcosfl(500),fxcosfl(500,20),fxcosfltot(500)
      common/inp_cosfl/m_cosfl
      common/div_cosfl/ndiv_cosfl
  !   Distribution in delta phi
      common/ext_dphi/dphimax,dphimin,dphiw
      common/dist_dphi/xdphi(500),fxdphi(500,20),fxdphitot(500)
      common/inp_dphi/m_dphi
      common/div_dphi/ndiv_dphi
  !   Distribution in cost5
      common/ext_cost5/cost5max,cost5min,cost5w
      common/dist_cost5/xcost5(500),fxcost5(500,20),fxcost5tot(500)
      common/inp_cost5/m_cost5
      common/div_cost5/ndiv_cost5
  !   Distribution in cost7
      common/ext_cost7/cost7max,cost7min,cost7w
      common/dist_cost7/xcost7(500),fxcost7(500,20),fxcost7tot(500)
      common/inp_cost7/m_cost7
      common/div_cost7/ndiv_cost7
  !   Distribution in ct7ct5
      common/ext_ct7ct5/ct7ct5max,ct7ct5min,ct7ct5w
      common/dist_ct7ct5/xct7ct5(500),fxct7ct5(500,20),fxct7ct5tot(500)
      common/inp_ct7ct5/m_ct7ct5
      common/div_ct7ct5/ndiv_ct7ct5
  !   Distribution in sigp
      common/ext_sigp/sigpmax,sigpmin,sigpw
      common/dist_sigp/xsigp(1000),fxsigp(nasy,1000,20)
     &,fxsigptot(nasy,1000)
      common/inp_sigp/m_sigp
      common/div_sigp/ndiv_sigp
  !   Distribution in sigm
      common/ext_sigm/sigmmax,sigmmin,sigmw
      common/dist_sigm/xsigm(1000),fxsigm(nasy,1000,20)
     &,fxsigmtot(nasy,1000)
      common/inp_sigm/m_sigm
      common/div_sigm/ndiv_sigm
  !   Distributions in asymmetries
      common/inp_asym/m_asy(nasy)  ! nasy

  ! Local arrays    
  !   phase space vectors.
      dimension q356(4),q478(4),p356(4),p478(4)
      dimension q56(4),q78(4),p56(4),p78(4)
      dimension q5(4),q7(4)
      dimension q(4,8),qcol(4,8)
      dimension p1(0:3),p2(0:3),
     &          p3(0:3),p4(0:3),p5(0:3),p6(0:3),p7(0:3),p8(0:3)
      dimension pT2(8),pT(8),rps(8),rpl(8),arg(8),eta(8),phi(8)
      dimension pTvis(2),pTmiss(2)
  ! Lepton azimuthal angle coordinate system
      dimension xp(3),yp(3),zp(3)
  !  polar M*Ms for asymmetries
    ! situation one: q-qbar
      dimension respolgg1(-1:1,-1:1),respolqq1(-1:1,-1:1)      
      dimension respoldd1(-1:1,-1:1),respoluu1(-1:1,-1:1)   
      dimension pfx1(-1:1,-1:1)
    ! situation two: qbar-q
      dimension respolgg2(-1:1,-1:1),respolqq2(-1:1,-1:1)      
      dimension respoldd2(-1:1,-1:1),respoluu2(-1:1,-1:1)
      dimension pfx2(-1:1,-1:1)
    ! weight
      dimension weight(20,-1:1,-1:1)
  !   PDFs
      dimension fx1(13),fx2(13)
      dimension x1x2(2,2)

  ! Local constants
  !   pi
      parameter (pi=3.14159265358979323846d0)
  !   Quark masses
      data rmu/0.00d0/,
     &     rmd/0.00d0/,
     &     rms/0.00d0/,
     &     rmc/0.00d0/,
     &     rmb/4.25d0/
  !   Internal random number seed
      data jseed/987654321/
! ----------------------------------------------------------------------
! Initial parton distribution
  !   Maximum centre of mass energy
      Ecm_max=Ecm_coll 
  !   Centre of mass energy
      Ecm=x(2+12*ifinal)*(Ecm_max-rm3-rm4-rm5-rm6-rm7-rm8)
     &                        +rm3+rm4+rm5+rm6+rm7+rm8
      shat=Ecm*Ecm
      tau=shat/s
  !   x1 and x2 of the partons      
      xx1=x(3+12*ifinal)*(1.d0-tau)+tau
      xx2=tau/xx1
      x1x2(1,1)=xx1
      x1x2(1,2)=xx2
      x1x2(2,1)=xx2
      x1x2(2,2)=xx1
  ! Loop over x1 and x2
      fxn=0.d0
      do ix=1,ixmax
      ffxn=0.d0 
      x1=x1x2(ix,1)
      x2=x1x2(ix,2)
  ! Loop over costheta_cm
      do jx=1,jxmax
      fffxn=0.d0
  ! Structure functions
  !   Scale for the PDFs
      QQ=2.d0*rmt
  !   construct hadronic structure functions.
      if(istructure.le.4)then
        q2=QQ*QQ
        if((x1.le.1.d-6).or.(x1.ge.1.d0))then
          fffxn=0.d0
          return
        end if
        if((x2.le.1.d-6).or.(x2.ge.1.d0))then
          fffxn=0.d0
          return
        end if
        if((QQ.le.1.3d0).or.(QQ.ge.1.d4))then
          fffxn=0.d0
          return
        end if
  !   (Note that for cteq PDFs we multiply by x1 below and then divide by 
  !   it later. This is for compatibility with MRS, which return xf(x).)
        u1=x1*ctq6pdf(1,x1,QQ)
        d1=x1*ctq6pdf(2,x1,QQ)
        usea1=x1*ctq6pdf(-1,x1,QQ)
        dsea1=x1*ctq6pdf(-2,x1,QQ)
        str1=x1*ctq6pdf(3,x1,QQ)
        chm1=x1*ctq6pdf(4,x1,QQ)
        btm1=x1*ctq6pdf(5,x1,QQ)
        g1=x1*ctq6pdf(0,x1,QQ)
        u2=x2*ctq6pdf(1,x2,QQ)
        d2=x2*ctq6pdf(2,x2,QQ)
        usea2=x2*ctq6pdf(-1,x2,QQ)
        dsea2=x2*ctq6pdf(-2,x2,QQ)
        str2=x2*ctq6pdf(3,x2,QQ)
        chm2=x2*ctq6pdf(4,x2,QQ)
        btm2=x2*ctq6pdf(5,x2,QQ)
        g2=x2*ctq6pdf(0,x2,QQ)
      else if(istructure.eq.5)then
        imode=1
        if((x1.le.1.d-5).or.(x1.ge.1.d0))then
          fffxn=0.d0
          return
        end if
        if((x2.le.1.d-5).or.(x2.ge.1.d0))then
          fffxn=0.d0
          return
        end if
        if((QQ**2.le.1.25d0).or.(QQ**2.ge.1.d7))then
          fffxn=0.d0
          return
        end if
        call mrs99(x1,QQ,imode,u1,d1,usea1,dsea1,str1,chm1,btm1,g1)
        call mrs99(x2,QQ,imode,u2,d2,usea2,dsea2,str2,chm2,btm2,g2)
      else if(istructure.eq.6)then
        imode=2
        if((x1.le.1.d-5).or.(x1.ge.1.d0))then
          fffxn=0.d0
          return
        end if
        if((x2.le.1.d-5).or.(x2.ge.1.d0))then
          fffxn=0.d0
          return
        end if
        if((QQ**2.le.1.25d0).or.(QQ**2.ge.1.d7))then
          fffxn=0.d0
          return
        end if
        call mrs99(x1,QQ,imode,u1,d1,usea1,dsea1,str1,chm1,btm1,g1)
        call mrs99(x2,QQ,imode,u2,d2,usea2,dsea2,str2,chm2,btm2,g2)
      else if(istructure.eq.7)then
        imode=3
        if((x1.le.1.d-5).or.(x1.ge.1.d0))then
          fffxn=0.d0
          return
        end if
        if((x2.le.1.d-5).or.(x2.ge.1.d0))then
          fffxn=0.d0
          return
        end if
        if((QQ**2.le.1.25d0).or.(QQ**2.ge.1.d7))then
          fffxn=0.d0
          return
        end if
        call mrs99(x1,QQ,imode,u1,d1,usea1,dsea1,str1,chm1,btm1,g1)
        call mrs99(x2,QQ,imode,u2,d2,usea2,dsea2,str2,chm2,btm2,g2)
      else if(istructure.eq.8)then
        imode=4
        if((x1.le.1.d-5).or.(x1.ge.1.d0))then
          fffxn=0.d0
          return
        end if
        if((x2.le.1.d-5).or.(x2.ge.1.d0))then
          fffxn=0.d0
          return
        end if
        if((QQ**2.le.1.25d0).or.(QQ**2.ge.1.d7))then
          fffxn=0.d0
          return
        end if
        call mrs99(x1,QQ,imode,u1,d1,usea1,dsea1,str1,chm1,btm1,g1)
        call mrs99(x2,QQ,imode,u2,d2,usea2,dsea2,str2,chm2,btm2,g2)
      else if(istructure.eq.9)then
        imode=5
        if((x1.le.1.d-5).or.(x1.ge.1.d0))then
          fffxn=0.d0
          return
        end if
        if((x2.le.1.d-5).or.(x2.ge.1.d0))then
          fffxn=0.d0
          return
        end if
        if((QQ**2.le.1.25d0).or.(QQ**2.ge.1.d7))then
          fffxn=0.d0
          return
        end if
        call mrs99(x1,QQ,imode,u1,d1,usea1,dsea1,str1,chm1,btm1,g1)
        call mrs99(x2,QQ,imode,u2,d2,usea2,dsea2,str2,chm2,btm2,g2)
      end if

  !   Parton distribution functions (PDFs)
  !   (Note that MRS return valence and sea contributions automatically.)
      fx1(1)=d1+dsea1
      fx1(2)=u1+usea1
      fx1(3)=str1
      fx1(4)=chm1
      fx1(5)=btm1
      fx1(6)=0.d0
      fx1(7)=dsea1
      fx1(8)=usea1
      fx1(9)=fx1(3)
      fx1(10)=fx1(4)
      fx1(11)=fx1(5)
      fx1(12)=fx1(6)
      fx1(13)=g1
      do i=1,13
        fx1(i)=fx1(i)/x1
      end do
      fx2(1)=d2*(1-icoll)+dsea2
      fx2(2)=u2*(1-icoll)+usea2
      fx2(3)=str2
      fx2(4)=chm2
      fx2(5)=btm2
      fx2(6)=0.d0
      fx2(7)=d2*icoll+dsea2
      fx2(8)=u2*icoll+usea2
      fx2(9)=fx2(3)
      fx2(10)=fx2(4)
      fx2(11)=fx2(5)
      fx2(12)=fx2(6)
      fx2(13)=g2
      do i=1,13
        fx2(i)=fx2(i)/x2
      end do
! ----------------------------------------------------------------------
! Kinematics

  ! Incoming momenta (all massless)
      pcm=Ecm/2.d0
      q(4,1)=pcm
      q(3,1)=pcm
      q(2,1)=0.d0
      q(1,1)=0.d0
      q(4,2)=pcm
      q(3,2)=-pcm
      q(2,2)=0.d0
      q(1,2)=0.d0

  !   Outgoing momenta for 2 body final state.  
      if(ifinal.eq.0)then
        phit=2.d0*pi*ran(jseed)
        if(jx.eq.1)then
          ct=x(1)
        else if(jx.eq.2)then
          ct=-x(1)
        else
          write(*,*)'Invalid jx.'
        end if
        st=sqrt(1.d0-ct*ct)
        qcm2=((Ecm*Ecm-rm3*rm3-rm4*rm4)**2-(2.d0*rm3*rm4)**2)/
     &    (4.d0*Ecm*Ecm)
        if (qcm2.lt.0.d0) then
          fffxn=0.d0
          return
        else
          qcm=sqrt(qcm2)
        endif
        q(4,3)=sqrt(qcm2+rm3*rm3)
        q(3,3)=qcm*ct
        q(2,3)=qcm*st*cos(phit)
        q(1,3)=qcm*st*sin(phit)
        q(4,4)=sqrt(qcm2+rm4*rm4)
        q(3,4)=-qcm*ct
        q(2,4)=-qcm*st*cos(phit)
        q(1,4)=-qcm*st*sin(phit)
        do i=1,4
          q(i,5)=0.d0
          q(i,6)=0.d0
          q(i,7)=0.d0
          q(i,8)=0.d0
        end do

  ! Outgoing momenta for 6 body final state
      else if(ifinal.eq.1)then
        phit=2.d0*pi*ran(jseed)
        rm356min=rm3+rm5+rm6
        rm356max=Ecm-rm4-rm7-rm8
        XX356min=datan(((rm356min)**2-rmt**2)/rmt/gamt)
        XX356max=datan(((rm356max)**2-rmt**2)/rmt/gamt)
        xx=x(13)*(XX356max-XX356min)+XX356min          
        rl356=dtan(xx)*rmt*gamt                        
        rm356_2=(rmt**2+rl356)                         
        if(rm356_2.lt.0.d0)then
          fffxn=0.d0
          return
        else
          rm356=sqrt(rm356_2)
        endif
        rm478min=rm4+rm7+rm8
        rm478max=Ecm-rm356
        XX478min=datan(((rm478min)**2-rmt**2)/rmt/gamt)
        XX478max=datan(((rm478max)**2-rmt**2)/rmt/gamt)
        xx=x(12)*(XX478max-XX478min)+XX478min
        rl478=dtan(xx)*rmt*gamt
        rm478_2=(rmt**2+rl478)
        if(rm478_2.lt.0.d0)then
          fffxn=0.d0
          return
        else
          rm478=sqrt(rm478_2)
        endif
        rm56min=rm5+rm6
        rm56max=rm356-rm3
        XX56min=datan(((rm56min)**2-rmW**2)/rmW/gamW)
        XX56max=datan(((rm56max)**2-rmW**2)/rmW/gamW)
        xx=x(11)*(XX56max-XX56min)+XX56min
        rl56=dtan(xx)*rmW*gamW
        rm56_2=(rmW**2+rl56)
        if(rm56_2.lt.0.d0)then
          fffxn=0.d0
          return
        else
          rm56=sqrt(rm56_2)
        endif
        rm78min=rm7+rm8
        rm78max=rm478-rm4
        XX78min=datan(((rm78min)**2-rmW**2)/rmW/gamW)
        XX78max=datan(((rm78max)**2-rmW**2)/rmW/gamW)
        xx=x(10)*(XX78max-XX78min)+XX78min
        rl78=dtan(xx)*rmW*gamW
        rm78_2=(rmW**2+rl78)
        if(rm78_2.lt.0.d0)then
          fffxn=0.d0
          return
        else
          rm78=sqrt(rm78_2)
        endif
        if(jx.eq.1)then
          ct=x(9)
        else if(jx.eq.2)then
          ct=-x(9)
        else
          write(*,*)'Invalid jx.'
        end if
        st=sqrt(abs(1.d0-ct*ct))
        ct56=x(8)
        st56=sqrt(1.d0-ct56*ct56)
        ct78=x(7)
        st78=sqrt(1.d0-ct78*ct78)
        ct5=x(6)
        st5=sqrt(1.d0-ct5*ct5)
        ct7=x(5)
        st7=sqrt(1.d0-ct7*ct7)
        cf56=cos(x(4))
        sf56=sin(x(4))
        cf78=cos(x(3))
        sf78=sin(x(3))
        cf5=cos(x(2))
        sf5=sin(x(2))
        cf7=cos(x(1))
        sf7=sin(x(1))
        rq2=((Ecm*Ecm-rm356*rm356-rm478*rm478)**2
     &     -(2.d0*rm356*rm478)**2)/
     &      (4.d0*Ecm*Ecm)
        if(rq2.lt.0.d0)then
          fffxn=0.d0
          return
        else
          rq=sqrt(rq2)
        endif
        p356(3)=rq*ct
        p356(2)=rq*st*cos(phit)
        p356(1)=rq*st*sin(phit)
        p356(4)=sqrt(rq2+rm356*rm356)
        rq562=((rm356*rm356-rm3*rm3-rm56*rm56)**2-(2.d0*rm3*rm56)**2)/
     &      (4.d0*rm356*rm356)
        if(rq562.lt.0.d0)then
          fffxn=0.d0
          return
        else
          rq56=sqrt(rq562)
        endif
        q56(3)=rq56*st56*cf56
        q56(2)=rq56*st56*sf56
        q56(1)=rq56*ct56
        q56(4)=sqrt(rq562+rm56*rm56)
        pq56=0.d0
        do i=1,3
          pq56=pq56+p356(i)*q56(i)
        end do
        p56(4)=(p356(4)*q56(4)+pq56)/rm356
        q(4,3)=p356(4)-p56(4)
        do i=1,3
          p56(i)=q56(i)+p356(i)*(p56(4)+q56(4))/(p356(4)+rm356)
          q(i,3)=p356(i)-p56(i)
        end do
        do i=1,3
          p478(i)=-p356(i)
        end do
        p478(4)=sqrt(rq2+rm478*rm478)
        rq782=((rm478*rm478-rm4*rm4-rm78*rm78)**2-(2.d0*rm4*rm78)**2)/
     &      (4.d0*rm478*rm478)
        if(rq782.lt.0.d0)then
          fffxn=0.d0
          return
        else
          rq78=sqrt(rq782)
        endif
        q78(3)=rq78*st78*cf78
        q78(2)=rq78*st78*sf78
        q78(1)=rq78*ct78
        q78(4)=sqrt(rq782+rm78*rm78)
        pq78=0.d0
        do i=1,3
          pq78=pq78+p478(i)*q78(i)
        end do
        p78(4)=(p478(4)*q78(4)+pq78)/rm478
        q(4,4)=p478(4)-p78(4)
        do i=1,3
          p78(i)=q78(i)+p478(i)*(p78(4)+q78(4))/(p478(4)+rm478)
          q(i,4)=p478(i)-p78(i)
        end do
        rq52=((rm56*rm56-rm5*rm5-rm6*rm6)**2-(2.d0*rm5*rm6)**2)/
     &       (4.d0*rm56*rm56)
        if(rq52.lt.0.d0)then
          fffxn=0.d0
          return
        else
          rq5=sqrt(rq52)
        endif
        q5(3)=rq5*st5*cf5
        q5(2)=rq5*st5*sf5
        q5(1)=rq5*ct5
        q5(4)=sqrt(rq52+rm5*rm5)
        pq5=0.d0
        do i=1,3
          pq5=pq5+p56(i)*q5(i)
        end do
        q(4,5)=(p56(4)*q5(4)+pq5)/rm56
        q(4,6)=p56(4)-q(4,5)
        do i=1,3
          q(i,5)=q5(i)+p56(i)*(q(4,5)+q5(4))/(p56(4)+rm56)
          q(i,6)=p56(i)-q(i,5)
        end do
        rq72=((rm78*rm78-rm7*rm7-rm8*rm8)**2-(2.d0*rm7*rm8)**2)/
     &       (4.d0*rm78*rm78)
        if(rq72.lt.0.d0)then
          fffxn=0.d0
          return
        else
          rq7=sqrt(rq72)
        endif
        q7(3)=rq7*st7*cf7
        q7(2)=rq7*st7*sf7
        q7(1)=rq7*ct7
        q7(4)=sqrt(rq72+rm7*rm7)
        pq7=0.d0
        do i=1,3
          pq7=pq7+p78(i)*q7(i)
        end do
        q(4,7)=(p78(4)*q7(4)+pq7)/rm78
        q(4,8)=p78(4)-q(4,7)
        do i=1,3
          q(i,7)=q7(i)+p78(i)*(q(4,7)+q7(4))/(p78(4)+rm78)
          q(i,8)=p78(i)-q(i,7)
        end do
      end if

  ! Boost initial and final state momenta to the collider CM
      vcol=(x1-x2)/(x1+x2)
      gcol=(x1+x2)/2.d0/sqrt(x1*x2)
      imax=4+ifinal*4
      do i=1,imax
        qcol(4,i)=gcol*(q(4,i)+vcol*q(3,i))
        qcol(3,i)=gcol*(q(3,i)+vcol*q(4,i))
        qcol(2,i)=q(2,i)
        qcol(1,i)=q(1,i)
      end do
! ----------------------------------------------------------------------
! Additional kinematics
  ! These aren't required for the integration, but are used for
  ! distributions and cuts.
      
  ! Calculate transverse momenta (pT)
      do ip=1,ipmax
        pT2(ip)=qcol(1,ip)**2+qcol(2,ip)**2
        pT(ip)=sqrt(pT2(ip))
      end do
  ! Calculate pseudorapidity (eta)
      do ip=1,ipmax
        rps(ip)=(q(3,ip))/sqrt(q(1,ip)**2+q(2,ip)**2+q(3,ip)**2)
        if(rps(ip).lt.-1.d0)rps=-1.d0
        if(rps(ip).gt.+1.d0)rps=+1.d0
        rpl(ip)=dacos(rps(ip))
        arg(ip)=tan(rpl(ip)/2d0)
        if(arg(ip).le.0.d0)arg(ip)=1.d-9
        eta(ip)=-log(arg(ip))
      end do
  ! Calculate azimuthal angle (phi) in lab frame
      do ip=1,ipmax
        phi(ip)=atan2(qcol(2,ip),qcol(1,ip))
      end do
  ! calculate delta phi
      if(ifinal.eq.1)then
        dphi=abs(phi(5)-phi(7))
      end if
  ! calculate visible and missing transverse momentum
      if(ifinal.eq.1)then  
        ETvis2=0d0
        ETmiss2=0d0
        do i=1,2
          pTvis(i)=qcol(i,3)+qcol(i,4)+qcol(i,5)+qcol(i,7)
          pTmiss(i)=-pTvis(i)
          ETvis2=ETvis2+pTvis(i)**2
          ETmiss2=ETmiss2+pTmiss(i)**2
        end do
        ETvis=sqrt(ETvis2)
        ETmiss=sqrt(ETmiss2) 
      end if            
  ! calculate truth level top/antitop pT, eta and phi
      if(ifinal.eq.1)then
        pT356=sqrt((qcol(1,3)+qcol(1,5)+qcol(1,6))**2
     &           +(qcol(2,3)+qcol(2,5)+qcol(2,6))**2)

        pT478=sqrt((qcol(1,4)+qcol(1,7)+qcol(1,8))**2
     &           +(qcol(2,4)+qcol(2,7)+qcol(2,8))**2)    

        rps356=(q(3,3)+q(3,5)+q(3,6))
     &       /sqrt((q(1,3)+q(1,5)+q(1,6))**2
     &            +(q(2,3)+q(2,5)+q(2,6))**2
     &            +(q(3,3)+q(3,5)+q(3,6))**2)
        if(rps356.lt.-1.d0)rps=-1.d0
        if(rps356.gt.+1.d0)rps=+1.d0
        rpl356=dacos(rps356)
        arg356=tan(rpl356/2d0)
        if(arg356.le.0.d0)arg356=1.d-9
        eta356=-log(arg356)      

        rps478=(q(3,4)+q(3,7)+q(3,8))
     &       /sqrt((q(1,4)+q(1,7)+q(1,8))**2
     &            +(q(2,4)+q(2,7)+q(2,8))**2
     &            +(q(3,4)+q(3,7)+q(3,8))**2)
        if(rps478.lt.-1.d0)rps=-1.d0
        if(rps478.gt.+1.d0)rps=+1.d0
        rpl478=dacos(rps478)
        arg478=tan(rpl478/2d0)
        if(arg478.le.0.d0)arg478=1.d-9
        eta478=-log(arg478) 

        phi356=atan2(qcol(2,3)+qcol(2,5)+qcol(2,6)
     &              ,qcol(1,3)+qcol(1,5)+qcol(1,6))
        phi478=atan2(qcol(2,4)+qcol(2,7)+qcol(2,8)
     &              ,qcol(1,4)+qcol(1,7)+qcol(1,8))
      else
        continue
      end if
  ! Calculate cos(theta_t)
      if(ifinal.eq.0)then
          cost=
     &     (qcol(1,3)*qcol(1,1)
     &     +qcol(2,3)*qcol(2,1)
     &     +qcol(3,3)*qcol(3,1))
     &/sqrt(qcol(1,3)*qcol(1,3)
     &     +qcol(2,3)*qcol(2,3)
     &     +qcol(3,3)*qcol(3,3))
     &/sqrt(qcol(1,1)*qcol(1,1)
     &     +qcol(2,1)*qcol(2,1)
     &     +qcol(3,1)*qcol(3,1))
        else if(ifinal.eq.1)then
          cost=
     &    ((qcol(1,3)+qcol(1,5)+qcol(1,6))*qcol(1,1)
     &    +(qcol(2,3)+qcol(2,5)+qcol(2,6))*qcol(2,1)
     &    +(qcol(3,3)+qcol(3,5)+qcol(3,6))*qcol(3,1))
     &/sqrt((qcol(1,3)+qcol(1,5)+qcol(1,6))
     &     *(qcol(1,3)+qcol(1,5)+qcol(1,6))
     &     +(qcol(2,3)+qcol(2,5)+qcol(2,6))
     &     *(qcol(2,3)+qcol(2,5)+qcol(2,6))
     &     +(qcol(3,3)+qcol(3,5)+qcol(3,6))
     &     *(qcol(3,3)+qcol(3,5)+qcol(3,6)))
     &/sqrt(qcol(1,1)*qcol(1,1)
     &     +qcol(2,1)*qcol(2,1)
     &     +qcol(3,1)*qcol(3,1))
      end if     
  ! calculate cos(theta^*_t)
      if(ifinal.eq.0)then
          costcm=(q(1,3)*q(1,1)
     &           +q(2,3)*q(2,1)  
     &           +q(3,3)*q(3,1))
     &      /sqrt(q(1,3)*q(1,3) 
     &           +q(2,3)*q(2,3)
     &           +q(3,3)*q(3,3))
     &      /sqrt(q(1,1)*q(1,1) 
     &           +q(2,1)*q(2,1)
     &           +q(3,1)*q(3,1))
      else if(ifinal.gt.0)then
        costcm=
     &    ((q(1,3)+q(1,5)+q(1,6))*q(1,1)
     &    +(q(2,3)+q(2,5)+q(2,6))*q(2,1)
     &    +(q(3,3)+q(3,5)+q(3,6))*q(3,1))
     &/sqrt((q(1,3)+q(1,5)+q(1,6))
     &     *(q(1,3)+q(1,5)+q(1,6))
     &     +(q(2,3)+q(2,5)+q(2,6))
     &     *(q(2,3)+q(2,5)+q(2,6))
     &     +(q(3,3)+q(3,5)+q(3,6))
     &     *(q(3,3)+q(3,5)+q(3,6)))
     &/sqrt(q(1,1)*q(1,1)
     &     +q(2,1)*q(2,1)
     &     +q(3,1)*q(3,1))
      end if      
  ! calculate the energy of the top
      if(ifinal.eq.0)then
        Et=qcol(4,3)
      else if(ifinal.eq.1)then
        Et=qcol(4,3)+qcol(4,5)+qcol(4,6)
      end if

  ! calculate boost of the tt system
      ytt = 0.5d0*log(x1/x2)

  ! calculate rMtt
      if(ifinal.eq.0)then
        rMtt2=(qcol(4,3)+qcol(4,4))**2
        do i=1,3
          rMtt2=rMtt2-(qcol(i,3)+qcol(i,4))**2
        end do
      else if(ifinal.eq.1)then
        rMtt2=(qcol(4,3)+qcol(4,4)
     &         +qcol(4,5)+qcol(4,6)
     &         +qcol(4,7)+qcol(4,8))**2
        do i=1,3
          rMtt2=rMtt2-(qcol(i,3)+qcol(i,4)
     &                  +qcol(i,5)+qcol(i,6)
     &                  +qcol(i,7)+qcol(i,8))**2
        end do
      end if        
      rMtt=sqrt(abs(rMtt2))
  ! calculate invariant mass of visible decay products
      if(m_trans(1).eq.1)then
        rMvis2=(qcol(4,3)+qcol(4,4)
     &       +qcol(4,5)+qcol(4,7))**2
        do i=1,3
          rMvis2=rMvis2-(qcol(i,3)+qcol(i,4)
     &                +qcol(i,5)+qcol(i,7))**2
        end do      
        trans(1)=sqrt(abs(rMvis2))
      end if
  ! calculate transverse energy energies of visible particles
      if(ifinal.eq.1)then
        ET3=sqrt(rm3**2+pT2(3))
        ET4=sqrt(rm4**2+pT2(4))
        ET5=sqrt(rm5**2+pT2(5))
        ET7=sqrt(rm6**2+pT2(7))
      end if
  ! calculate HT
      if(m_trans(2).eq.1)then
        trans(2)=ET3+ET4+ET5+ET7+ETmiss
      end if

  ! calculate *full* transverse mass 1
      if(m_trans(3).eq.1)then
        rM_T12=(ET3+ET4+ET5+ET7+ETmiss)**2
     &        +(pT(3)+pT(4)+pT(5)+pT(7)+ETmiss)**2
        trans(3)=sqrt(abs(rM_T12))
      end if
  ! calculate *full* transverse mass 2
      if(m_trans(4).eq.1)then
        rM_T22=(ET3+ET4+ET5+ET7+ETmiss)**2
        do i=1,2
          rM_T22=rM_T22-(pTvis(i)+pTmiss(i))**2
        end do
        trans(4)=sqrt(abs(rM_T22))
      end if
  ! calculate *full* transverse mass 3
      if(m_trans(5).eq.1)then
        rM_T32=(ETvis+ETmiss)**2
        do i=1,2
          rM_T32=rM_T32-(pTvis(i)+pTmiss(i))**2
        end do
        trans(5)=sqrt(abs(rM_T32))    
      end if
  ! calculate lepton transverse mass
      if(m_trans(6).eq.1)then
        ET5=sqrt(rm5**2+pT2(5))
        ET7=sqrt(rm7**2+pT2(7))
        rMlT2=(ET5+ET7)**2
        do i=1,2
          rMlT2=rMlT2-(qcol(i,5)+qcol(i,7))**2
        end do
        trans(6)=sqrt(abs(rMlT2))
      end if
  ! calculate *full* contranverse mass 1
      if(m_trans(7).eq.1)then
        rM_CT12=(ET3+ET4+ET5+ET7+ETmiss)**2
     &        +(pT(3)+pT(4)+pT(5)+pT(7)-ETmiss)**2
        trans(7)=sqrt(abs(rM_CT12))
      end if
  ! calculate *full* contranverse mass 2
      if(m_trans(8).eq.1)then
        rM_CT22=(ET3+ET4+ET5+ET7+ETmiss)**2
        do i=1,2
          rM_CT22=rM_CT22-(pTvis(i)-pTmiss(i))**2
        end do
        trans(8)=sqrt(abs(rM_CT22))
      end if
  ! calculate *full* contranverse mass 3
      if(m_trans(9).eq.1)then
        rM_CT32=(ETvis+ETmiss)**2
        do i=1,2
          rM_CT32=rM_CT32-(pTvis(i)-pTmiss(i))**2
        end do
        trans(9)=sqrt(abs(rM_CT32))      
      end if
  ! calculate lepton contransverse mass
      if(m_trans(10).eq.1)then
        ET5=sqrt(rm5**2+pT2(5))
        ET7=sqrt(rm7**2+pT2(7))
        rMlCT2=(ET5+ET7)**2
        do i=1,2
          rMlCT2=rMlCT2-(qcol(i,5)-qcol(i,7))**2
        end do
        trans(10)=sqrt(abs(rMlCT2))
      end if
  ! calculate top pseudorapidity
      if(ifinal.eq.1)then
        rps356=(q(3,3)+q(3,5)+q(3,6))
     &       /sqrt((q(1,3)+q(1,5)+q(1,6))**2
     &            +(q(2,3)+q(2,5)+q(2,6))**2
     &            +(q(3,3)+q(3,5)+q(3,6))**2)
        if(rps356.lt.-1.d0)rps=-1.d0
        if(rps356.gt.+1.d0)rps=+1.d0
        rpl356=dacos(rps356)
        arg356=tan(rpl356/2d0)
        if(arg356.le.0.d0)arg356=1.d-9
        eta356=-log(arg356)      

        rps478=(q(3,4)+q(3,7)+q(3,8))
     &       /sqrt((q(1,4)+q(1,7)+q(1,8))**2
     &            +(q(2,4)+q(2,7)+q(2,8))**2
     &            +(q(3,4)+q(3,7)+q(3,8))**2)
        if(rps478.lt.-1.d0)rps=-1.d0
        if(rps478.gt.+1.d0)rps=+1.d0
        rpl478=dacos(rps478)
        arg478=tan(rpl478/2d0)
        if(arg478.le.0.d0)arg478=1.d-9
        eta478=-log(arg478)   ! no cuts on pseudorapidity yet
      else
        continue
      end if
  ! Calculate rapdity (y) of top and antitop
      if(ifinal.eq.0)then
        yt= 0.5*log((qcol(4,3)+qcol(3,3))/(qcol(4,3)-qcol(3,3))) 
        ytb=0.5*log((qcol(4,4)+qcol(3,4))/(qcol(4,4)-qcol(3,4)))
      else if(ifinal.gt.0)then
        yt =0.5*log((qcol(4,3)+qcol(4,5)+qcol(4,6)
     &               +qcol(3,3)+qcol(3,5)+qcol(3,6))
     &              /(qcol(4,3)+qcol(4,5)+qcol(4,6)
     &               -qcol(3,3)-qcol(3,5)-qcol(3,6)))
        ytb=0.5*log((qcol(4,4)+qcol(4,7)+qcol(4,8)
     &               +qcol(3,4)+qcol(3,7)+qcol(3,8))
     &              /(qcol(4,4)+qcol(4,7)+qcol(4,8)
     &               -qcol(3,4)-qcol(3,7)-qcol(3,8)))
      end if
      del_y=abs(yt)-abs(ytb) ! this is ARFB from Ken's work
  !    del_y=yt-ytb ! this is A' from Bernreuther's paper
  ! calculate cos(theta_l+)
      if(ifinal.gt.0)then
          cost5=+(q(1,5)*q(1,1)
     &           +q(2,5)*q(2,1)  
     &           +q(3,5)*q(3,1))
     &      /sqrt(q(1,5)*q(1,5) 
     &           +q(2,5)*q(2,5)
     &           +q(3,5)*q(3,5))
     &      /sqrt(q(1,1)*q(1,1) 
     &           +q(2,1)*q(2,1)
     &           +q(3,1)*q(3,1))
      end if
  ! calculate cos(theta_l-)
      if(ifinal.gt.0)then
          cost7=+(q(1,7)*q(1,1)
     &           +q(2,7)*q(2,1)  
     &           +q(3,7)*q(3,1))
     &      /sqrt(q(1,7)*q(1,7) 
     &           +q(2,7)*q(2,7)
     &           +q(3,7)*q(3,7))
     &      /sqrt(q(1,1)*q(1,1) 
     &           +q(2,1)*q(2,1)
     &           +q(3,1)*q(3,1))
      end if

      if(ifinal.gt.0)then
        ct7ct5=cost7*cost5
      end if

  ! calculate costst
      costst=int(ytt/abs(ytt))*costcm
  !     write(*,*)'del_y',del_y,'; costst',costst
  ! Calculate cos(phi_l) (lepton azimuthal angle)
      if(ifinal.gt.0)then
        p5m=sqrt(q(1,5)*q(1,5)+q(2,5)*q(2,5)+q(3,5)*q(3,5))

        ! p(1)^ is z^
        do i=1,3
          zp(i)=q(i,1)/sqrt(q(1,1)*q(1,1)+q(2,1)*q(2,1)+q(3,1)*q(3,1))
        end do

        ! p(5)_T^ is x^
        do i=1,2
          xp(i)=p356(i)/sqrt(p356(1)*p356(1)+p356(2)*p356(2))
        end do
        xp(3)=0      

        ! y^ obtained using cross product
        yp(1) = zp(2) * xp(3) - zp(3) * xp(2)
        yp(2) = zp(3) * xp(1) - zp(1) * xp(3)
        yp(3) = zp(1) * xp(2) - zp(2) * xp(1)

        p5xp=0
        do i=1,3
          p5xp=p5xp+q(i,5)*xp(i)
        end do
        p5yp=0
        do i=1,3
          p5yp=p5yp+q(i,5)*yp(i)
        end do
        p5zp=0
        do i=1,3
          p5zp=p5zp+q(i,5)*zp(i)
        end do

        p5mp=sqrt(p5xp*p5xp+p5yp*p5yp+p5zp*p5zp)

        if(abs(p5m-p5mp).ge.1E-11)write(*,*)'Error in coord transform.'

        fl=atan2(p5yp,p5xp)

        if(fl.lt.0)fl=fl+2*pi

        cosfl=cos(fl)
      end if
! ----------------------------------------------------------------------
! Selections
  ! Cut on top pT
      if(ifinal.eq.0)then       
        if(abs(eta(3)).gt.ytcut)then
          fffxn=0.d0
          return
        end if
      else if(abs(eta356).gt.ytcut)then
        fffxn=0.d0
        return
      else
        continue
      end if !
!-----------------------------------------------------------------------    
! Matrix elements
  ! Assign 2to2 MadGraph momenta
      if(ifinal.eq.0)then
        
        do i=1,3
          p1(i)=q(i,1)
          p2(i)=q(i,2)
          p3(i)=q(i,3)
          p4(i)=q(i,4) 
          p5(i)=0.d0
          p6(i)=0.d0  
          p7(i)=0.d0
          p8(i)=0.d0  
        end do
        p1(0)=q(4,1)
        p2(0)=q(4,2)
        p3(0)=q(4,3)
        p4(0)=q(4,4) 
        p5(0)=0.d0
        p6(0)=0.d0
        p7(0)=0.d0
        p8(0)=0.d0

  ! Check 2to2 kinematics
    !         write(*,*) 'p1  =',p1
    !         write(*,*) 'p2  =',p2
    !         write(*,*) 'p3  =',p3
    !         write(*,*) 'p4  =',p4
    !         delta_E=p1(0)+p2(0)
    !      &         -p3(0)-p4(0)
    !         delta_x=p1(1)+p2(1)
    !      &         -p3(1)-p4(1)
    !         delta_y=p1(2)+p2(2)
    !      &         -p3(2)-p4(2)
    !         delta_z=p1(3)+p2(3)
    !      &         -p3(3)-p4(3)
    !         write(*,*) 'delta_E=',delta_E
    !         write(*,*) 'delta_x=',delta_x
    !         write(*,*) 'delta_y=',delta_y
    !         write(*,*) 'delta_z=',delta_z
    !         rmassa1=sqrt(abs(p1(0)**2-p1(1)**2-p1(2)**2-p1(3)**2))
    !         rmassa2=sqrt(abs(p2(0)**2-p2(1)**2-p2(2)**2-p2(3)**2))
    !         rmassa3=sqrt(abs(p3(0)**2-p3(1)**2-p3(2)**2-p3(3)**2))
    !         rmassa4=sqrt(abs(p4(0)**2-p4(1)**2-p4(2)**2-p4(3)**2))
    !         write(*,*) 'rm_1 =',rmassa1
    !         write(*,*) 'rm_2 =',rmassa2
    !         write(*,*) 'rm_3 =',rmassa3
    !         write(*,*) 'rm_4 =',rmassa4


      else if(ifinal.eq.1)then
  ! Assign 2to6 MadGraph momenta      
        do i=1,3
          p1(i)=q(i,1)
          p2(i)=q(i,2)
          p3(i)=q(i,3)
          p4(i)=q(i,4) 
          p5(i)=q(i,5) 
          p6(i)=q(i,6) 
          p7(i)=q(i,7) 
          p8(i)=q(i,8) 
        end do
        p1(0)=q(4,1)
        p2(0)=q(4,2)
        p3(0)=q(4,3)
        p4(0)=q(4,4) 
        p5(0)=q(4,5)
        p6(0)=q(4,6)
        p7(0)=q(4,7)
        p8(0)=q(4,8)

  ! Check 6-body kinematics
  !         write(*,*) 'p1  =',p1
  !         write(*,*) 'p2  =',p2
  !         write(*,*) 'p3  =',p3
  !         write(*,*) 'p4  =',p4
  !         write(*,*) 'p5  =',p5
  !         write(*,*) 'p6  =',p6
  !         write(*,*) 'p7  =',p7
  !         write(*,*) 'p8  =',p8
  !   ! check conservation of 4-momentum.
  !         delta_E=p1(0)+p2(0)
  !      &         -p3(0)-p4(0)
  !      &         -p5(0)-p6(0)
  !      &         -p7(0)-p8(0)
  !         delta_x=p1(1)+p2(1)
  !      &         -p3(1)-p4(1)
  !      &         -p5(1)-p6(1)
  !      &         -p7(1)-p8(1)
  !         delta_y=p1(2)+p2(2)
  !      &         -p3(2)-p4(2)
  !      &         -p5(2)-p6(2)
  !      &         -p7(2)-p8(2)
  !         delta_z=p1(3)+p2(3)
  !      &         -p3(3)-p4(3)
  !      &         -p5(3)-p6(3)
  !      &         -p7(3)-p8(3)
  !         write(*,*) 'delta_E=',delta_E
  !         write(*,*) 'delta_px=',delta_x
  !         write(*,*) 'delta_py=',delta_y
  !         write(*,*) 'delta_pz=',delta_z
  !   ! check invarient mass.
  !         rmassa1=sqrt(abs(p1(0)**2-p1(1)**2-p1(2)**2-p1(3)**2))
  !         rmassa2=sqrt(abs(p2(0)**2-p2(1)**2-p2(2)**2-p2(3)**2))
  !         rmassa3=sqrt(abs(p3(0)**2-p3(1)**2-p3(2)**2-p3(3)**2))
  !         rmassa4=sqrt(abs(p4(0)**2-p4(1)**2-p4(2)**2-p4(3)**2))
  !         rmassa5=sqrt(abs(p5(0)**2-p5(1)**2-p5(2)**2-p5(3)**2))
  !         rmassa6=sqrt(abs(p6(0)**2-p6(1)**2-p6(2)**2-p6(3)**2))
  !         rmassa7=sqrt(abs(p7(0)**2-p7(1)**2-p7(2)**2-p7(3)**2))
  !         rmassa8=sqrt(abs(p8(0)**2-p8(1)**2-p8(2)**2-p8(3)**2))
  !         write(*,*) 'rm_1 =',rmassa1
  !         write(*,*) 'rm_2 =',rmassa2
  !         write(*,*) 'rm_3 =',rmassa3
  !         write(*,*) 'rm_4 =',rmassa4
  !         write(*,*) 'rm_5 =',rmassa5
  !         write(*,*) 'rm_6 =',rmassa6
  !         write(*,*) 'rm_7 =',rmassa7
  !         write(*,*) 'rm_8 =',rmassa8
  !   ! check missing momentum
  !         pT682=(qcol(1,6)+qcol(1,8))**2+(qcol(2,6)+qcol(2,8))**2
  !         pT68=sqrt(pT682)
  !         write(*,*)'ETmiss :',ETmiss
  !         write(*,*)'pT(v+v):',pT68
      end if


  ! Square Matrix elements
  !   Calculate strong coupling
      a_s=alfas(QQ,rLambdaQCD4,nloops)
      gs2=4.d0*pi*a_s
      gs=sqrt(gs2)

  !   (Do not change the deliberate order of p6 and p7 in the EW code.)
  !   Initilize
      resqq1=0.d0
      resgg1=0.d0
      resuu1=0.d0
      resdd1=0.d0
      resqq2=0.d0
      resgg2=0.d0
      resuu2=0.d0
      resdd2=0.d0
      do ii=-1,1,1
        do jj=-1,1,1
          respolgg1(ii,jj)=0.d0
          respolqq1(ii,jj)=0.d0
          respoldd1(ii,jj)=0.d0
          respoluu1(ii,jj)=0.d0
          respolgg2(ii,jj)=0.d0
          respolqq2(ii,jj)=0.d0
          respoldd2(ii,jj)=0.d0
          respoluu2(ii,jj)=0.d0
          do kk=1,20
            weight(kk,ii,jj)=0.d0
          end do
        end do
      end do

  ! 2-body MEs      
  !   Add QCD Matrix Elements
      if(ifinal.eq.0)then
        if(iQCD.eq.0)then
          continue
        else if(iQCD.eq.1)then
          do lam3=-1,1,2
            do lam4=-1,1,2
            respolqq1(lam3,lam4)=sqqb_ttb(p1,p2,p3,p4,lam3,lam4)*gs**4
            respolgg1(lam3,lam4)=sgg_ttb(p1,p2,p3,p4,lam3,lam4)*gs**4
            respolqq2(lam3,lam4)=sqqb_ttb(p2,p1,p3,p4,lam3,lam4)*gs**4
            respolgg2(lam3,lam4)=sgg_ttb(p2,p1,p3,p4,lam3,lam4)*gs**4
            end do
          end do
        else
          write(*,*)'iQCD is not set correctly.'
          stop
        end if  
  !   Add EW Matrix Elements
        if((iEW.eq.1).or.(iBSM.eq.1))then
          do lam3=-1,1,2
            do lam4=-1,1,2
              respoldd1(lam3,lam4)=sqqb_ttb_EWp(1,gZpd,gZpu,rmZp,gamZp
     &                                           ,p1,p2,p3,p4,lam3,lam4)
              respoluu1(lam3,lam4)=sqqb_ttb_EWp(2,gZpu,gZpu,rmZp,gamZp
     &                                           ,p1,p2,p3,p4,lam3,lam4)
              respoldd2(lam3,lam4)=sqqb_ttb_EWp(1,gZpd,gZpu,rmZp,gamZp
     &                                           ,p2,p1,p3,p4,lam3,lam4)
              respoluu2(lam3,lam4)=sqqb_ttb_EWp(2,gZpu,gZpu,rmZp,gamZp
     &                                           ,p2,p1,p3,p4,lam3,lam4)
            end do
          end do
        else
          continue
        end if
      end if
  ! 6-body MEs
  !   Add QCD Matrix Elements
      if(ifinal.eq.1)then
        if(iQCD.eq.0)then
          continue
        else if(iQCD.eq.1)then
          resqq1=sqqb_bbbtatann( p1 ,p2 ,p3 ,p4 ,p5 ,p7 ,p6 ,p8 )
          resgg1= sgg_bbbtatann( p1 ,p2 ,p3 ,p4 ,p5 ,p7 ,p6 ,p8 )
          resqq2=sqqb_bbbtatann( p2 ,p1 ,p3 ,p4 ,p5 ,p7 ,p6 ,p8 )
          resgg2= sgg_bbbtatann( p2 ,p1 ,p3 ,p4 ,p5 ,p7 ,p6 ,p8 )
        else
          write(*,*)'iQCD is not set correctly.'
          stop
        end if
  !   Add EW Matrix Elements
        if((iEW.eq.1).or.(iBSM.eq.1))then          
          resdd1=sqqb_bbbtatann_EWp(1,gZpd,gZpu,rmZp,gamZp
     &                                  ,p1 ,p2 ,p3 ,p4 ,p5 ,p7 ,p6 ,p8)
          resuu1=sqqb_bbbtatann_EWp(2,gZpu,gZpu,rmZp,gamZp
     &                                  ,p1 ,p2 ,p3 ,p4 ,p5 ,p7 ,p6 ,p8)
          resdd2=sqqb_bbbtatann_EWp(1,gZpd,gZpu,rmZp,gamZp
     &                                  ,p2 ,p1 ,p3 ,p4 ,p5 ,p7 ,p6 ,p8)
          resuu2=sqqb_bbbtatann_EWp(2,gZpu,gZpu,rmZp,gamZp
     &                                  ,p2 ,p1 ,p3 ,p4 ,p5 ,p7 ,p6 ,p8)
        else
          continue
        end if
      end if
  ! if no gauge sectors are active, fffxn = 0
      if(ifinal.eq.1)then
        restot=resqq1+resgg1+resuu1+resdd1+resqq2+resgg2+resuu2+resdd2
        if((restot).eq.0.d0)then
          fffxn=0.d0
          return
        end if
      end if

  ! Multiple QCD M*M by g_s 
  ! (Madgraph gs is set to one due to scale dependence.)
      resqq1=resqq1*gs**4
      resgg1=resgg1*gs**4
      resqq2=resqq2*gs**4
      resgg2=resgg2*gs**4

  ! Sum over M*M for all initial partons.
  ! (Initial luminosity for total unpolarised cross section: pfxtot)
  ! sum over all polarised Matrix elements
      pfx1tot=0.d0
      pfx2tot=0.d0
      if(ifinal.eq.0) then
        do lam3=-1,1,2
          do lam4=-1,1,2
              pfx1(lam3,lam4)=respolgg1(lam3,lam4) *fx1(13)*fx2(13)/2.d0
     & +(respolqq1(lam3,lam4)+respoldd1(lam3,lam4))*fx1( 1)*fx2( 7)
     & +(respolqq1(lam3,lam4)+respoluu1(lam3,lam4))*fx1( 2)*fx2( 8)
     & +(respolqq1(lam3,lam4)+respoldd1(lam3,lam4))*fx1( 3)*fx2( 9)
     & +(respolqq1(lam3,lam4)+respoluu1(lam3,lam4))*fx1( 4)*fx2(10)
     & +(respolqq1(lam3,lam4)+respoldd1(lam3,lam4))*fx1( 5)*fx2(11)
              pfx2(lam3,lam4)=respolgg2(lam3,lam4) *fx1(13)*fx2(13)/2.d0
     & +(respolqq2(lam3,lam4)+respoldd2(lam3,lam4))*fx1( 7)*fx2( 1)
     & +(respolqq2(lam3,lam4)+respoluu2(lam3,lam4))*fx1( 8)*fx2( 2)
     & +(respolqq2(lam3,lam4)+respoldd2(lam3,lam4))*fx1( 9)*fx2( 3)
     & +(respolqq2(lam3,lam4)+respoluu2(lam3,lam4))*fx1(10)*fx2( 4)
     & +(respolqq2(lam3,lam4)+respoldd2(lam3,lam4))*fx1(11)*fx2( 5)
            if(ix.eq.1)then
              pfx1(lam3,lam4)=pfx1(lam3,lam4)/x1
              pfx2(lam3,lam4)=pfx2(lam3,lam4)/x1
            else if(ix.eq.2)then
              pfx1(lam3,lam4)=pfx1(lam3,lam4)/x2
              pfx2(lam3,lam4)=pfx2(lam3,lam4)/x2
            end if
            pfx1tot=pfx1tot
     &             +pfx1(lam3,lam4)
            pfx2tot=pfx2tot
     &             +pfx2(lam3,lam4)
          end do
        end do
      else if(ifinal.eq.1) then
        qqd1=fx1( 1)*fx2( 7)*(resqq1+resdd1)
     &      +fx1( 2)*fx2( 8)*(resqq1+resuu1)
     &      +fx1( 3)*fx2( 9)*(resqq1+resdd1)
     &      +fx1( 4)*fx2(10)*(resqq1+resuu1)
     &      +fx1( 5)*fx2(11)*(resqq1+resdd1)
        qqd2=fx1( 7)*fx2( 1)*(resqq2+resdd2)
     &      +fx1( 8)*fx2( 2)*(resqq2+resuu2)
     &      +fx1( 9)*fx2( 3)*(resqq2+resdd2)
     &      +fx1(10)*fx2( 4)*(resqq2+resuu2)
     &      +fx1(11)*fx2( 5)*(resqq2+resdd2)
        ggd1=fx1(13)*fx2(13)*resgg1/2.d0
        ggd2=fx1(13)*fx2(13)*resgg2/2.d0
        if(ix.eq.1)then
          pfx1tot=(qqd1+ggd1)/x1
          pfx2tot=(qqd2+ggd2)/x1
        else if(ix.eq.2)then
          pfx1tot=(qqd1+ggd1)/x2
          pfx2tot=(qqd2+ggd2)/x2
        end if
      end if
  !  check it's not null
      if(pfx1tot.eq.0.d0.and.pfx2tot.eq.0.d0)then
        fffxn=0.d0
        return
      end if
  ! for distributions,
      if(ifinal.eq.0)then 
        do lam3=-1,1,2
          do lam4=-1,1,2
            pfx1(lam3,lam4)=pfx1(lam3,lam4)/pfx1tot
            pfx2(lam3,lam4)=pfx2(lam3,lam4)/pfx2tot
          end do
        end do
      end if
! ----------------------------------------------------------------------
! Phase space volume
  ! Jacobians from dx1 dx2 -> dx(2) dx(3)
      pfx1tot=pfx1tot*(1.d0-tau)*2.d0*Ecm/s
     &      *(ecm_max-rm3-rm4-rm5-rm6-rm7-rm8)
      pfx2tot=pfx2tot*(1.d0-tau)*2.d0*Ecm/s
     &      *(ecm_max-rm3-rm4-rm5-rm6-rm7-rm8)
  ! fffxn is now M*M*PDFs
      fffxn1=pfx1tot
      fffxn2=pfx2tot
  ! Multiply by 2pi from phit integration and convert from GeV^-2 to pb
      fffxn1=fffxn1*fac
      fffxn2=fffxn2*fac
      if(ifinal.eq.0)then
  ! 2-body phase space factor     
        fffxn1=fffxn1*qcm/(2.d0*pcm)*2.d0**(4-3*(2))
        fffxn1=fffxn1/2.d0/Ecm/Ecm*(2.d0*pi)**(4-3*(2))
        fffxn2=fffxn2*qcm/(2.d0*pcm)*2.d0**(4-3*(2))
        fffxn2=fffxn2/2.d0/Ecm/Ecm*(2.d0*pi)**(4-3*(2))
      else if(ifinal.eq.1)then
  ! 6-body flux factor, pi's and phase space integral
        fffxn1=fffxn1*rq*rq56*rq78*rq5*rq7/Ecm*256.d0*2.d0**(4-3*(6))
     &     /(2.d0*rm356)
     &     /rmt/gamt
     &     *((rm356*rm356-rmt*rmt)**2+rmt**2*gamt**2)
        fffxn1=fffxn1*(XX356max-XX356min)
     &     /(2.d0*rm478)
     &     /rmt/gamt
     &     *((rm478*rm478-rmt*rmt)**2+rmt**2*gamt**2)
        fffxn1=fffxn1*(XX478max-XX478min)
     &     /(2.d0*rm56)
     &     /rmW/gamW
     &     *((rm56*rm56-rmW*rmW)**2+rmW**2*gamW**2)
        fffxn1=fffxn1*(XX56max-XX56min)
     &     /(2.d0*rm78)
     &     /rmW/gamW
     &     *((rm78*rm78-rmW*rmW)**2+rmW**2*gamW**2)
        fffxn1=fffxn1*(XX78max-XX78min)
  !   NWA
        fffxn1=fffxn1
     &     *gamt/gNWA
     &     *gamt/gNWA
  !   flux and pi factors.
        fffxn1=fffxn1/2.d0/Ecm/Ecm*(2.d0*pi)**(4-3*(6))

        fffxn2=fffxn2*rq*rq56*rq78*rq5*rq7/Ecm*256.d0*2.d0**(4-3*(6))
     &     /(2.d0*rm356)
     &     /rmt/gamt
     &     *((rm356*rm356-rmt*rmt)**2+rmt**2*gamt**2)
        fffxn2=fffxn2*(XX356max-XX356min)
     &     /(2.d0*rm478)
     &     /rmt/gamt
     &     *((rm478*rm478-rmt*rmt)**2+rmt**2*gamt**2)
        fffxn2=fffxn2*(XX478max-XX478min)
     &     /(2.d0*rm56)
     &     /rmW/gamW
     &     *((rm56*rm56-rmW*rmW)**2+rmW**2*gamW**2)
        fffxn2=fffxn2*(XX56max-XX56min)
     &     /(2.d0*rm78)
     &     /rmW/gamW
     &     *((rm78*rm78-rmW*rmW)**2+rmW**2*gamW**2)
        fffxn2=fffxn2*(XX78max-XX78min)
  !   NWA
        fffxn2=fffxn2
     &     *gamt/gNWA
     &     *gamt/gNWA
  !   flux and pi factors.
        fffxn2=fffxn2/2.d0/Ecm/Ecm*(2.d0*pi)**(4-3*(6))
      end if
      fffxn=fffxn1+fffxn2
! ----------------------------------------------------------------------
! Categorised cross sections / Asymmetries
   
  ! Polarised total cross sections
  !   Polarised cross section for each point is calculated. 
  !   (Note that above pfx was divided by fffxn.)
      if(ifinal.eq.0)then
        do iphel=-1,+1,2
          do jphel=-1,+1,2
            polcross(it,iphel,jphel)=polcross(it,iphel,jphel)
     &                              +fffxn
     &                              *wgt          
     &                              *(pfx1(iphel,jphel)
     &                               +pfx2(iphel,jphel))
            weight(it,iphel,jphel)=+fffxn
     &                             *wgt
     &                             *(pfx1(iphel,jphel)
     &                              +pfx2(iphel,jphel))
            polerror(it,iphel,jphel)=polerror(it,iphel,jphel)
     &                              +polcross(it,iphel,jphel)**2
          end do
        end do
      end if

  ! AFB    
      if(m_asy(4).eq.0)then
        continue
      else
        if(costcm.eq.0.d0)then
          continue
        else if(costcm.gt.0.d0)then
          spatcross(1,it,+1)=spatcross(1,it,+1)
     &                              +fffxn
     &                              *wgt
          spaterror(1,it,+1)=spaterror(1,it,+1)
     &                   +spatcross(1,it,+1)**2
        else if(costcm.lt.0.d0)then
          spatcross(1,it,-1)=spatcross(1,it,-1)
     &                              +fffxn
     &                              *wgt
          spaterror(1,it,-1)=spaterror(1,it,-1)
     &                   +spatcross(1,it,-1)**2
        end if
      end if

  ! AFBstar   
      if(m_asy(5).eq.0)then
        continue
      else
        if(costst.eq.0.d0)then
          continue
        else if(costst.gt.0.d0)then
          spatcross(2,it,+1)=spatcross(2,it,+1)
     &                              +fffxn
     &                              *wgt
          spaterror(2,it,+1)=spaterror(2,it,+1)
     &                   +spatcross(2,it,+1)**2
  !         write(*,*)'asy(5)=+1'
        else if(costst.lt.0.d0)then
          spatcross(2,it,-1)=spatcross(2,it,-1)
     &                              +fffxn
     &                              *wgt
          spaterror(2,it,-1)=spaterror(2,it,-1)
     &                   +spatcross(2,it,-1)**2
  !         write(*,*)'asy(5)=-1'
        end if
      end if

  ! AtRFB

      if(m_asy(6).eq.0)then
        continue
      else
        if(yt.eq.0.d0)then
          continue
        else if(yt.gt.0.d0)then
          spatcross(3,it,+1)=spatcross(3,it,+1)
     &                              +fffxn
     &                              *wgt
          spaterror(3,it,+1)=spaterror(3,it,+1)
     &                   +spatcross(3,it,+1)**2
        else if(yt.lt.0.d0)then
          spatcross(3,it,-1)=spatcross(3,it,-1)
     &                              +fffxn
     &                              *wgt
          spaterror(3,it,-1)=spaterror(3,it,-1)
     &                   +spatcross(3,it,-1)**2
        end if
      end if

  ! AttbRFB/A
      if(m_asy(7).eq.0)then
        continue
      else
        if(yt.ge.0.d0)then
          spatcross(4,it,+1)=spatcross(4,it,+1)
     &                              +fffxn
     &                              *wgt
          spaterror(4,it,+1)=spaterror(4,it,+1)
     &                   +spatcross(4,it,+1)**2
        end if
        if(ytb.ge.0.d0)then
          spatcross(4,it,-1)=spatcross(4,it,-1)
     &                              +fffxn
     &                              *wgt
          spaterror(4,it,-1)=spaterror(4,it,-1)
     &                   +spatcross(4,it,-1)**2
        end if
      end if

  ! ARFB/A'

      if((m_asy(8).eq.1).and.(abs(ytt).gt.yttcut))then
        if(del_y.eq.0.d0)then
          continue
        else if(del_y.gt.0.d0)then
          spatcross(5,it,+1)=spatcross(5,it,+1)
     &                              +fffxn
     &                              *wgt
          spaterror(5,it,+1)=spaterror(5,it,+1)
     &                   +spatcross(5,it,+1)**2
  !         write(*,*)'asy(8)=+1'
        else if(del_y.lt.0.d0)then
          spatcross(5,it,-1)=spatcross(5,it,-1)
     &                              +fffxn
     &                              *wgt
          spaterror(5,it,-1)=spaterror(5,it,-1)
     &                   +spatcross(5,it,-1)**2
  !         write(*,*)'asy(8)=-1'
        end if
      end if

  ! A_l
      if(m_asy(9).eq.0)then
        continue
      else
        if (ifinal.gt.0)then      
          if(cosfl.eq.0.d0)then
            continue
          else if(cosfl.gt.0.d0)then
            spatcross(6,it,+1)=spatcross(6,it,+1)
     &                                +fffxn
     &                                *wgt
            spaterror(6,it,+1)=spaterror(6,it,+1)
     &                     +spatcross(6,it,+1)**2
          else if(cosfl.lt.0.d0)then
            spatcross(6,it,-1)=spatcross(6,it,-1)
     &                                +fffxn
     &                                *wgt
            spaterror(6,it,-1)=spaterror(6,it,-1)
     &                     +spatcross(6,it,-1)**2
          end if
        end if
      end if
! ----------------------------------------------------------------------
! Binning
  ! scale by weight
      hist1=fffxn1*wgt
      hist2=fffxn2*wgt
      hist=hist1+hist2
      do ip=3,ipmax
  ! generate distribution in pT      
        if(m_pT(ip).eq.1)then      
          nbin=int((pT(ip)-pTmin(ip))/pTw(ip))+1
          if(nbin.ge.(ndiv_pT(ip)+1))then
            continue
          else if(nbin.lt.1)then
            continue
          else
            fxpT(ip,nbin,it)=fxpT(ip,nbin,it)+hist
          end if
        end if
  ! generate distribution in eta      
        if(m_eta(ip).eq.1)then         
          nbin=int((eta(ip)-etamin(ip))/etaw(ip))+1
          if(nbin.ge.(ndiv_eta(ip)+1))then
            continue
          else if(nbin.lt.1)then
            continue
          else
            fxeta(ip,nbin,it)=fxeta(ip,nbin,it)+hist
          end if
        end if
  ! generate distribution in phi            
        if(m_phi(ip).eq.1)then   
          nbin=int((phi(ip)-phimin(ip))/phiw(ip))+1
          if(nbin.ge.(ndiv_phi(ip)+1))then
            continue
          else if(nbin.lt.1)then
            continue
          else
            fxphi(ip,nbin,it)=fxphi(ip,nbin,it)+hist
          end if
        end if
      end do
  ! generate distribution in pT356. 
      if(m_pT356.eq.1)then  
        nbin=int((pT356-pT356min)/pT356w)+1
        if(nbin.ge.(ndiv_pT356+1))then
          continue
        else if(nbin.lt.1)then
          continue
        else
          fxpT356(nbin,it)=fxpT356(nbin,it)+hist
        end if
      end if      

      if(m_eta356.eq.1)then
  ! generate distribution in eta356. 
        nbin=int((eta356-eta356min)/eta356w)+1
        if(nbin.ge.(ndiv_eta356+1))then
          continue
        else if(nbin.lt.1)then
          continue
        else
          fxeta356(nbin,it)=fxeta356(nbin,it)+hist
        end if
      end if

      if(m_phi356.eq.1)then
  ! generate distribution in phi356. 
        nbin=int((phi356-phi356min)/phi356w)+1
        if(nbin.ge.(ndiv_phi356+1))then
          continue
        else if(nbin.lt.1)then
          continue
        else
          fxphi356(nbin,it)=fxphi356(nbin,it)+hist
        end if
      end if

        if(m_pT478.eq.1)then
  ! generate distribution in pT478. 
        nbin=int((pT478-pT478min)/pT478w)+1
        if(nbin.ge.(ndiv_pT478+1))then
          continue
        else if(nbin.lt.1)then
          continue
        else
          fxpT478(nbin,it)=fxpT478(nbin,it)+hist
        end if
      end if

      if(m_eta478.eq.1)then
  ! generate distribution in eta478. 
        nbin=int((eta478-eta478min)/eta478w)+1
        if(nbin.ge.(ndiv_eta478+1))then
          continue
        else if(nbin.lt.1)then
          continue
        else
          fxeta478(nbin,it)=fxeta478(nbin,it)+hist
        end if
      end if

      if(m_phi478.eq.1)then
  ! generate distribution in phi478. 
        nbin=int((phi478-phi478min)/phi478w)+1
        if(nbin.ge.(ndiv_phi478+1))then
          continue
        else if(nbin.lt.1)then
          continue
        else
          fxphi478(nbin,it)=fxphi478(nbin,it)+hist
        end if
      end if

      if(m_ETmiss.eq.1)then
  ! generate distribution in ETmiss. 
        nbin=int((ETmiss-ETmissmin)/ETmissw)+1
        if(nbin.ge.(ndiv_ETmiss+1))then
          continue
        else if(nbin.lt.1)then
          continue
        else
          fxETmiss(nbin,it)=fxETmiss(nbin,it)+hist
        end if
      end if

      if(m_rMtt.eq.1)then
  ! generate distribution in rMtt.
        nbin=int((rMtt-rMttmin)/rMttw)+1
        if(nbin.ge.(ndiv_rMtt+1))then
          continue
        else if(nbin.lt.1)then
          continue
        else
          fxrMtt(nbin,it)=fxrMtt(nbin,it)+hist
        end if
      end if

      if(m_beta.eq.1)then
  ! generate distribution in beta.
        beta=shat/4.d0/rmt**2-1.d0
        nbin=int((beta-betamin)/betaw)+1
        if(nbin.ge.(ndiv_beta+1))then
          continue
        else if(nbin.lt.1)then
          continue
        else
          fxbeta(nbin,it)=fxbeta(nbin,it)+hist
        end if
      end if  

      if(m_cost.eq.1)then
  ! generate distribution in cost.
        nbin=int((cost-costmin)/costw)+1
        if(nbin.ge.(ndiv_cost+1))then
          continue
        else if(nbin.lt.1)then
          continue
        else
          fxcost(nbin,it)=fxcost(nbin,it)+hist
        end if
      end if

      if(m_Et.eq.1)then   !enerate distribution in Et.
        nbin=int((Et-Etmin)/Etw)+1
        if(nbin.ge.(ndiv_Et+1))then
          continue
        else if(nbin.lt.1)then
          continue
        else
          fxEt(nbin,it)=fxEt(nbin,it)+hist
        end if
      end if


      do itrans=1,ntrans
        if(m_trans(itrans).eq.1)then
  ! generate distribution in trans.
          nbin=int((trans(itrans)-transmin(itrans))/transw(itrans))+1
          if(nbin.ge.(ndiv_trans(itrans)+1))then
            continue
          else if(nbin.lt.1)then
            continue
          else
            fxtrans(itrans,nbin,it)=fxtrans(itrans,nbin,it)+hist
          end if
        end if
      end do

      if(m_fl.eq.1)then
  ! generate distribution in fl.
        nbin=int((fl-flmin)/flw)+1
        if(nbin.ge.(ndiv_fl+1))then
          continue
        else if(nbin.lt.1)then
          continue
        else
          fxfl(nbin,it)=fxfl(nbin,it)+hist
        end if
      end if


      if(m_cosfl.eq.1)then
  ! generate distribution in cosfl.
        nbin=int((cosfl-cosflmin)/cosflw)+1
        if(nbin.ge.(ndiv_cosfl+1))then
          continue
        else if(nbin.lt.1)then
          continue
        else
          fxcosfl(nbin,it)=fxcosfl(nbin,it)+hist
        end if
      end if


      if(m_dphi.eq.1)then
  ! generate distribution in dphi.
        nbin=int((dphi-dphimin)/dphiw)+1
        if(nbin.ge.(ndiv_dphi+1))then
          continue
        else if(nbin.lt.1)then
          continue
        else
          fxdphi(nbin,it)=fxdphi(nbin,it)+hist
        end if
      end if

      if(m_cost5.eq.1)then
  ! generate distribution in cost5.
        nbin=int((cost5-cost5min)/cost5w)+1
        if(nbin.ge.(ndiv_cost5+1))then
          continue
        else if(nbin.lt.1)then
          continue
        else
          fxcost5(nbin,it)=fxcost5(nbin,it)+hist
        end if
      end if

      if(m_cost7.eq.1)then
  ! generate distribution in cost7.
        nbin=int((cost7-cost7min)/cost7w)+1
        if(nbin.ge.(ndiv_cost7+1))then
          continue
        else if(nbin.lt.1)then
          continue
        else
          fxcost7(nbin,it)=fxcost7(nbin,it)+hist
        end if
      end if

      if(m_ct7ct5.eq.1)then
        nbin=int((ct7ct5-ct7ct5min)/ct7ct5w)+1
        if(nbin.ge.(ndiv_ct7ct5+1))then
          continue
        else if(nbin.lt.1)then
          continue
        else
            fxct7ct5(nbin,it)=fxct7ct5(nbin,it)+hist
        end if
      end if

      if(m_asy(1).eq.1)then
        if(m_sigp.eq.1)then
  ! generate distribution in sigp for ALL.
          sigp=Ecm
          nbin=int((sigp-sigpmin)/sigpw)+1
          if(nbin.ge.(ndiv_sigp+1))then
            continue
          else if(nbin.lt.1)then
            continue
          else
            fxsigp(1,nbin,it)=fxsigp(1,nbin,it)+
     &    (weight(it,+1,+1)+weight(it,-1,-1))   !ction happens
          end if
        end if  
        if(m_sigm.eq.1)then
  ! generate distribution in sigm for ALL.
          sigm=Ecm
          nbin=int((sigm-sigmmin)/sigmw)+1
          if(nbin.ge.(ndiv_sigm+1))then
            continue
          else if(nbin.lt.1)then
            continue
          else
            fxsigm(1,nbin,it)=fxsigm(1,nbin,it)+
     &      (weight(it,+1,-1)+weight(it,-1,+1))
          end if
        end if
      end if

      if(m_asy(2).eq.1)then
        if(m_sigp.eq.1)then
  ! generate distribution in sigp for AL.
          sigp=Ecm
          nbin=int((sigp-sigpmin)/sigpw)+1
          if(nbin.ge.(ndiv_sigp+1))then
            continue
          else if(nbin.lt.1)then
            continue
          else
            fxsigp(2,nbin,it)=fxsigp(2,nbin,it)+
     &      (weight(it,-1,-1)+weight(it,-1,+1))
          end if
        end if  
        if(m_sigm.eq.1)then
  ! generate distribution in sigm for AL.
          sigm=Ecm
          nbin=int((sigm-sigmmin)/sigmw)+1
          if(nbin.ge.(ndiv_sigm+1))then
            continue
          else if(nbin.lt.1)then
            continue
          else
            fxsigm(2,nbin,it)=fxsigm(2,nbin,it)+
     &      (weight(it,+1,-1)+weight(it,+1,+1))
          end if
        end if
      end if

      if(m_asy(3).eq.1)then
        if(m_sigp.eq.1)then
  ! generate distribution in sigp for APV.
          sigp=Ecm
          nbin=int((sigp-sigpmin)/sigpw)+1
          if(nbin.ge.(ndiv_sigp+1))then
            continue
          else if(nbin.lt.1)then
            continue
          else
            fxsigp(3,nbin,it)=fxsigp(3,nbin,it)+
     &      (weight(it,-1,-1))
          end if
        end if  
        if(m_sigm.eq.1)then
  ! generate distribution in sigm for APV.
          sigm=Ecm
          nbin=int((sigm-sigmmin)/sigmw)+1
          if(nbin.ge.(ndiv_sigm+1))then
            continue
          else if(nbin.lt.1)then
            continue
          else
            fxsigm(3,nbin,it)=fxsigm(3,nbin,it)+
     &      (weight(it,+1,+1))
          end if
        end if 
      end if

      if(m_asy(4).eq.1)then
        if((m_sigp.eq.1).and.(costcm.gt.0.d0))then
  ! generate distribution in sigp for AFBcm.
          sigp=Ecm
          nbin=int((sigp-sigpmin)/sigpw)+1
          if(nbin.ge.(ndiv_sigp+1))then
            continue
          else if(nbin.lt.1)then
            continue
          else
            fxsigp(4,nbin,it)=fxsigp(4,nbin,it)+hist
          end if
        end if  
        if((m_sigm.eq.1).and.(costcm.lt.0.d0))then
  ! generate distribution in sigm for AFBcm.
          sigm=Ecm
          nbin=int((sigm-sigmmin)/sigmw)+1
          if(nbin.ge.(ndiv_sigm+1))then
            continue
          else if(nbin.lt.1)then
            continue
          else
            fxsigm(4,nbin,it)=fxsigm(4,nbin,it)+hist
          end if
        end if
      end if

      if(m_asy(5).eq.1)then
        if((m_sigp.eq.1).and.(costst.gt.0.d0))then
  ! generate distribution in sigp for AFBcm.
          sigp=Ecm
          nbin=int((sigp-sigpmin)/sigpw)+1
          if(nbin.ge.(ndiv_sigp+1))then
            continue
          else if(nbin.lt.1)then
            continue
          else
            fxsigp(5,nbin,it)=fxsigp(5,nbin,it)+hist
          end if
        end if  
        if((m_sigm.eq.1).and.(costst.lt.0.d0))then
  ! generate distribution in sigm for AFBcm.
          sigm=Ecm
          nbin=int((sigm-sigmmin)/sigmw)+1
          if(nbin.ge.(ndiv_sigm+1))then
            continue
          else if(nbin.lt.1)then
            continue
          else
            fxsigm(5,nbin,it)=fxsigm(5,nbin,it)+hist
          end if
        end if
      end if

      if(m_asy(6).eq.1)then
        if((m_sigp.eq.1).and.(yt.gt.0.d0))then
  ! generate distribution in sigp for AtFB.
          sigp=Ecm
          nbin=int((sigp-sigpmin)/sigpw)+1
          if(nbin.ge.(ndiv_sigp+1))then
            continue
          else if(nbin.lt.1)then
            continue
          else
            fxsigp(6,nbin,it)=fxsigp(6,nbin,it)+hist
          end if
        end if  
        if((m_sigm.eq.1).and.(yt.lt.0.d0))then
  ! generate distribution in sigm for AtFB.
          sigm=Ecm
          nbin=int((sigm-sigmmin)/sigmw)+1
          if(nbin.ge.(ndiv_sigm+1))then
            continue
          else if(nbin.lt.1)then
            continue
          else
            fxsigm(6,nbin,it)=fxsigm(6,nbin,it)+hist
          end if
        end if
      end if

      if(m_asy(7).eq.1)then
        if((m_sigp.eq.1).and.(yt.ge.0.d0))then
  ! generate distribution in sigp for A.
          sigp=Ecm
          nbin=int((sigp-sigpmin)/sigpw)+1
          if(nbin.ge.(ndiv_sigp+1))then
            continue
          else if(nbin.lt.1)then
            continue
          else
            fxsigp(7,nbin,it)=fxsigp(7,nbin,it)+hist
          end if
        end if  
        if((m_sigm.eq.1).and.(ytb.ge.0.d0))then
  ! generate distribution in sigm for A.
          sigm=Ecm
          nbin=int((sigm-sigmmin)/sigmw)+1
          if(nbin.ge.(ndiv_sigm+1))then
            continue
          else if(nbin.lt.1)then
            continue
          else
            fxsigm(7,nbin,it)=fxsigm(7,nbin,it)+hist
          end if
        end if
      end if

      if((m_asy(8).eq.1).and.(abs(ytt).gt.yttcut))then
        if((m_sigp.eq.1).and.(del_y.gt.0.d0))then
  ! generate distribution in sigp for ARFB.
          sigp=Ecm
          nbin=int((sigp-sigpmin)/sigpw)+1
          if(nbin.ge.(ndiv_sigp+1))then
            continue
          else if(nbin.lt.1)then
            continue
          else
            fxsigp(8,nbin,it)=fxsigp(8,nbin,it)+hist
          end if
        end if  
        if((m_sigm.eq.1).and.(del_y.lt.0.d0))then
  ! generate distribution in sigm for ARFB.
          sigm=Ecm
          nbin=int((sigm-sigmmin)/sigmw)+1
          if(nbin.ge.(ndiv_sigm+1))then
            continue
          else if(nbin.lt.1)then
            continue
          else
            fxsigm(8,nbin,it)=fxsigm(8,nbin,it)+hist
          end if
        end if
      end if


      if(m_asy(9).eq.1)then
        if((m_sigp.eq.1).and.(cosfl.gt.0.d0))then
  ! generate distribution in sigp for A_l.
          sigp=Ecm
          nbin=int((sigp-sigpmin)/sigpw)+1
          if(nbin.ge.(ndiv_sigp+1))then
            continue
          else if(nbin.lt.1)then
            continue
          else
            fxsigp(9,nbin,it)=fxsigp(9,nbin,it)+hist
          end if
        end if
        if((m_sigm.eq.1).and.(cosfl.lt.0.d0))then
  ! generate distribution in sigm for A_l.
          sigm=Ecm
          nbin=int((sigm-sigmmin)/sigmw)+1
          if(nbin.ge.(ndiv_sigm+1))then
            continue
          else if(nbin.lt.1)then
            continue
          else
            fxsigm(9,nbin,it)=fxsigm(9,nbin,it)+hist
          end if
        end if
      end if
! ----------------------------------------------------------------------
! End functions
  ! stats
      npoints=npoints+1
  ! end loop (cost)+(-cost)
      ffxn=ffxn+fffxn/float(jxmax) ! 2 x number of phase space points
      end do
      fxn=fxn+ffxn/float(ixmax) ! 2 x number of phase space points
  ! end loop x1 <-> x2 
      end do 
      return
      end
! ======================================================================