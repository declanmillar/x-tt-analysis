c ======================================================================
      function fxn(x,wgt)
! Authors: Declan Millar, Stefano Moretti 

! Returns the fully differential cross section for
!   pp -> tt,
!   pp -> tt -> bW^+bbarW^- -> bbbare^+nue^-nubarc 
! This is then passed to VEGAS in the main program.

! Matrix element and phase space integration function.
! Called each time a phase space point is generated by VEGAS.
! Calculates matrix element using HELAS subroutines, scales by phase 
! space volume factor and populates distributions for set of defined 
! observables accordingly.
! ----------------------------------------------------------------------
      implicit real*8 (a-h,o-z)
! Argument arrays
!   Integration variables
      dimension x(100)

! Global variables
!   Vegas
      common/bveg1/ncall,itmx,nprn,ndev,xl(100),xu(100),acc
      common/bveg2/it,ndo,si,swgt,schi,xi(50,100)
      common/rndm/iseed
      common/reslocal/resl(20),standdevl(20)
!   Kinematics
      common/par/rm3,rm4,rm5,rm6,rm7,rm8,s
      common/limfac/fac
      common/EW/a_em,s2w
      common/final/ifinal ! final state
      common/top/rmt,gamt
      common/W/rmW,gamW
      common/Z/rmZ,gamZ
      common/H/rmH,gamH      
      common/stat/npoints
      common/coll/ecm_coll
      common/cuts/ytcut,yttcut
!   Narrow Width Approximation (NWA)
      common/NWA/gNWA
!   Z' masses and LR couplings
      common/Zp/rmZp(5),gamZp(5)
      common/ZpLRcoup/gZpd(2,5),gZpu(2,5)
!   Active gauge sectors
      common/igauge/iQCD,iEW,iBSM
!   Common for decay ME
      common/polarqq/polqq(-1:1,-1:1)
      common/polargg/polgg(-1:1,-1:1)
!   structure functions
      COMMON/PARTDIST/ISTRUCTURE
      common/ALFASTRONG/rlambdaQCD4,nloops
      common/collider/icoll
!   Polarised cross sections
      common/polarised/polcross(20,-1:1,-1:1),polerror(20,-1:1,-1:1)
      common/spatial/asycross(5,20,-1:1),asyerror(5,20,-1:1) !nasy-3
!   Switch for all distributions
      common/distros/idist
!   Distributions in pTs of particles
      common/ext_pT/pTmax(8),pTmin(8),pTw(8)
      common/dist_pT/xpT(8,500),fxpT(8,500,20),fxpTtot(8,500)
      common/inp_pT/m_pT(8)
      common/div_pT/ndiv_pT(8)
!   Distributions in phis of external particles
      common/ext_phi/phimax(8),phimin(8),phiw(8)
      common/dist_phi/xphi(8,500),fxphi(8,500,20),fxphitot(8,500)
      common/inp_phi/m_phi(8)
      common/div_phi/ndiv_phi(8)
!   Distribution in pT of the top
      common/ext_pT356/pT356max,pT356min,pT356w
      common/dist_pT356/xpT356(500),fxpT356(500,20),fxpT356tot(500)
      common/inp_pT356/m_pT356
      common/div_pT356/ndiv_pT356
!   Distribution in pT of the anti-top
      common/ext_pT478/pT478max,pT478min,pT478w
      common/dist_pT478/xpT478(500),fxpT478(500,20),fxpT478tot(500)
      common/inp_pT478/m_pT478
      common/div_pT478/ndiv_pT478
!   Distribution in ETmiss
      common/ext_ETmiss/ETmissmax,ETmissmin,ETmissw
      common/dist_ETmiss/xETmiss(500),fxETmiss(500,20),fxETmisstot(500)
      common/inp_ETmiss/m_ETmiss
      common/div_ETmiss/ndiv_ETmiss
!   Distribution in eta of the top / bottom
      common/ext_eta3/eta3max,eta3min,eta3w
      common/dist_eta3/xeta3(500),fxeta3(500,20),fxeta3tot(500)
      common/inp_eta3/m_eta3
      common/div_eta3/ndiv_eta3
!   Distribution in eta of the anti-top / bottom
      common/ext_eta4/eta4max,eta4min,eta4w
      common/dist_eta4/xeta4(500),fxeta4(500,20),fxeta4tot(500)
      common/inp_eta4/m_eta4
      common/div_eta4/ndiv_eta4
!   Distribution in eta of the anti-leetaon
      common/ext_eta5/eta5max,eta5min,eta5w
      common/dist_eta5/xeta5(500),fxeta5(500,20),fxeta5tot(500)
      common/inp_eta5/m_eta5
      common/div_eta5/ndiv_eta5
!   Distribution in eta of the neutrino
      common/ext_eta6/eta6max,eta6min,eta6w
      common/dist_eta6/xeta6(500),fxeta6(500,20),fxeta6tot(500)
      common/inp_eta6/m_eta6
      common/div_eta6/ndiv_eta6
!   Distribution in eta of the leetaon
      common/ext_eta7/eta7max,eta7min,eta7w
      common/dist_eta7/xeta7(500),fxeta7(500,20),fxeta7tot(500)
      common/inp_eta7/m_eta7
      common/div_eta7/ndiv_eta7
!   Distribution in eta of the anti-neutrino
      common/ext_eta8/eta8max,eta8min,eta8w
      common/dist_eta8/xeta8(500),fxeta8(500,20),fxeta8tot(500)
      common/inp_eta8/m_eta8
      common/div_eta8/ndiv_eta8
!   Distribution in eta of the top
      common/ext_eta356/eta356max,eta356min,eta356w
      common/dist_eta356/xeta356(500),fxeta356(500,20),fxeta356tot(500)
      common/inp_eta356/m_eta356
      common/div_eta356/ndiv_eta356
!   Distribution in eta of the anti-top
      common/ext_eta478/eta478max,eta478min,eta478w
      common/dist_eta478/xeta478(500),fxeta478(500,20),fxeta478tot(500)
      common/inp_eta478/m_eta478
      common/div_eta478/ndiv_eta478
!   Distribution in invarient mass of the top pair
      common/ext_rmass/rmassmax,rmassmin,rmassw
      common/dist_rmass/xrmass(500),fxrmass(500,20),fxrmasstot(500)
      common/inp_rmass/m_rmass
      common/div_rmass/ndiv_rmass
!   Distribution in invarient mass of all visible decay products
      common/ext_rmvis/rmvismax,rmvismin,rmvisw
      common/dist_rmvis/xrmvis(500),fxrmvis(500,20),fxrmvistot(500)
      common/inp_rmvis/m_rmvis
      common/div_rmvis/ndiv_rmvis  
!   Distribution in  boost of top pair centre of mass frame
      common/ext_beta/betamax,betamin,betaw
      common/dist_beta/xbeta(500),fxbeta(500,20),fxbetatot(500)
      common/inp_beta/m_beta
      common/div_beta/ndiv_beta
!   Distribution in cos(theta_t)
      common/ext_cost/costmax,costmin,costw
      common/dist_cost/xcost(500),fxcost(500,20),fxcosttot(500)
      common/inp_cost/m_cost
      common/div_cost/ndiv_cost
!   Distribution in top energy
      common/ext_Et/Etmax,Etmin,Etw
      common/dist_Et/xEt(500),fxEt(500,20),fxEttot(500)
      common/inp_Et/m_Et
      common/div_Et/ndiv_Et
!   Distribution in sum of ET: H_T
      common/ext_HT/HTmax,HTmin,HTw
      common/dist_HT/xHT(500),fxHT(500,20),fxHTtot(500)
      common/inp_HT/m_HT
      common/div_HT/ndiv_HT
!   Distribution in cotransverse mass
      common/ext_rM_T/rM_Tmax,rM_Tmin,rM_Tw
      common/dist_rM_T/xrM_T(500),fxrM_T(500,20),fxrM_Ttot(500)
      common/inp_rM_T/m_rM_T
      common/div_rM_T/ndiv_rM_T
!   Distribution in contransverse mass 1
      common/ext_rM_CT/rM_CTmax,rM_CTmin,rM_CTw
      common/dist_rM_CT/xrM_CT(500),fxrM_CT(500,20),fxrM_CTtot(500)
      common/inp_rM_CT/m_rM_CT
      common/div_rM_CT/ndiv_rM_CT
!   Distribution in lepton contransverse mass
      common/ext_rMlCT/rMlCTmax,rMlCTmin,rMlCTw
      common/dist_rMlCT/xrMlCT(500),fxrMlCT(500,20),fxrMlCTtot(500)
      common/inp_rMlCT/m_rMlCT
      common/div_rMlCT/ndiv_rMlCT
!   Distribution in phi_l (lepton azimuthal angle)
      common/ext_fl/flmax,flmin,flw
      common/dist_fl/xfl(500),fxfl(500,20),fxfltot(500)
      common/inp_fl/m_fl
      common/div_fl/ndiv_fl
!   Distribution in cos_phi_l
      common/ext_cosfl/cosflmax,cosflmin,cosflw
      common/dist_cosfl/xcosfl(500),fxcosfl(500,20),fxcosfltot(500)
      common/inp_cosfl/m_cosfl
      common/div_cosfl/ndiv_cosfl
!   Distribution in sigp
      common/ext_sigp/sigpmax,sigpmin,sigpw
      common/dist_sigp/xsigp(1000),fxsigp(8,1000,20),fxsigptot(8,1000)
      common/inp_sigp/m_sigp
      common/div_sigp/ndiv_sigp
!   Distribution in sigm
      common/ext_sigm/sigmmax,sigmmin,sigmw
      common/dist_sigm/xsigm(1000),fxsigm(8,1000,20),fxsigmtot(8,1000)
      common/inp_sigm/m_sigm
      common/div_sigm/ndiv_sigm
!   Distributions in asymmetries
      common/inp_asym/m_asy(8) ! nasy

! Local arrays    
!   phase space vectors.
      dimension q356(4),q478(4),p356(4),p478(4)
      dimension q56(4),q78(4),p56(4),p78(4)
      dimension q5(4),q7(4)
      dimension q(4,8),qcol(4,8)
      dimension p1(0:3),p2(0:3),
     &          p3(0:3),p4(0:3),p5(0:3),p6(0:3),p7(0:3),p8(0:3)
      dimension pT2(8),pT(8),phi(8)
      dimension pTvis(2),pTmiss(2)
! Lepton azimuthal angle coordinate system
      dimension xp(3),yp(3),zp(3)
!   polar M*Ms for asymmetries
      dimension respolgg(-1:1,-1:1),respolqq(-1:1,-1:1)      
      dimension respoldd(-1:1,-1:1),respoluu(-1:1,-1:1)
      dimension weight(20,-1:1,-1:1)
      dimension pfx(-1:1,-1:1)
!   PDFs
      dimension fx1(13),fx2(13)

! Local constants
!   pi
      parameter (pi=3.14159265358979323846d0)
!   Quark masses
      data rmu/0.00d0/,
     &     rmd/0.00d0/,
     &     rms/0.00d0/,
     &     rmc/0.00d0/,
     &     rmb/4.25d0/
!   Internal random number seed
      data jseed/987654321/
! ----------------------------------------------------------------------
! Initial parton distribution
!   Maximum centre of mass energy
      Ecm_max=Ecm_coll 
!   Centre of mass energy
      Ecm=x(2+12*ifinal ! final state)*(Ecm_max-rm3-rm4-rm5-rm6-rm7-rm8)
     &                        +rm3+rm4+rm5+rm6+rm7+rm8
      shat=Ecm*Ecm
      tau=shat/s
!   x1 and x2 of the partons      
      x1=x(3+12*ifinal ! final state)*(1.d0-tau)+tau
      x2=tau/x1

! Structure functions
!   Scale for the PDFs
      QQ=2.d0*rmt
!   construct hadronic structure functions.
      if(istructure.le.4)then
        q2=QQ*QQ
        if((x1.le.1.d-6).or.(x1.ge.1.d0))then
          fxn=0.d0
          return
        end if
        if((x2.le.1.d-6).or.(x2.ge.1.d0))then
          fxn=0.d0
          return
        end if
        if((QQ.le.1.3d0).or.(QQ.ge.1.d4))then
          fxn=0.d0
          return
        end if
!   (Note that for cteq PDFs we multiply by x1 below and then divide by 
!   it later. This is for compatibility with MRS, which return xf(x).)
        u1=x1*ctq6pdf(1,x1,QQ)
        d1=x1*ctq6pdf(2,x1,QQ)
        usea1=x1*ctq6pdf(-1,x1,QQ)
        dsea1=x1*ctq6pdf(-2,x1,QQ)
        str1=x1*ctq6pdf(3,x1,QQ)
        chm1=x1*ctq6pdf(4,x1,QQ)
        btm1=x1*ctq6pdf(5,x1,QQ)
        g1=x1*ctq6pdf(0,x1,QQ)
        u2=x2*ctq6pdf(1,x2,QQ)
        d2=x2*ctq6pdf(2,x2,QQ)
        usea2=x2*ctq6pdf(-1,x2,QQ)
        dsea2=x2*ctq6pdf(-2,x2,QQ)
        str2=x2*ctq6pdf(3,x2,QQ)
        chm2=x2*ctq6pdf(4,x2,QQ)
        btm2=x2*ctq6pdf(5,x2,QQ)
        g2=x2*ctq6pdf(0,x2,QQ)
      else if(istructure.eq.5)then
        imode=1
        if((x1.le.1.d-5).or.(x1.ge.1.d0))then
          fxn=0.d0
          return
        end if
        if((x2.le.1.d-5).or.(x2.ge.1.d0))then
          fxn=0.d0
          return
        end if
        if((QQ**2.le.1.25d0).or.(QQ**2.ge.1.d7))then
          fxn=0.d0
          return
        end if
        call mrs99(x1,QQ,imode,u1,d1,usea1,dsea1,str1,chm1,btm1,g1)
        call mrs99(x2,QQ,imode,u2,d2,usea2,dsea2,str2,chm2,btm2,g2)
      else if(istructure.eq.6)then
        imode=2
        if((x1.le.1.d-5).or.(x1.ge.1.d0))then
          fxn=0.d0
          return
        end if
        if((x2.le.1.d-5).or.(x2.ge.1.d0))then
          fxn=0.d0
          return
        end if
        if((QQ**2.le.1.25d0).or.(QQ**2.ge.1.d7))then
          fxn=0.d0
          return
        end if
        call mrs99(x1,QQ,imode,u1,d1,usea1,dsea1,str1,chm1,btm1,g1)
        call mrs99(x2,QQ,imode,u2,d2,usea2,dsea2,str2,chm2,btm2,g2)
      else if(istructure.eq.7)then
        imode=3
        if((x1.le.1.d-5).or.(x1.ge.1.d0))then
          fxn=0.d0
          return
        end if
        if((x2.le.1.d-5).or.(x2.ge.1.d0))then
          fxn=0.d0
          return
        end if
        if((QQ**2.le.1.25d0).or.(QQ**2.ge.1.d7))then
          fxn=0.d0
          return
        end if
        call mrs99(x1,QQ,imode,u1,d1,usea1,dsea1,str1,chm1,btm1,g1)
        call mrs99(x2,QQ,imode,u2,d2,usea2,dsea2,str2,chm2,btm2,g2)
      else if(istructure.eq.8)then
        imode=4
        if((x1.le.1.d-5).or.(x1.ge.1.d0))then
          fxn=0.d0
          return
        end if
        if((x2.le.1.d-5).or.(x2.ge.1.d0))then
          fxn=0.d0
          return
        end if
        if((QQ**2.le.1.25d0).or.(QQ**2.ge.1.d7))then
          fxn=0.d0
          return
        end if
        call mrs99(x1,QQ,imode,u1,d1,usea1,dsea1,str1,chm1,btm1,g1)
        call mrs99(x2,QQ,imode,u2,d2,usea2,dsea2,str2,chm2,btm2,g2)
      else if(istructure.eq.9)then
        imode=5
        if((x1.le.1.d-5).or.(x1.ge.1.d0))then
          fxn=0.d0
          return
        end if
        if((x2.le.1.d-5).or.(x2.ge.1.d0))then
          fxn=0.d0
          return
        end if
        if((QQ**2.le.1.25d0).or.(QQ**2.ge.1.d7))then
          fxn=0.d0
          return
        end if
        call mrs99(x1,QQ,imode,u1,d1,usea1,dsea1,str1,chm1,btm1,g1)
        call mrs99(x2,QQ,imode,u2,d2,usea2,dsea2,str2,chm2,btm2,g2)
      end if

!   Parton distribution functions (PDFs)
!   (Note that MRS return valence and sea contributions automatically.)
      fx1(1)=d1+dsea1
      fx1(2)=u1+usea1
      fx1(3)=str1
      fx1(4)=chm1
      fx1(5)=btm1
      fx1(6)=0.d0
      fx1(7)=dsea1
      fx1(8)=usea1
      fx1(9)=fx1(3)
      fx1(10)=fx1(4)
      fx1(11)=fx1(5)
      fx1(12)=fx1(6)
      fx1(13)=g1
      do i=1,13
        fx1(i)=fx1(i)/x1
      end do
      fx2(1)=d2*(1-icoll)+dsea2
      fx2(2)=u2*(1-icoll)+usea2
      fx2(3)=str2
      fx2(4)=chm2
      fx2(5)=btm2
      fx2(6)=0.d0
      fx2(7)=d2*icoll+dsea2
      fx2(8)=u2*icoll+usea2
      fx2(9)=fx2(3)
      fx2(10)=fx2(4)
      fx2(11)=fx2(5)
      fx2(12)=fx2(6)
      fx2(13)=g2
      do i=1,13
        fx2(i)=fx2(i)/x2
      end do

!       write(*,*)'bork end pdfs'
! ----------------------------------------------------------------------
! Kinematics

! Incoming momenta (all massless)
      pcm=Ecm/2.d0
      q(4,1)=pcm
      q(3,1)=pcm
      q(2,1)=0.d0
      q(1,1)=0.d0
      q(4,2)=pcm
      q(3,2)=-pcm
      q(2,2)=0.d0
      q(1,2)=0.d0

!   Outgoing momenta for 2 body final state.  
      if(ifinal ! final state.eq.0)then
        phit=2.d0*pi*ran(jseed)
        ct=x(1)
        st=sqrt(1.d0-ct*ct)
        qcm2=((Ecm*Ecm-rm3*rm3-rm4*rm4)**2-(2.d0*rm3*rm4)**2)/
     &    (4.d0*Ecm*Ecm)
        if (qcm2.lt.0.d0) then
          fxn=0.d0
          return
        else
          qcm=sqrt(qcm2)
        endif
        q(4,3)=sqrt(qcm2+rm3*rm3)
        q(3,3)=qcm*ct
        q(2,3)=qcm*st*cos(phit)
        q(1,3)=qcm*st*sin(phit)
        q(4,4)=sqrt(qcm2+rm4*rm4)
        q(3,4)=-qcm*ct
        q(2,4)=-qcm*st*cos(phit)
        q(1,4)=-qcm*st*sin(phit)
        do i=1,4
          q(i,5)=0.d0
          q(i,6)=0.d0
          q(i,7)=0.d0
          q(i,8)=0.d0
        end do

! Outgoing momenta for 6 body final state
      else if(ifinal ! final state.eq.1)then
        phit=2.d0*pi*ran(jseed)
        rm356min=rm3+rm5+rm6
        rm356max=Ecm-rm4-rm7-rm8
        XX356min=datan(((rm356min)**2-rmt**2)/rmt/gamt)
        XX356max=datan(((rm356max)**2-rmt**2)/rmt/gamt)
        xx=x(13)*(XX356max-XX356min)+XX356min          
        rl356=dtan(xx)*rmt*gamt                        
        rm356_2=(rmt**2+rl356)                         
        if(rm356_2.lt.0.d0)then
          fxn=0.d0
          return
        else
          rm356=sqrt(rm356_2)
        endif
        rm478min=rm4+rm7+rm8
        rm478max=Ecm-rm356
        XX478min=datan(((rm478min)**2-rmt**2)/rmt/gamt)
        XX478max=datan(((rm478max)**2-rmt**2)/rmt/gamt)
        xx=x(12)*(XX478max-XX478min)+XX478min
        rl478=dtan(xx)*rmt*gamt
        rm478_2=(rmt**2+rl478)
        if(rm478_2.lt.0.d0)then
          fxn=0.d0
          return
        else
          rm478=sqrt(rm478_2)
        endif
        rm56min=rm5+rm6
        rm56max=rm356-rm3
        XX56min=datan(((rm56min)**2-rmW**2)/rmW/gamW)
        XX56max=datan(((rm56max)**2-rmW**2)/rmW/gamW)
        xx=x(11)*(XX56max-XX56min)+XX56min
        rl56=dtan(xx)*rmW*gamW
        rm56_2=(rmW**2+rl56)
        if(rm56_2.lt.0.d0)then
          fxn=0.d0
          return
        else
          rm56=sqrt(rm56_2)
        endif
        rm78min=rm7+rm8
        rm78max=rm478-rm4
        XX78min=datan(((rm78min)**2-rmW**2)/rmW/gamW)
        XX78max=datan(((rm78max)**2-rmW**2)/rmW/gamW)
        xx=x(10)*(XX78max-XX78min)+XX78min
        rl78=dtan(xx)*rmW*gamW
        rm78_2=(rmW**2+rl78)
        if(rm78_2.lt.0.d0)then
          fxn=0.d0
          return
        else
          rm78=sqrt(rm78_2)
        endif
        ct=x(9)
        st=sqrt(abs(1.d0-ct*ct))
        ct56=x(8)
        st56=sqrt(1.d0-ct56*ct56)
        ct78=x(7)
        st78=sqrt(1.d0-ct78*ct78)
        ct5=x(6)
        st5=sqrt(1.d0-ct5*ct5)
        ct7=x(5)
        st7=sqrt(1.d0-ct7*ct7)
        cf56=cos(x(4))
        sf56=sin(x(4))
        cf78=cos(x(3))
        sf78=sin(x(3))
        cf5=cos(x(2))
        sf5=sin(x(2))
        cf7=cos(x(1))
        sf7=sin(x(1))
        rq2=((Ecm*Ecm-rm356*rm356-rm478*rm478)**2
     &     -(2.d0*rm356*rm478)**2)/
     &      (4.d0*Ecm*Ecm)
        if(rq2.lt.0.d0)then
          fxn=0.d0
          return
        else
          rq=sqrt(rq2)
        endif
        p356(3)=rq*ct
        p356(2)=rq*st*cos(phit)
        p356(1)=rq*st*sin(phit)
        p356(4)=sqrt(rq2+rm356*rm356)
        rq562=((rm356*rm356-rm3*rm3-rm56*rm56)**2-(2.d0*rm3*rm56)**2)/
     &      (4.d0*rm356*rm356)
        if(rq562.lt.0.d0)then
          fxn=0.d0
          return
        else
          rq56=sqrt(rq562)
        endif
        q56(3)=rq56*st56*cf56
        q56(2)=rq56*st56*sf56
        q56(1)=rq56*ct56
        q56(4)=sqrt(rq562+rm56*rm56)
        pq56=0.d0
        do i=1,3
          pq56=pq56+p356(i)*q56(i)
        end do
        p56(4)=(p356(4)*q56(4)+pq56)/rm356
        q(4,3)=p356(4)-p56(4)
        do i=1,3
          p56(i)=q56(i)+p356(i)*(p56(4)+q56(4))/(p356(4)+rm356)
          q(i,3)=p356(i)-p56(i)
        end do
        do i=1,3
          p478(i)=-p356(i)
        end do
        p478(4)=sqrt(rq2+rm478*rm478)
        rq782=((rm478*rm478-rm4*rm4-rm78*rm78)**2-(2.d0*rm4*rm78)**2)/
     &      (4.d0*rm478*rm478)
        if(rq782.lt.0.d0)then
          fxn=0.d0
          return
        else
          rq78=sqrt(rq782)
        endif
        q78(3)=rq78*st78*cf78
        q78(2)=rq78*st78*sf78
        q78(1)=rq78*ct78
        q78(4)=sqrt(rq782+rm78*rm78)
        pq78=0.d0
        do i=1,3
          pq78=pq78+p478(i)*q78(i)
        end do
        p78(4)=(p478(4)*q78(4)+pq78)/rm478
        q(4,4)=p478(4)-p78(4)
        do i=1,3
          p78(i)=q78(i)+p478(i)*(p78(4)+q78(4))/(p478(4)+rm478)
          q(i,4)=p478(i)-p78(i)
        end do
        rq52=((rm56*rm56-rm5*rm5-rm6*rm6)**2-(2.d0*rm5*rm6)**2)/
     &       (4.d0*rm56*rm56)
        if(rq52.lt.0.d0)then
          fxn=0.d0
          return
        else
          rq5=sqrt(rq52)
        endif
        q5(3)=rq5*st5*cf5
        q5(2)=rq5*st5*sf5
        q5(1)=rq5*ct5
        q5(4)=sqrt(rq52+rm5*rm5)
        pq5=0.d0
        do i=1,3
          pq5=pq5+p56(i)*q5(i)
        end do
        q(4,5)=(p56(4)*q5(4)+pq5)/rm56
        q(4,6)=p56(4)-q(4,5)
        do i=1,3
          q(i,5)=q5(i)+p56(i)*(q(4,5)+q5(4))/(p56(4)+rm56)
          q(i,6)=p56(i)-q(i,5)
        end do
        rq72=((rm78*rm78-rm7*rm7-rm8*rm8)**2-(2.d0*rm7*rm8)**2)/
     &       (4.d0*rm78*rm78)
        if(rq72.lt.0.d0)then
          fxn=0.d0
          return
        else
          rq7=sqrt(rq72)
        endif
        q7(3)=rq7*st7*cf7
        q7(2)=rq7*st7*sf7
        q7(1)=rq7*ct7
        q7(4)=sqrt(rq72+rm7*rm7)
        pq7=0.d0
        do i=1,3
          pq7=pq7+p78(i)*q7(i)
        end do
        q(4,7)=(p78(4)*q7(4)+pq7)/rm78
        q(4,8)=p78(4)-q(4,7)
        do i=1,3
          q(i,7)=q7(i)+p78(i)*(q(4,7)+q7(4))/(p78(4)+rm78)
          q(i,8)=p78(i)-q(i,7)
        end do
      end if

! Boost initial and final state momenta to the collider CM
      vcol=(x1-x2)/(x1+x2)
      gcol=(x1+x2)/2.d0/sqrt(x1*x2)
      imax=4+ifinal ! final state*4
      do i=1,imax
        qcol(4,i)=gcol*(q(4,i)+vcol*q(3,i))
        qcol(3,i)=gcol*(q(3,i)+vcol*q(4,i))
        qcol(2,i)=q(2,i)
        qcol(1,i)=q(1,i)
      end do

!       write(*,*)'bork end kinematics'
! ----------------------------------------------------------------------
! Additional Kinematics
!   (These aren't required for the integration, but are used for
!   distributions and cuts.)
      
!   calculate transverse momenta
      do ip=1,8
        if (m_pT(ip).eq.1)then
          pT2(ip)=qcol(1,ip)**2+qcol(2,ip)**2
          pT(ip)=sqrt(pT2(ip))
        end if
      end do

      if(ifinal ! final state.eq.1)then
! calculate truth level top pair momenta
        pT356=sqrt((qcol(1,3)+qcol(1,5)+qcol(1,6))**2
     &           +(qcol(2,3)+qcol(2,5)+qcol(2,6))**2)
        pT478=sqrt((qcol(1,4)+qcol(1,7)+qcol(1,8))**2
     &           +(qcol(2,4)+qcol(2,7)+qcol(2,8))**2)

!   calculate missing transverse momentum
        ETvis2=0d0
        ETmiss2=0d0
        do i=1,2
          pTvis(i)=qcol(i,3)+qcol(i,4)+qcol(i,5)+qcol(i,7)
          pTmiss(i)=-pTvis(i)
          ETvis2=ETvis2+pTvis(i)**2
          ETmiss2=ETmiss2+pTmiss(i)**2
        end do
        ETvis=sqrt(ETvis2)
        ETmiss=sqrt(ETmiss2)

        

!   calculate HT
        ET3=sqrt(rm3**2+pT2(3))
        ET4=sqrt(rm4**2+pT2(4))
        ET5=sqrt(rm5**2+pT2(5))
        ET7=sqrt(rm6**2+pT2(7))
        HT=ET3+ET4+ET5+ET7+ETmiss

!   calculate *full* transverse mass
        rM_T2=(ETvis+ETmiss)**2
        do i=1,2
          rM_T2=rM_T2-(pTvis(i)+pTmiss(i))**2
        end do
        rM_T=sqrt(rM_T2)

        

!   calculate *full* contranverse mass
        rM_CT2=(ETvis+ETmiss)**2
        do i=1,2
          rM_CT2=rM_CT2-(pTvis(i)-pTmiss(i))**2
        end do
        rM_CT=sqrt(abs(rM_CT2))

!   calculate lepton contransverse mass
        ET5=sqrt(rm5**2+pT2(5))
        ET7=sqrt(rm7**2+pT2(7))
        rMlCT2=(ET5+ET7)**2
        do i=1,2
          rMlCT2=rMlCT2-(qcol(i,5)-qcol(i,7))**2
        end do
        rMlCT=sqrt(rMlCT2)
      end if

!       write(*,*)'bork end of transverse variables'

! Calculate pseudorapidity (eta)        
      rps3=(q(3,3))/sqrt(q(1,3)**2+q(2,3)**2+q(3,3)**2)
      if(rps3.lt.-1.d0)rps=-1.d0
      if(rps3.gt.+1.d0)rps=+1.d0
      rpl3=dacos(rps3)
      arg3=tan(rpl3/2d0)
      if(arg3.le.0.d0)arg3=1.d-9
      eta3=-log(arg3)
!   Cut on this if ifinal ! final state=0
      if(ifinal ! final state.eq.0)then        
        if(abs(eta3).gt.ytcut)then
          fxn=0.d0
          return
        end if
      else
        continue
      end if

      rps4=(q(3,4))/sqrt(q(1,4)**2+q(2,4)**2+q(3,4)**2)
      if(rps4.lt.-1.d0)rps=-1.d0
      if(rps4.gt.+1.d0)rps=+1.d0
      rpl4=dacos(rps4)
      arg4=tan(rpl4/2d0)
      if(arg4.le.0.d0)arg4=1.d-9
      eta4=-log(arg4) ! no cuts on pseudorapidity yet

      if(ifinal ! final state.eq.1)then

        rps5=q(3,5)/sqrt(q(1,5)**2+q(2,5)**2+q(3,5)**2)
        if(rps5.lt.-1.d0)rps=-1.d0
        if(rps5.gt.+1.d0)rps=+1.d0
        rpl5=dacos(rps5)
        arg5=tan(rpl5/2d0)
        if(arg5.le.0.d0)arg5=1.d-9
        eta5=-log(arg5) ! no cuts on pseudorapidity yet

        rps6=q(3,6)/sqrt(q(1,6)**2+q(2,6)**2+q(3,6)**2)
        if(rps6.lt.-1.d0)rps=-1.d0
        if(rps6.gt.+1.d0)rps=+1.d0
        rpl6=dacos(rps6)
        arg6=tan(rpl6/2d0)
        if(arg6.le.0.d0)arg6=1.d-9
        eta6=-log(arg6) ! no cuts on pseudorapidity yet

        rps7=q(3,7)/sqrt(q(1,7)**2+q(2,7)**2+q(3,7)**2)
        if(rps7.lt.-1.d0)rps=-1.d0
        if(rps7.gt.+1.d0)rps=+1.d0
        rpl7=dacos(rps7)
        arg7=tan(rpl7/2d0)
        if(arg7.le.0.d0)arg7=1.d-9
        eta7=-log(arg7) ! no cuts on pseudorapidity yet

        rps8=q(3,8)/sqrt(q(1,8)**2+q(2,8)**2+q(3,8)**2)
        if(rps8.lt.-1.d0)rps=-1.d0
        if(rps8.gt.+1.d0)rps=+1.d0
        rpl8=dacos(rps8)
        arg8=tan(rpl8/2d0)
        if(arg8.le.0.d0)arg8=1.d-9
        eta8=-log(arg8) ! no cuts on pseudorapidity yet
      end if

! calculate phi's
      if(ifinal ! final state.eq.0)ipmax=4
      if(ifinal ! final state.gt.0)ipmax=8
      do ip=1,ipmax
        phi(ip)=atan2(qcol(2,ip),qcol(1,ip))
      end do

! calculate delta phi
      if(ifinal ! final state.eq.1)then
        dphi=abs(phi(5)-phi(7))
      end if

! calculate top pseudorapidity     
      if(ifinal ! final state.eq.1)then
        rps356=(q(3,3)+q(3,5)+q(3,6))
     &       /sqrt((q(1,3)+q(1,5)+q(1,6))**2
     &            +(q(2,3)+q(2,5)+q(2,6))**2
     &            +(q(3,3)+q(3,5)+q(3,6))**2)
        if(rps356.lt.-1.d0)rps=-1.d0
        if(rps356.gt.+1.d0)rps=+1.d0
        rpl356=dacos(rps356)
        arg356=tan(rpl356/2d0)
        if(arg356.le.0.d0)arg356=1.d-9
        eta356=-log(arg356)      
        if(abs(eta356).gt.ytcut)then
          fxn=0.d0
          return
        end if

        rps478=(q(3,4)+q(3,7)+q(3,8))
     &       /sqrt((q(1,4)+q(1,7)+q(1,8))**2
     &            +(q(2,4)+q(2,7)+q(2,8))**2
     &            +(q(3,4)+q(3,7)+q(3,8))**2)
        if(rps478.lt.-1.d0)rps=-1.d0
        if(rps478.gt.+1.d0)rps=+1.d0
        rpl478=dacos(rps478)
        arg478=tan(rpl478/2d0)
        if(arg478.le.0.d0)arg478=1.d-9
        eta478=-log(arg478) ! no cuts on pseudorapidity yet
      else
        continue
      end if

! Calculate top rapidities (y)

      if(ifinal ! final state.eq.0)then
        yt= 0.5*log((qcol(4,3)+qcol(3,3))/(qcol(4,3)-qcol(3,3))) 
        ytb=0.5*log((qcol(4,4)+qcol(3,4))/(qcol(4,4)-qcol(3,4)))
      else if(ifinal ! final state.gt.0)then
        yt =0.5*log((qcol(4,3)+qcol(4,5)+qcol(4,6)
     &               +qcol(3,3)+qcol(3,5)+qcol(3,6))
     &              /(qcol(4,3)+qcol(4,5)+qcol(4,6)
     &               -qcol(3,3)+qcol(3,5)+qcol(3,6)))
        ytb=0.5*log((qcol(4,4)+qcol(4,7)+qcol(4,8)
     &               +qcol(3,4)+qcol(3,7)+qcol(3,8))
     &              /(qcol(4,4)+qcol(4,7)+qcol(4,8)
     &               -qcol(3,4)+qcol(3,7)+qcol(3,8)))


      end if

      del_y=abs(yt)-abs(ytb)

! calculate boost of the tt system
      ytt = 0.5d0*log(x1/x2)      

! calculate cos(theta^*_t)
      if(ifinal ! final state.eq.0)then
          costcm=+(q(1,3)*q(1,1)
     &         +q(2,3)*q(2,1)  
     &         +q(3,3)*q(3,1))
     &    /sqrt(q(1,3)*q(1,3) 
     &         +q(2,3)*q(2,3)
     &         +q(3,3)*q(3,3))
     &    /sqrt(q(1,1)*q(1,1) 
     &         +q(2,1)*q(2,1)
     &         +q(3,1)*q(3,1))
      else if(ifinal ! final state.gt.0)then
        costcm=
     &    ((q(1,3)+q(1,5)+q(1,6))*q(1,1)
     &    +(q(2,3)+q(2,5)+q(2,6))*q(2,1)
     &    +(q(3,3)+q(3,5)+q(3,6))*q(3,1))
     &/sqrt((q(1,3)+q(1,5)+q(1,6))
     &     *(q(1,3)+q(1,5)+q(1,6))
     &     +(q(2,3)+q(2,5)+q(2,6))
     &     *(q(2,3)+q(2,5)+q(2,6))
     &     +(q(3,3)+q(3,5)+q(3,6))
     &     *(q(3,3)+q(3,5)+q(3,6)))
     &/sqrt(q(1,1)*q(1,1)
     &     +q(2,1)*q(2,1)
     &     +q(3,1)*q(3,1))
      end if      

! calculate cos(theta_l+)
      if(ifinal ! final state.gt.0)then
          cost5=+(q(1,5)*q(1,1)
     &         +q(2,5)*q(2,1)  
     &         +q(3,5)*q(3,1))
     &    /sqrt(q(1,5)*q(1,5) 
     &         +q(2,5)*q(2,5)
     &         +q(3,5)*q(3,5))
     &    /sqrt(q(1,1)*q(1,1) 
     &         +q(2,1)*q(2,1)
     &         +q(3,1)*q(3,1))
      end if

! ! calculate cos(theta_l-)
      if(ifinal ! final state.gt.0)then
          cost7=+(q(1,7)*q(1,1)
     &         +q(2,7)*q(2,1)  
     &         +q(3,7)*q(3,1))
     &    /sqrt(q(1,7)*q(1,7) 
     &         +q(2,7)*q(2,7)
     &         +q(3,7)*q(3,7))
     &    /sqrt(q(1,1)*q(1,1) 
     &         +q(2,1)*q(2,1)
     &         +q(3,1)*q(3,1))
      end if

! calculate cos(theta_t)
      if(ifinal ! final state.eq.0)then
          cost=
     &     (qcol(1,3)*qcol(1,1)
     &     +qcol(2,3)*qcol(2,1)
     &     +qcol(3,3)*qcol(3,1))
     &/sqrt(qcol(1,3)*qcol(1,3)
     &     +qcol(2,3)*qcol(2,3)
     &     +qcol(3,3)*qcol(3,3))
     &/sqrt(qcol(1,1)*qcol(1,1)
     &     +qcol(2,1)*qcol(2,1)
     &     +qcol(3,1)*qcol(3,1))
        else if(ifinal ! final state.eq.1)then
          cost=
     &    ((qcol(1,3)+qcol(1,5)+qcol(1,6))*qcol(1,1)
     &    +(qcol(2,3)+qcol(2,5)+qcol(2,6))*qcol(2,1)
     &    +(qcol(3,3)+qcol(3,5)+qcol(3,6))*qcol(3,1))
     &/sqrt((qcol(1,3)+qcol(1,5)+qcol(1,6))
     &     *(qcol(1,3)+qcol(1,5)+qcol(1,6))
     &     +(qcol(2,3)+qcol(2,5)+qcol(2,6))
     &     *(qcol(2,3)+qcol(2,5)+qcol(2,6))
     &     +(qcol(3,3)+qcol(3,5)+qcol(3,6))
     &     *(qcol(3,3)+qcol(3,5)+qcol(3,6)))
     &/sqrt(qcol(1,1)*qcol(1,1)
     &     +qcol(2,1)*qcol(2,1)
     &     +qcol(3,1)*qcol(3,1))
        end if


! Calculate cos(phi_l) (lepton azimuthal angle)
      if(ifinal ! final state.gt.0)then
        p5m=sqrt(q(1,5)*q(1,5)+q(2,5)*q(2,5)+q(3,5)*q(3,5))

        ! p(1)^ is z^
        do i=1,3
          zp(i)=q(i,1)/sqrt(q(1,1)*q(1,1)+q(2,1)*q(2,1)+q(3,1)*q(3,1))
        end do

        ! p(5)_T^ is x^
        do i=1,2
          xp(i)=p356(i)/sqrt(p356(1)*p356(1)+p356(2)*p356(2))
        end do
        xp(3)=0      

        ! y^ obtained using cross product
        yp(1) = zp(2) * xp(3) - zp(3) * xp(2)
        yp(2) = zp(3) * xp(1) - zp(1) * xp(3)
        yp(3) = zp(1) * xp(2) - zp(2) * xp(1)

        p5xp=0
        do i=1,3
          p5xp=p5xp+q(i,5)*xp(i)
        end do
        p5yp=0
        do i=1,3
          p5yp=p5yp+q(i,5)*yp(i)
        end do
        p5zp=0
        do i=1,3
          p5zp=p5zp+q(i,5)*zp(i)
        end do

        p5mp=sqrt(p5xp*p5xp+p5yp*p5yp+p5zp*p5zp)

        if(abs(p5m-p5mp).ge.1E-11)write(*,*)'Error in coord transform.'

        fl=atan2(p5yp,p5xp)

        if(fl.lt.0)fl=fl+2*pi

        cosfl=cos(fl)
      end if
     
! ----------------------------------------------------------------------
! Assign to madgraph momenta

      if(ifinal ! final state.eq.0)then
! Assign 2to2 MadGraph momenta      
        do i=1,3
          p1(i)=q(i,1)
          p2(i)=q(i,2)
          p3(i)=q(i,3)
          p4(i)=q(i,4) 
          p5(i)=0.d0
          p6(i)=0.d0  
          p7(i)=0.d0
          p8(i)=0.d0  
        end do
        p1(0)=q(4,1)
        p2(0)=q(4,2)
        p3(0)=q(4,3)
        p4(0)=q(4,4) 
        p5(0)=0.d0
        p6(0)=0.d0
        p7(0)=0.d0
        p8(0)=0.d0

! Check 2to2 kinematics
!         write(*,*) 'p1  =',p1
!         write(*,*) 'p2  =',p2
!         write(*,*) 'p3  =',p3
!         write(*,*) 'p4  =',p4
!         delta_E=p1(0)+p2(0)
!      &         -p3(0)-p4(0)
!         delta_x=p1(1)+p2(1)
!      &         -p3(1)-p4(1)
!         delta_y=p1(2)+p2(2)
!      &         -p3(2)-p4(2)
!         delta_z=p1(3)+p2(3)
!      &         -p3(3)-p4(3)
!         write(*,*) 'delta_E=',delta_E
!         write(*,*) 'delta_x=',delta_x
!         write(*,*) 'delta_y=',delta_y
!         write(*,*) 'delta_z=',delta_z
!         rmassa1=sqrt(abs(p1(0)**2-p1(1)**2-p1(2)**2-p1(3)**2))
!         rmassa2=sqrt(abs(p2(0)**2-p2(1)**2-p2(2)**2-p2(3)**2))
!         rmassa3=sqrt(abs(p3(0)**2-p3(1)**2-p3(2)**2-p3(3)**2))
!         rmassa4=sqrt(abs(p4(0)**2-p4(1)**2-p4(2)**2-p4(3)**2))
!         write(*,*) 'rm_1 =',rmassa1
!         write(*,*) 'rm_2 =',rmassa2
!         write(*,*) 'rm_3 =',rmassa3
!         write(*,*) 'rm_4 =',rmassa4


      else if(ifinal ! final state.eq.1)then
! Assign 2to6 MadGraph momenta      
        do i=1,3
          p1(i)=q(i,1)
          p2(i)=q(i,2)
          p3(i)=q(i,3)
          p4(i)=q(i,4) 
          p5(i)=q(i,5) 
          p6(i)=q(i,6) 
          p7(i)=q(i,7) 
          p8(i)=q(i,8) 
        end do
        p1(0)=q(4,1)
        p2(0)=q(4,2)
        p3(0)=q(4,3)
        p4(0)=q(4,4) 
        p5(0)=q(4,5)
        p6(0)=q(4,6)
        p7(0)=q(4,7)
        p8(0)=q(4,8)

! Check 6-body kinematics
!         write(*,*) 'p1  =',p1
!         write(*,*) 'p2  =',p2
!         write(*,*) 'p3  =',p3
!         write(*,*) 'p4  =',p4
!         write(*,*) 'p5  =',p5
!         write(*,*) 'p6  =',p6
!         write(*,*) 'p7  =',p7
!         write(*,*) 'p8  =',p8
! ! check conservation of 4-momentum.
!         delta_E=p1(0)+p2(0)
!      &         -p3(0)-p4(0)
!      &         -p5(0)-p6(0)
!      &         -p7(0)-p8(0)
!         delta_x=p1(1)+p2(1)
!      &         -p3(1)-p4(1)
!      &         -p5(1)-p6(1)
!      &         -p7(1)-p8(1)
!         delta_y=p1(2)+p2(2)
!      &         -p3(2)-p4(2)
!      &         -p5(2)-p6(2)
!      &         -p7(2)-p8(2)
!         delta_z=p1(3)+p2(3)
!      &         -p3(3)-p4(3)
!      &         -p5(3)-p6(3)
!      &         -p7(3)-p8(3)
!         write(*,*) 'delta_E=',delta_E
!         write(*,*) 'delta_px=',delta_x
!         write(*,*) 'delta_py=',delta_y
!         write(*,*) 'delta_pz=',delta_z
! ! check invarient mass.
!         rmassa1=sqrt(abs(p1(0)**2-p1(1)**2-p1(2)**2-p1(3)**2))
!         rmassa2=sqrt(abs(p2(0)**2-p2(1)**2-p2(2)**2-p2(3)**2))
!         rmassa3=sqrt(abs(p3(0)**2-p3(1)**2-p3(2)**2-p3(3)**2))
!         rmassa4=sqrt(abs(p4(0)**2-p4(1)**2-p4(2)**2-p4(3)**2))
!         rmassa5=sqrt(abs(p5(0)**2-p5(1)**2-p5(2)**2-p5(3)**2))
!         rmassa6=sqrt(abs(p6(0)**2-p6(1)**2-p6(2)**2-p6(3)**2))
!         rmassa7=sqrt(abs(p7(0)**2-p7(1)**2-p7(2)**2-p7(3)**2))
!         rmassa8=sqrt(abs(p8(0)**2-p8(1)**2-p8(2)**2-p8(3)**2))
!         write(*,*) 'rm_1 =',rmassa1
!         write(*,*) 'rm_2 =',rmassa2
!         write(*,*) 'rm_3 =',rmassa3
!         write(*,*) 'rm_4 =',rmassa4
!         write(*,*) 'rm_5 =',rmassa5
!         write(*,*) 'rm_6 =',rmassa6
!         write(*,*) 'rm_7 =',rmassa7
!         write(*,*) 'rm_8 =',rmassa8
! ! check missing momentum
!         pT682=(qcol(1,6)+qcol(1,8))**2+(qcol(2,6)+qcol(2,8))**2
!         pT68=sqrt(pT682)
!         write(*,*)'ETmiss :',ETmiss
!         write(*,*)'pT(v+v):',pT68
      end if

!       write(*,*)'bork end additional kinematics'

! Square Matrix elements
!   Calculate strong coupling
      a_s=alfas(QQ,rLambdaQCD4,nloops)
      gs2=4.d0*pi*a_s
      gs=sqrt(gs2)

!   (Do not change the deliberate order of p6 and p7 in the EW code.)
!   Initilize
      resqq=0.d0
      resgg=0.d0
      resuu=0.d0
      resdd=0.d0
      do ii=-1,1,1
        do jj=-1,1,1
          respolgg(ii,jj)=0.d0
          respolqq(ii,jj)=0.d0
          respoldd(ii,jj)=0.d0
          respoluu(ii,jj)=0.d0
          do kk=1,20
            weight(kk,ii,jj)=0.d0
          end do
        end do
      end do

! 2-body MEs      
!   Add QCD Matrix Elements
      if(ifinal ! final state.eq.0)then
        if(iQCD.eq.0)then
          continue
        else if(iQCD.eq.1)then
          do lam3=-1,1,2
            do lam4=-1,1,2
            respolqq(lam3,lam4)=sqqb_ttb(p1,p2,p3,p4,lam3,lam4)*gs**4
            respolgg(lam3,lam4)=sgg_ttb(p1,p2,p3,p4,lam3,lam4)*gs**4
            end do
          end do
        else
          write(*,*)'iQCD is not set correctly.'
          stop
        end if  
!   Add EW Matrix Elements
        if((iEW.eq.1).or.(iBSM.eq.1))then
          do lam3=-1,1,2
            do lam4=-1,1,2
              respoldd(lam3,lam4)=sqqb_ttb_EWp(1,gZpd,gZpu,rmZp,gamZp
     &                                           ,p1,p2,p3,p4,lam3,lam4)
              respoluu(lam3,lam4)=sqqb_ttb_EWp(2,gZpu,gZpu,rmZp,gamZp
     &                                           ,p1,p2,p3,p4,lam3,lam4)
            end do
          end do
        else
          continue
        end if
      end if
! 6-body MEs
!   Add QCD Matrix Elements
      if(ifinal ! final state.eq.1)then
        if(iQCD.eq.0)then
          continue
        else if(iQCD.eq.1)then
          resqq=sqqb_bbbtatann( p1 ,p2 ,p3 ,p4 ,p5 ,p7 ,p6 ,p8 )
          resgg= sgg_bbbtatann( p1 ,p2 ,p3 ,p4 ,p5 ,p7 ,p6 ,p8 )
        else
          write(*,*)'iQCD is not set correctly.'
          stop
        end if
!   Add EW Matrix Elements
        if((iEW.eq.1).or.(iBSM.eq.1))then
          
          resdd=sqqb_bbbtatann_EWp(1,gZpd,gZpu,rmZp,gamZp
     &                                  ,p1 ,p2 ,p3 ,p4 ,p5 ,p7 ,p6 ,p8)
          resuu=sqqb_bbbtatann_EWp(2,gZpu,gZpu,rmZp,gamZp
     &                                  ,p1 ,p2 ,p3 ,p4 ,p5 ,p7 ,p6 ,p8)
        else
          continue
        end if
      end if
! if no gauge sectors are active, fxn = 0
      if(ifinal ! final state.eq.1)then
        if((resqq+resgg+resuu+resdd).eq.0.d0)then
          fxn=0.d0
          return
        end if
      end if

! Multiple QCD M*M by g_s 
! (Madgraph gs is set to one due to scale dependence.)
      resqq=resqq*gs**4
      resgg=resgg*gs**4

! Sum over M*M for all initial partons.
! (Initial luminosity for total unpolarised cross section: pfxtot)

! sum over all polarised Matrix elements
      pfxtot=0.d0
      if(ifinal ! final state.eq.0) then

        do lam3=-1,1,2
          do lam4=-1,1,2
               pfx(lam3,lam4)=respolgg(lam3,lam4) *fx1(13)*fx2(13)
     &  +(respolqq(lam3,lam4)+respoldd(lam3,lam4))*fx1( 1)*fx2( 7)
     &  +(respolqq(lam3,lam4)+respoluu(lam3,lam4))*fx1( 2)*fx2( 8)
     &  +(respolqq(lam3,lam4)+respoldd(lam3,lam4))*fx1( 3)*fx2( 9)
     &  +(respolqq(lam3,lam4)+respoluu(lam3,lam4))*fx1( 4)*fx2(10)
     &  +(respolqq(lam3,lam4)+respoldd(lam3,lam4))*fx1( 5)*fx2(11)
     &  +(respolqq(lam3,lam4)+respoldd(lam3,lam4))*fx1( 7)*fx2( 1)
     &  +(respolqq(lam3,lam4)+respoluu(lam3,lam4))*fx1( 8)*fx2( 2)
     &  +(respolqq(lam3,lam4)+respoldd(lam3,lam4))*fx1( 9)*fx2( 3)
     &  +(respolqq(lam3,lam4)+respoluu(lam3,lam4))*fx1(10)*fx2( 4)
     &  +(respolqq(lam3,lam4)+respoldd(lam3,lam4))*fx1(11)*fx2( 5)
            pfx(lam3,lam4)=pfx(lam3,lam4)/x1
            pfxtot=pfxtot
     &            +pfx(lam3,lam4)
          end do
        end do
      else if(ifinal ! final state.eq.1) then
        qqd=fx1( 1)*fx2( 7)*( resqq + resdd ) ! d+db QCD + EW
     &     +fx1( 2)*fx2( 8)*( resqq + resuu ) ! u+ub
     &     +fx1( 3)*fx2( 9)*( resqq + resdd ) ! s+sb
     &     +fx1( 4)*fx2(10)*( resqq + resuu ) ! !+cb
     &     +fx1( 5)*fx2(11)*( resqq + resdd ) ! b+bb
     &     +fx1( 7)*fx2( 1)*( resqq + resdd ) ! db+d
     &     +fx1( 8)*fx2( 2)*( resqq + resuu ) ! ub+d
     &     +fx1( 9)*fx2( 3)*( resqq + resdd ) ! sb+s
     &     +fx1(10)*fx2( 4)*( resqq + resuu ) ! cb+!
     &     +fx1(11)*fx2( 5)*( resqq + resdd ) ! bb+b
        ggd=fx1(13)*fx2(13)*resgg
        pfxtot=(qqd+ggd)/x1
      end if
      if(pfxtot.eq.0.d0)then
        fxn=0.d0
        return
      end if
! for distributions,
      if(ifinal ! final state.eq.0)then 
        do lam3=-1,1,2
          do lam4=-1,1,2
            pfx(lam3,lam4)=pfx(lam3,lam4)/pfxtot
          end do
        end do
      end if
! check 
!       write(*,*)'resqq =',resqq
!       write(*,*)'resgg =',resgg
!       write(*,*)'resuu =',resuu
!       write(*,*)'resdd =',resdd
!       write(*,*)'pfxtot =',pfxtot

!       write(*,*)'bork end matrix elements'

      
! ---------------------------------------------------------------------- 
! Jacobians from dx1 dx2 -> dx(2) dx(3)
      pfxtot=pfxtot*(1.d0-tau)*2.d0*Ecm/s
     &      *(ecm_max-rm3-rm4-rm5-rm6-rm7-rm8)
! fxn is now M*M*PDFs
      fxn=pfxtot
! Multiply by 2pi from phit integration and convert from GeV^-2 to pb
      fxn=fxn*fac
      if(ifinal ! final state.eq.0)then
! 2-body phase space factor     
        fxn=fxn*qcm/(2.d0*pcm)*2.d0**(4-3*(2))
        fxn=fxn/2.d0/Ecm/Ecm*(2.d0*pi)**(4-3*(2))
      else if(ifinal ! final state.eq.1)then
! 6-body flux factor, pi's and phase space integral
        fxn=fxn*rq*rq56*rq78*rq5*rq7/Ecm*256.d0*2.d0**(4-3*(6))
     &     /(2.d0*rm356)
     &     /rmt/gamt
     &     *((rm356*rm356-rmt*rmt)**2+rmt**2*gamt**2)
        fxn=fxn*(XX356max-XX356min)
     &     /(2.d0*rm478)
     &     /rmt/gamt
     &     *((rm478*rm478-rmt*rmt)**2+rmt**2*gamt**2)
        fxn=fxn*(XX478max-XX478min)
     &     /(2.d0*rm56)
     &     /rmW/gamW
     &     *((rm56*rm56-rmW*rmW)**2+rmW**2*gamW**2)
        fxn=fxn*(XX56max-XX56min)
     &     /(2.d0*rm78)
     &     /rmW/gamW
     &     *((rm78*rm78-rmW*rmW)**2+rmW**2*gamW**2)
        fxn=fxn*(XX78max-XX78min)
!   NWA
        fxn=fxn
     &     *gamt/gNWA
     &     *gamt/gNWA
!   flux and pi factors.
        fxn=fxn/2.d0/Ecm/Ecm*(2.d0*pi)**(4-3*(6))
      end if

!       write(*,*)'bork end final factors'
! ---------------------------------------------------------------------- 
! Categorised cross sections / Asymmetries
   
! Polarised differential cross sections
!   Polarised cross section for each point is calculated. 
!   (Note that above pfx was divided by fxn.)
      if(ifinal ! final state.eq.0)then
        do iphel=-1,+1,2
          do jphel=-1,+1,2
            polcross(it,iphel,jphel)=polcross(it,iphel,jphel)
     &                              +fxn
     &                              *wgt          
     &                              *pfx(iphel,jphel)
            weight(it,iphel,jphel)=+fxn
     &                             *wgt
     &                             *pfx(iphel,jphel)
            polerror(it,iphel,jphel)=polerror(it,iphel,jphel)
     &                              +polcross(it,iphel,jphel)**2
          end do
        end do
      end if

! AFB*    
      if(m_asy(4).eq.0)then
        continue
      else
        if(costcm.eq.0.d0)then
          continue
        else if(costcm.gt.0.d0)then
          asycross(1,it,+1)=asycross(1,it,+1)
     &                              +fxn
     &                              *wgt
          asyerror(1,it,+1)=asyerror(1,it,+1)
     &                   +asycross(1,it,+1)**2
        else if(costcm.lt.0.d0)then
          asycross(1,it,-1)=asycross(1,it,-1)
     &                              +fxn
     &                              *wgt
          asyerror(1,it,-1)=asyerror(1,it,-1)
     &                   +asycross(1,it,-1)**2
        end if
      end if

! AtFB

      if(m_asy(5).eq.0)then
        continue
      else
        if(yt.eq.0.d0)then
          continue
        else if(yt.gt.0.d0)then
          asycross(2,it,+1)=asycross(2,it,+1)
     &                              +fxn
     &                              *wgt
          asyerror(2,it,+1)=asyerror(2,it,+1)
     &                   +asycross(2,it,+1)**2
        else if(yt.lt.0.d0)then
          asycross(2,it,-1)=asycross(2,it,-1)
     &                              +fxn
     &                              *wgt
          asyerror(2,it,-1)=asyerror(2,it,-1)
     &                   +asycross(2,it,-1)**2
        end if
      end if

! A
      if(m_asy(6).eq.0)then
        continue
      else
        if(yt.ge.0.d0)then
          asycross(3,it,+1)=asycross(3,it,+1)
     &                              +fxn
     &                              *wgt
          asyerror(3,it,+1)=asyerror(3,it,+1)
     &                   +asycross(3,it,+1)**2
        end if
        if(ytb.gt.0.d0)then
          asycross(3,it,-1)=asycross(3,it,-1)
     &                              +fxn
     &                              *wgt
          asyerror(3,it,-1)=asyerror(3,it,-1)
     &                   +asycross(3,it,-1)**2
        end if
      end if

! A'/ARFB

      if((m_asy(7).eq.1).and.(abs(ytt).gt.yttcut))then
        if(del_y.eq.0.d0)then
          continue
        else if(del_y.ge.0.d0)then
          asycross(4,it,+1)=asycross(4,it,+1)
     &                              +fxn
     &                              *wgt
          asyerror(4,it,+1)=asyerror(4,it,+1)
     &                   +asycross(4,it,+1)**2
        else if(del_y.lt.0.d0)then
          asycross(4,it,-1)=asycross(4,it,-1)
     &                              +fxn
     &                              *wgt
          asyerror(4,it,-1)=asyerror(4,it,-1)
     &                   +asycross(4,it,-1)**2
        end if
      end if

! A_l
      if(m_asy(8).eq.0)then
        continue
      else
        if (ifinal ! final state.gt.0)then      
          if(cosfl.eq.0.d0)then
            continue
          else if(cosfl.gt.0.d0)then
            asycross(5,it,+1)=asycross(5,it,+1)
     &                                +fxn
     &                                *wgt
            asyerror(5,it,+1)=asyerror(5,it,+1)
     &                     +asycross(5,it,+1)**2
          else if(cosfl.lt.0.d0)then
            asycross(5,it,-1)=asycross(5,it,-1)
     &                                +fxn
     &                                *wgt
            asyerror(5,it,-1)=asyerror(5,it,-1)
     &                     +asycross(5,it,-1)**2
          end if
        end if
      end if


!       write(*,*)'bork end categorised cross sections.'

! ----------------------------------------------------------------------
! Binning
      hist=fxn*wgt
      do ip=1,8
        if(m_pT(ip).eq.1)then
  !   generate distribution in pT       
          nbin=int((pT(ip)-pTmin(ip))/pTw(ip))+1
          if(nbin.ge.(ndiv_pT(ip)+1))then
            continue
          else if(nbin.lt.1)then
            continue
          else
            fxpT(ip,nbin,it)=fxpT(ip,nbin,it)+hist
          end if
        end if
      end do

      if(m_pT356.eq.1)then
!   generate distribution in pT356. 
        nbin=int((pT356-pT356min)/pT356w)+1
        if(nbin.ge.(ndiv_pT356+1))then
          continue
        else if(nbin.lt.1)then
          continue
        else
          fxpT356(nbin,it)=fxpT356(nbin,it)+hist
        end if
      end if

      if(m_pT478.eq.1)then
!   generate distribution in pT478. 
        nbin=int((pT478-pT478min)/pT478w)+1
        if(nbin.ge.(ndiv_pT478+1))then
          continue
        else if(nbin.lt.1)then
          continue
        else
          fxpT478(nbin,it)=fxpT478(nbin,it)+hist
        end if
      end if

      if(m_eta3.eq.1)then
!   generate distribution in eta3. 
        nbin=int((eta3-eta3min)/eta3w)+1
        if(nbin.ge.(ndiv_eta3+1))then
          continue
        else if(nbin.lt.1)then
          continue
        else
          fxeta3(nbin,it)=fxeta3(nbin,it)+hist
        end if
      end if

      if(m_eta4.eq.1)then
!   generate distribution in eta4. 
        nbin=int((eta4-eta4min)/eta4w)+1
        if(nbin.ge.(ndiv_eta4+1))then
          continue
        else if(nbin.lt.1)then
          continue
        else
          fxeta4(nbin,it)=fxeta4(nbin,it)+hist
        end if
      end if

      if(m_eta5.eq.1)then
!   generate distribution in eta5. 
        nbin=int((eta5-eta5min)/eta5w)+1
        if(nbin.ge.(ndiv_eta5+1))then
          continue
        else if(nbin.lt.1)then
          continue
        else
          fxeta5(nbin,it)=fxeta5(nbin,it)+hist
        end if
      end if

      if(m_eta6.eq.1)then
!   generate distribution in eta6. 
        nbin=int((eta6-eta6min)/eta6w)+1
        if(nbin.ge.(ndiv_eta6+1))then
          continue
        else if(nbin.lt.1)then
          continue
        else
          fxeta6(nbin,it)=fxeta6(nbin,it)+hist
        end if
      end if

      if(m_eta7.eq.1)then
!   generate distribution in eta7. 
        nbin=int((eta7-eta7min)/eta7w)+1
        if(nbin.ge.(ndiv_eta7+1))then
          continue
        else if(nbin.lt.1)then
          continue
        else
          fxeta7(nbin,it)=fxeta7(nbin,it)+hist
        end if
      end if

      if(m_eta8.eq.1)then
!   generate distribution in eta8. 
        nbin=int((eta8-eta8min)/eta8w)+1
        if(nbin.ge.(ndiv_eta8+1))then
          continue
        else if(nbin.lt.1)then
          continue
        else
          fxeta8(nbin,it)=fxeta8(nbin,it)+hist
        end if
      end if

      if(m_eta356.eq.1)then
!   generate distribution in eta356. 
        nbin=int((eta356-eta356min)/eta356w)+1
        if(nbin.ge.(ndiv_eta356+1))then
          continue
        else if(nbin.lt.1)then
          continue
        else
          fxeta356(nbin,it)=fxeta356(nbin,it)+hist
        end if
      end if

      if(m_eta478.eq.1)then
!   generate distribution in eta478. 
        nbin=int((eta478-eta478min)/eta478w)+1
        if(nbin.ge.(ndiv_eta478+1))then
          continue
        else if(nbin.lt.1)then
          continue
        else
          fxeta478(nbin,it)=fxeta478(nbin,it)+hist
        end if
      end if

      if(m_ETmiss.eq.1)then
!   generate distribution in ETmiss. 
        nbin=int((ETmiss-ETmissmin)/ETmissw)+1
        if(nbin.ge.(ndiv_ETmiss+1))then
          continue
        else if(nbin.lt.1)then
          continue
        else
          fxETmiss(nbin,it)=fxETmiss(nbin,it)+hist
        end if
      end if

      if(m_rmass.eq.1)then
!   generate distribution in rmass.
        if(ifinal ! final state.eq.0)then
          rmass2=(qcol(4,3)+qcol(4,4))**2
          do i=1,3
            rmass2=rmass2-(qcol(i,3)+qcol(i,4))**2
          end do
        else if(ifinal ! final state.eq.1)then
          rmass2=(qcol(4,3)+qcol(4,4)
     &           +qcol(4,5)+qcol(4,6)
     &           +qcol(4,7)+qcol(4,8))**2
          do i=1,3
            rmass2=rmass2-(qcol(i,3)+qcol(i,4)
     &                    +qcol(i,5)+qcol(i,6)
     &                    +qcol(i,7)+qcol(i,8))**2
          end do
        end if        
        rmass=sqrt(abs(rmass2))
        nbin=int((rmass-rmassmin)/rmassw)+1
        if(nbin.ge.(ndiv_rmass+1))then
          continue
        else if(nbin.lt.1)then
          continue
        else
          fxrmass(nbin,it)=fxrmass(nbin,it)+hist
        end if
      end if  

      if(m_rMvis.eq.1)then
!   generate distribution in rMvis.
        rMvis2=(qcol(4,3)+qcol(4,4)
     &         +qcol(4,5)+qcol(4,7))**2
        do i=1,3
          rMvis2=rMvis2-(qcol(i,3)+qcol(i,4)
     &                  +qcol(i,5)+qcol(i,7))**2
        end do      
        rMvis=sqrt(abs(rMvis2))
        nbin=int((rMvis-rMvismin)/rMvisw)+1
        if(nbin.ge.(ndiv_rMvis+1))then
          continue
        else if(nbin.lt.1)then
          continue
        else
          fxrMvis(nbin,it)=fxrMvis(nbin,it)+hist
        end if
      end if  

      if(m_beta.eq.1)then
!   generate distribution in beta.
        beta=shat/4.d0/rmt**2-1.d0
        nbin=int((beta-betamin)/betaw)+1
        if(nbin.ge.(ndiv_beta+1))then
          continue
        else if(nbin.lt.1)then
          continue
        else
          fxbeta(nbin,it)=fxbeta(nbin,it)+hist
        end if
      end if  

      if(m_cost.eq.1)then
!   generate distribution in cost.
        if(ifinal ! final state.eq.0)then
          cost=
     &     (qcol(1,3)*qcol(1,1)
     &     +qcol(2,3)*qcol(2,1)
     &     +qcol(3,3)*qcol(3,1))
     &/sqrt(qcol(1,3)*qcol(1,3)
     &     +qcol(2,3)*qcol(2,3)
     &     +qcol(3,3)*qcol(3,3))
     &/sqrt(qcol(1,1)*qcol(1,1)
     &     +qcol(2,1)*qcol(2,1)
     &     +qcol(3,1)*qcol(3,1))
        else if(ifinal ! final state.eq.1)then
          cost=
     &    ((qcol(1,3)+qcol(1,5)+qcol(1,6))*qcol(1,1)
     &    +(qcol(2,3)+qcol(2,5)+qcol(2,6))*qcol(2,1)
     &    +(qcol(3,3)+qcol(3,5)+qcol(3,6))*qcol(3,1))
     &/sqrt((qcol(1,3)+qcol(1,5)+qcol(1,6))
     &     *(qcol(1,3)+qcol(1,5)+qcol(1,6))
     &     +(qcol(2,3)+qcol(2,5)+qcol(2,6))
     &     *(qcol(2,3)+qcol(2,5)+qcol(2,6))
     &     +(qcol(3,3)+qcol(3,5)+qcol(3,6))
     &     *(qcol(3,3)+qcol(3,5)+qcol(3,6)))
     &/sqrt(qcol(1,1)*qcol(1,1)
     &     +qcol(2,1)*qcol(2,1)
     &     +qcol(3,1)*qcol(3,1))
        end if
        nbin=int((cost-costmin)/costw)+1
        if(nbin.ge.(ndiv_cost+1))then
          continue
        else if(nbin.lt.1)then
          continue
        else
          fxcost(nbin,it)=fxcost(nbin,it)+hist
        end if
      end if

      if(m_Et.eq.1)then ! generate distribution in Et.
        if(ifinal ! final state.eq.0)then
          Et=qcol(4,3)
        else if(ifinal ! final state.eq.1)then
          Et=qcol(4,3)+qcol(4,5)+qcol(4,6)
        end if
        nbin=int((Et-Etmin)/Etw)+1
        if(nbin.ge.(ndiv_Et+1))then
          continue
        else if(nbin.lt.1)then
          continue
        else
          fxEt(nbin,it)=fxEt(nbin,it)+hist
        end if
      end if

      if(m_HT.eq.1)then
        nbin=int((HT-HTmin)/HTw)+1
        if(nbin.ge.(ndiv_HT+1))then
          continue
        else if(nbin.lt.1)then
          continue
        else
          fxHT(nbin,it)=fxHT(nbin,it)+hist
        end if
      end if      

      if(m_rM_T.eq.1)then
        nbin=int((rM_T-rM_Tmin)/rM_Tw)+1
        if(nbin.ge.(ndiv_rM_T+1))then
          continue
        else if(nbin.lt.1)then
          continue
        else
          fxrM_T(nbin,it)=fxrM_T(nbin,it)+hist
        end if
      end if

      if(m_rM_CT.eq.1)then
        nbin=int((rM_CT-rM_CTmin)/rM_CTw)+1
        if(nbin.ge.(ndiv_rM_CT+1))then
          continue
        else if(nbin.lt.1)then
          continue
        else
          fxrM_CT(nbin,it)=fxrM_CT(nbin,it)+hist
        end if
      end if 

      if(m_rMlCT.eq.1)then
        nbin=int((rMlCT-rMlCTmin)/rMlCTw)+1
        if(nbin.ge.(ndiv_rMlCT+1))then
          continue
        else if(nbin.lt.1)then
          continue
        else
          fxrMlCT(nbin,it)=fxrMlCT(nbin,it)+hist
        end if
      end if

      if(m_fl.eq.1)then
!   generate distribution in fl.
        nbin=int((fl-flmin)/flw)+1
        if(nbin.ge.(ndiv_fl+1))then
          continue
        else if(nbin.lt.1)then
          continue
        else
          fxfl(nbin,it)=fxfl(nbin,it)+hist
        end if
      end if

      if(m_cosfl.eq.1)then
!   generate distribution in cosfl.
        nbin=int((cosfl-cosflmin)/cosflw)+1
        if(nbin.ge.(ndiv_cosfl+1))then
          continue
        else if(nbin.lt.1)then
          continue
        else
          fxcosfl(nbin,it)=fxcosfl(nbin,it)+hist
        end if
      end if

      if(m_asy(1).eq.1)then
        if(m_sigp.eq.1)then
!   generate distribution in sigp for ALL.
          sigp=Ecm
          nbin=int((sigp-sigpmin)/sigpw)+1
          if(nbin.ge.(ndiv_sigp+1))then
            continue
          else if(nbin.lt.1)then
            continue
          else
            fxsigp(1,nbin,it)=fxsigp(1,nbin,it)+
     &    (weight(it,+1,+1)+weight(it,-1,-1)) ! action happens
          end if
        end if  
        if(m_sigm.eq.1)then
!   generate distribution in sigm for ALL.
          sigm=Ecm
          nbin=int((sigm-sigmmin)/sigmw)+1
          if(nbin.ge.(ndiv_sigm+1))then
            continue
          else if(nbin.lt.1)then
            continue
          else
            fxsigm(1,nbin,it)=fxsigm(1,nbin,it)+
     &      (weight(it,+1,-1)+weight(it,-1,+1))
          end if
        end if
      end if

      if(m_asy(2).eq.1)then
        if(m_sigp.eq.1)then
!   generate distribution in sigp for AL.
          sigp=Ecm
          nbin=int((sigp-sigpmin)/sigpw)+1
          if(nbin.ge.(ndiv_sigp+1))then
            continue
          else if(nbin.lt.1)then
            continue
          else
            fxsigp(2,nbin,it)=fxsigp(2,nbin,it)+
     &      (weight(it,-1,-1)+weight(it,-1,+1))
          end if
        end if  
        if(m_sigm.eq.1)then
!   generate distribution in sigm for AL.
          sigm=Ecm
          nbin=int((sigm-sigmmin)/sigmw)+1
          if(nbin.ge.(ndiv_sigm+1))then
            continue
          else if(nbin.lt.1)then
            continue
          else
            fxsigm(2,nbin,it)=fxsigm(2,nbin,it)+
     &      (weight(it,+1,-1)+weight(it,+1,+1))
          end if
        end if
      end if

      if(m_asy(3).eq.1)then
        if(m_sigp.eq.1)then
!   generate distribution in sigp for APV.
          sigp=Ecm
          nbin=int((sigp-sigpmin)/sigpw)+1
          if(nbin.ge.(ndiv_sigp+1))then
            continue
          else if(nbin.lt.1)then
            continue
          else
            fxsigp(3,nbin,it)=fxsigp(3,nbin,it)+
     &      (weight(it,-1,-1))
          end if
        end if  
        if(m_sigm.eq.1)then
!   generate distribution in sigm for APV.
          sigm=Ecm
          nbin=int((sigm-sigmmin)/sigmw)+1
          if(nbin.ge.(ndiv_sigm+1))then
            continue
          else if(nbin.lt.1)then
            continue
          else
            fxsigm(3,nbin,it)=fxsigm(3,nbin,it)+
     &      (weight(it,+1,+1))
          end if
        end if 
      end if

      if(m_asy(4).eq.1)then
        if((m_sigp.eq.1).and.(costcm.gt.0.d0))then
!   generate distribution in sigp for AFBcm.
          sigp=Ecm
          nbin=int((sigp-sigpmin)/sigpw)+1
          if(nbin.ge.(ndiv_sigp+1))then
            continue
          else if(nbin.lt.1)then
            continue
          else
            fxsigp(4,nbin,it)=fxsigp(4,nbin,it)+hist
          end if
        end if  
        if((m_sigm.eq.1).and.(costcm.lt.0.d0))then
!   generate distribution in sigm for AFBcm.
          sigm=Ecm
          nbin=int((sigm-sigmmin)/sigmw)+1
          if(nbin.ge.(ndiv_sigm+1))then
            continue
          else if(nbin.lt.1)then
            continue
          else
            fxsigm(4,nbin,it)=fxsigm(4,nbin,it)+hist
          end if
        end if
      end if

      if(m_asy(5).eq.1)then
        if((m_sigp.eq.1).and.(yt.gt.0.d0))then
!   generate distribution in sigp for AtFB.
          sigp=Ecm
          nbin=int((sigp-sigpmin)/sigpw)+1
          if(nbin.ge.(ndiv_sigp+1))then
            continue
          else if(nbin.lt.1)then
            continue
          else
            fxsigp(5,nbin,it)=fxsigp(5,nbin,it)+hist
          end if
        end if  
        if((m_sigm.eq.1).and.(yt.lt.0.d0))then
!   generate distribution in sigm for AtFB.
          sigm=Ecm
          nbin=int((sigm-sigmmin)/sigmw)+1
          if(nbin.ge.(ndiv_sigm+1))then
            continue
          else if(nbin.lt.1)then
            continue
          else
            fxsigm(5,nbin,it)=fxsigm(5,nbin,it)+hist
          end if
        end if
      end if

      if(m_asy(6).eq.1)then
        if((m_sigp.eq.1).and.(yt.ge.0.d0))then
!   generate distribution in sigp for A.
          sigp=Ecm
          nbin=int((sigp-sigpmin)/sigpw)+1
          if(nbin.ge.(ndiv_sigp+1))then
            continue
          else if(nbin.lt.1)then
            continue
          else
            fxsigp(6,nbin,it)=fxsigp(6,nbin,it)+hist
          end if
        end if  
        if((m_sigm.eq.1).and.(ytb.ge.0.d0))then
!   generate distribution in sigm for A.
          sigm=Ecm
          nbin=int((sigm-sigmmin)/sigmw)+1
          if(nbin.ge.(ndiv_sigm+1))then
            continue
          else if(nbin.lt.1)then
            continue
          else
            fxsigm(6,nbin,it)=fxsigm(6,nbin,it)+hist
          end if
        end if
      end if

      if((m_asy(7).eq.1).and.(abs(ytt).gt.yttcut))then
        if((m_sigp.eq.1).and.(del_y.gt.0.d0))then
!   generate distribution in sigp for Ap.
          sigp=Ecm
          nbin=int((sigp-sigpmin)/sigpw)+1
          if(nbin.ge.(ndiv_sigp+1))then
            continue
          else if(nbin.lt.1)then
            continue
          else
            fxsigp(7,nbin,it)=fxsigp(7,nbin,it)+hist
          end if
        end if  
        if((m_sigm.eq.1).and.(del_y.lt.0.d0))then
!   generate distribution in sigm for Ap.
          sigm=Ecm
          nbin=int((sigm-sigmmin)/sigmw)+1
          if(nbin.ge.(ndiv_sigm+1))then
            continue
          else if(nbin.lt.1)then
            continue
          else
            fxsigm(7,nbin,it)=fxsigm(7,nbin,it)+hist
          end if
        end if
      end if


      if(m_asy(8).eq.1)then
        if((m_sigp.eq.1).and.(cosfl.gt.0.d0))then
!   generate distribution in sigp for A_l.
          sigp=Ecm
          nbin=int((sigp-sigpmin)/sigpw)+1
          if(nbin.ge.(ndiv_sigp+1))then
            continue
          else if(nbin.lt.1)then
            continue
          else
            fxsigp(8,nbin,it)=fxsigp(8,nbin,it)+hist
          end if
        end if
        if((m_sigm.eq.1).and.(cosfl.lt.0.d0))then
!   generate distribution in sigm for A_l.
          sigm=Ecm
          nbin=int((sigm-sigmmin)/sigmw)+1
          if(nbin.ge.(ndiv_sigm+1))then
            continue
          else if(nbin.lt.1)then
            continue
          else
            fxsigm(8,nbin,it)=fxsigm(8,nbin,it)+hist
          end if
        end if
      end if

! Statistics
      npoints=npoints+1
!       write(*,*)'bork end binning' 
      return
      end
! ======================================================================    