! rapidity
real :: yt, ytb, ytt, ytt_reco, yt_reco, ytcol, ytbcol
real :: delta_absy, delta_absy_reco
real :: yttmin = 0.d0

real :: mtt_reco
real :: mtt_reco2
real :: m356_reco

real :: pt68, pt682
! lepton azimuthal angle coordinate system
real :: xp(3), yp(3), zp(3)

! Transverse momentum vectors   
real :: pT6col(1:2), ptmiss(2)

if(additional_kinematics == 1) then

            call debug("Computing additional kinematic variables...")

            ! calculate truth level top/antitop pt, eta and phi
            if (final_state > 0) then
              pt356 = sqrt((qcol(1,3) + qcol(1,5) + qcol(1,6))**2 &
                           + (qcol(2,3) + qcol(2,5) + qcol(2,6))**2)
              call rootadddouble(pt356, "pT356")

              pt478 = sqrt((qcol(1,4) + qcol(1,7) + qcol(1,8))**2 &
                           + (qcol(2,4) + qcol(2,7) + qcol(2,8))**2)
              call rootadddouble(pt478, "pT478")


              rps356 = (q(3, 3) + q(3, 5) + q(3, 6)) &
              /sqrt((q(1, 3) + q(1, 5) + q(1, 6))**2 &
                    +(q(2, 3) + q(2, 5) + q(2, 6))**2 &
                    +(q(3, 3) + q(3, 5) + q(3, 6))**2)
              if (rps356 < -1.d0) rps = -1.d0
              if (rps356 > +1.d0) rps = +1.d0
              rpl356 = acos(rps356)
              arg356 = tan(rpl356/2d0)
              if (arg356 <= 0.d0) arg356 = 1.d-9
              eta356 = -log(arg356)
              call rootadddouble(eta356, "eta356")

              rps478 = (q(3,4)+q(3,7)+q(3,8)) &
              /sqrt((q(1,4)+q(1,7)+q(1,8))**2 &
              +(q(2,4)+q(2,7)+q(2,8))**2 &
              +(q(3,4)+q(3,7)+q(3,8))**2)
              if (rps478 < -1.d0)rps = -1.d0
              if (rps478 > +1.d0)rps = +1.d0
              rpl478 = acos(rps478)
              arg478 = tan(rpl478/2d0)
              if (arg478 <=  0.d0) arg478 = 1.d-9
              eta478 = -log(arg478)
              call rootadddouble(eta478, "eta478")

              phi356 = atan2(qcol(2,3) + qcol(2,5) + qcol(2,6) &
              ,qcol(1,3) + qcol(1,5) + qcol(1,6))
              call rootadddouble(phi356, "phi356")

              phi478 = atan2(qcol(2,4) + qcol(2,7) + qcol(2,8) &
              ,qcol(1,4) + qcol(1,7) + qcol(1,8))
              call rootadddouble(phi478, "phi478")

              ycol356 =0.5*log((qcol(4,3) + qcol(4,5) + qcol(4,6) &
               + qcol(3,3) + qcol(3,5) + qcol(3,6)) &
              /(qcol(4,3) + qcol(4,5) + qcol(4,6) &
               - qcol(3,3) - qcol(3,5) - qcol(3,6)))
              call rootadddouble(ycol356, "ycol356")

              ycol478=0.5*log((qcol(4,4) + qcol(4,7) + qcol(4,8) &
               + qcol(3,4) + qcol(3,7) + qcol(3,8)) &
              /(qcol(4,4) + qcol(4,7) + qcol(4,8) &
               - qcol(3,4) - qcol(3,7) - qcol(3,8)))
              call rootadddouble(ycol478, "ycol478")
            end if

            ! calculate the CoM rapidity of the top
            if (final_state == 0) then
              yt = 0.5d0*log((q(4,3) + q(3,3)) &
              /(q(4,3) - q(3,3)))
              ytcol = 0.5d0*log((qcol(4,3) + qcol(3,3)) &
              /(qcol(4,3) - qcol(3,3)))
            else if (final_state > 0) then
              yt  = 0.5*log((q(4,3) + q(4,5) + q(4,6) &
               + q(3,3) + q(3,5) + q(3,6)) &
               /(q(4,3) + q(4,5) + q(4,6) &
               - q(3,3) - q(3,5) - q(3,6)))
              ytcol = ycol356
            end if
            call rootadddouble(yt, "yt")

            ! calculate the CoM rapidity of the antitop
            if (final_state == 0) then
              ytb = 0.5d0*log((q(4,4) + q(3,4))/(q(4,4) - q(3,4)))
              ytbcol = 0.5d0*log((qcol(4,4) + qcol(3,4))/(qcol(4,4) - qcol(3,4)))
            else if (final_state > 0) then
              ytb = 0.5*log((q(4,4) + q(4,7) + q(4,8) &
               + q(3,4) + q(3,7) + q(3,8)) &
               /(q(4,4) + q(4,7) + q(4,8) &
               - q(3,4) - q(3,7) - q(3,8)))
              ytbcol = ycol478
            end if
            call rootadddouble(ytb, "ytbar")

            ! difference in absolute rapidity in lab frame
            delta_absy = abs(ytcol) - abs(ytbcol)
            call rootadddouble(delta_absy, "Delta_y")

            ! calculate collider frame cos(theta_t)
            if (final_state == 0) then
              cost = &
              (qcol(1,3)*qcol(1,1) &
              +qcol(2,3)*qcol(2,1) &
              +qcol(3,3)*qcol(3,1)) &
              /sqrt(qcol(1,3)*qcol(1,3) &
              +qcol(2,3)*qcol(2,3) &
              +qcol(3,3)*qcol(3,3)) &
              /sqrt(qcol(1,1)*qcol(1,1) &
              +qcol(2,1)*qcol(2,1) &
              +qcol(3,1)*qcol(3,1))
            else if (final_state > 0) then
              cost = &
              ((qcol(1,3)+qcol(1,5)+qcol(1,6))*qcol(1,1) &
              +(qcol(2,3)+qcol(2,5)+qcol(2,6))*qcol(2,1) &
              +(qcol(3,3)+qcol(3,5)+qcol(3,6))*qcol(3,1)) &
              /sqrt((qcol(1,3)+qcol(1,5)+qcol(1,6)) &
              *(qcol(1,3)+qcol(1,5)+qcol(1,6)) &
              +(qcol(2,3)+qcol(2,5)+qcol(2,6)) &
              *(qcol(2,3)+qcol(2,5)+qcol(2,6)) &
              +(qcol(3,3)+qcol(3,5)+qcol(3,6)) &
              *(qcol(3,3)+qcol(3,5)+qcol(3,6))) &
              /sqrt(qcol(1,1)*qcol(1,1) &
              +qcol(2,1)*qcol(2,1) &
              +qcol(3,1)*qcol(3,1))
            end if
            call rootadddouble(cost, "costhetatcol")

            ! calculate parton CoM cos(theta_t)
            if (final_state == 0) then
              costhetat_cm =(q(1,3)*q(1,1) &
              +q(2,3)*q(2,1) &
              +q(3,3)*q(3,1)) &
              /sqrt(q(1,3)*q(1,3) &
              +q(2,3)*q(2,3) &
              +q(3,3)*q(3,3)) &
              /sqrt(q(1,1)*q(1,1) &
              +q(2,1)*q(2,1) &
              +q(3,1)*q(3,1))
            else if (final_state > 0) then
              costhetat_cm = &
              ((q(1,3)+q(1,5)+q(1,6))*q(1,1) &
              +(q(2,3)+q(2,5)+q(2,6))*q(2,1) &
              +(q(3,3)+q(3,5)+q(3,6))*q(3,1)) &
              /sqrt((q(1,3)+q(1,5)+q(1,6)) &
              *(q(1,3)+q(1,5)+q(1,6)) &
              +(q(2,3)+q(2,5)+q(2,6)) &
              *(q(2,3)+q(2,5)+q(2,6)) &
              +(q(3,3)+q(3,5)+q(3,6)) &
              *(q(3,3)+q(3,5)+q(3,6))) &
              /sqrt(q(1,1)*q(1,1) &
              +q(2,1)*q(2,1) &
              +q(3,1)*q(3,1))
            end if
            call rootadddouble(costhetat_cm, "costhetat")

            beta = shat/4.d0/rmt**2 - 1.d0
            call rootadddouble(beta, "beta")

            ! calculate rapidity of the tt system
            ytt = 0.5d0*log(x1/x2)
            call rootadddouble(ytt, "ytt")

            ! reconstructed costheta_t
            costhetat_star = int(ytt/abs(ytt))*costhetat_cm
            call rootadddouble(costhetat_star, "costhetastar")

            if (final_state == 0) then
              mtt2 = (qcol(4,3) + qcol(4,4))**2
              do i = 1, 3
                mtt2 = mtt2 - (qcol(i,3) + qcol(i,4))**2
              end do
            else if (final_state > 0) then
              mtt2 = (qcol(4,3) + qcol(4,4) &
                    + qcol(4,5) + qcol(4,6) &
                    + qcol(4,7) + qcol(4,8))**2
              do i = 1, 3
                mtt2 = mtt2 - (qcol(i,3) + qcol(i,4) &
                             + qcol(i,5) + qcol(i,6) &
                             + qcol(i,7) + qcol(i,8))**2
              end do
            end if
            mtt = sqrt(abs(mtt2))
            call rootadddouble(mtt, "Mtt")

            if (final_state > 0) then         

              ! reconstruct the neutrino momentum for the semi-hadronic channel
              do i = 1, 2
                pT6col(i) = p6col(i)
                p6col_reco(i) = p6col(i)
              end do
              p6col_reco(3) = longitudinal_neutrino_momentum(p5col, pT6col)
              call rootadddouble(p6col_reco(3), "Pz6_reco")
              p6col_reco(0) = sqrt(p6col_reco(1)*p6col_reco(1) + p6col_reco(2)*p6col_reco(2) + p6col_reco(3)*p6col_reco(3))
              call rootadddouble(p6col_reco(0), "E6_reco") 

              ! total reconstructed momentum in collider frame
              ptotalcol_reco = p1col + p2col + p3col + p4col + p5col + p6col_reco + p7col + p8col

              ! find spatially opposite 4-momentum
              ptotalcol_reco_opp(0) = ptotalcol_reco(0)
              do i = 1, 3
                  ptotalcol_reco_opp(i) = -ptotalcol_reco(i)
              end do
              call boostx(p6col_reco, ptotalcol_reco_opp, p6_reco)

              yt_reco = 0.5*log((q(4,3)+q(4,5)+p6_reco(0) &
              +q(3,3)+q(3,5)+p6_reco(3)) &
              /(q(4,3)+q(4,5)+p6_reco(0) &
              -q(3,3)-q(3,5)-p6_reco(3)))
              call rootadddouble(yt_reco, "yt_reco")

              delta_absy_reco = abs(yt_reco) - abs(ytb)
              call rootadddouble(delta_absy_reco, "Delta_y_reco")

              ! calculate ytt reco
              ptotal_reco = p1 + p2 + p3 + p4 + p5 + p6_reco + p7 + p8
              ytt_reco = 0.5*log((ptotal_reco(0) + ptotal_reco(3))/(ptotal_reco(0) - ptotal_reco(3)))          

              ! calculate cos(theta_t) reco
              costhetat_reco = &
              ((q(1,3) + q(1,5) + p6_reco(1))*q(1,1) &
              + (q(2,3) + q(2,5) + p6_reco(2))*q(2,1) &
              + (q(3,3) + q(3,5) + p6_reco(3))*q(3,1)) &
              /sqrt((q(1,3) + q(1,5) + p6_reco(1))*(q(1,3) + q(1,5) + p6_reco(1)) &
                  + (q(2,3) + q(2,5) + p6_reco(2))*(q(2,3) + q(2,5) + p6_reco(2)) &
                  + (q(3,3) + q(3,5) + p6_reco(3))*(q(3,3) + q(3,5) + p6_reco(3))) &
              /sqrt(q(1,1)*q(1,1) + q(2,1)*q(2,1) + q(3,1)*q(3,1))
              call rootadddouble(costhetat_reco, "costhetat_reco")          

              ! truth anti top mass
              call rootadddouble(m478, "m478")

              ! calculate mt reco
              p356col_reco = p3col + p5col + p6col_reco
              m356_reco = mass(p356col_reco)
              call rootadddouble(m356_reco, "mt_reco")

              ! calculate Mtt reco
              mtt_reco2 = (qcol(4,3) + qcol(4,4) &
                         + qcol(4,5) + p6col_reco(0) &
                         + qcol(4,7) + qcol(4,8))**2
              do i = 1, 3
                mtt_reco2 = mtt_reco2 - (qcol(i,3) + qcol(i,4) &
                                      +  qcol(i,5) + p6col_reco(i) &
                                      +  qcol(i,7) + qcol(i,8))**2
              end do
              mtt_reco = sqrt(mtt_reco2)
              call rootadddouble(mtt_reco, "Mtt_reco")          

              ! "reconstructed" reconstructed costheta_t
              costhetat_star_reco = int(ytt_reco/abs(ytt_reco))*costhetat_reco
              call rootadddouble(costhetat_star_reco, "costhetastar_reco")

              ! boost anti lepton to top rest frame
              p356(0) = q356(4)
              p356_opp(0) = q356(4)
              do i = 1, 3
                p356(i) = q356(i)
                p356_opp(i) = -q356(i)
              end do 
              call boostx(p5, p356_opp, p5rest)

              ! boost lepton to antitop rest frame
              p478(0) = q478(4)
              p478_opp(0) = q478(4)
              do i = 1, 3
                p478(i) = q478(i)
                p478_opp(i) = -q478(i)
              end do
              call boostx(p7, p478_opp, p7rest)

              ! calculate cos(theta_l+) in top rest frame
              costheta5 = (p5rest(1)*q356(1) &
                           +p5rest(2)*q356(2) &
                           +p5rest(3)*q356(3)) &
                          /sqrt(p5rest(1)*p5rest(1) &
                                +p5rest(2)*p5rest(2) &
                                +p5rest(3)*p5rest(3)) &
                          /sqrt(q356(1)*q356(1) &
                                +q356(2)*q356(2) &
                                +q356(3)*q356(3))
              call rootadddouble(costheta5, "costheta5")

              ! calculate cos(theta_l-) in top rest frame
              costheta7 = (p7rest(1)*q478(1) &
                           +p7rest(2)*q478(2) &
                           +p7rest(3)*q478(3)) &
                          /sqrt(p7rest(1)*p7rest(1) &
                                +p7rest(2)*p7rest(2) &
                                +p7rest(3)*p7rest(3)) &
                          /sqrt(q478(1)*q478(1) &
                                +q478(2)*q478(2) &
                                +q478(3)*q478(3))
              call rootadddouble(costheta7, "costheta7")

              ! calculate product of cos(theta_l+) and cos(theta_l-) in top rest frame          
              ct7ct5 = costheta7*costheta5
              call rootadddouble(ct7ct5, "ct7ct5")

              ! calculate cos(theta_l+)col
              costheta5col = (qcol(1,5)*qcol(1,1) &
                            + qcol(2,5)*qcol(2,1) &
                            + qcol(3,5)*qcol(3,1)) &
                            /sqrt(qcol(1,5)*qcol(1,5) &
                            + qcol(2,5)*qcol(2,5) &
                            + qcol(3,5)*qcol(3,5)) &
                            /sqrt(qcol(1,1)*qcol(1,1) &
                            + qcol(2,1)*qcol(2,1) &
                            + qcol(3,1)*qcol(3,1))
              call rootadddouble(costheta5col, "costheta5col")


              ! calculate cos(theta_l-)col
              costheta7col = (qcol(1,7)*qcol(1,1) &
                            + qcol(2,7)*qcol(2,1) &
                            + qcol(3,7)*qcol(3,1)) &
                            /sqrt(qcol(1,7)*qcol(1,7) &
                            + qcol(2,7)*qcol(2,7) &
                            + qcol(3,7)*qcol(3,7)) &
                            /sqrt(qcol(1,1)*qcol(1,1) &
                            + qcol(2,1)*qcol(2,1) &
                            + qcol(3,1)*qcol(3,1))
              call rootadddouble(costheta7col, "costheta7col")

              ! calculate product of cos(theta_l+) and cos(theta_l-) in collider frame
              ct7ct5col = costheta7col*costheta5col
              call rootadddouble(ct7ct5col, "ct7ct5col")

              ! calculate cos(theta_l+)cm
              costheta5cm = (q(1,5)*q(1,1) &
                            + q(2,5)*q(2,1) &
                            + q(3,5)*q(3,1)) &
                            /sqrt(q(1,5)*q(1,5) &
                            + q(2,5)*q(2,5) &
                            + q(3,5)*q(3,5)) &
                            /sqrt(q(1,1)*q(1,1) &
                            + q(2,1)*q(2,1) &
                            + q(3,1)*q(3,1))
              call rootadddouble(costheta5cm, "costheta5cm")


              ! calculate cos(theta_l-)cm
              costheta7cm = (q(1,7)*q(1,1) &
                            + q(2,7)*q(2,1) &
                            + q(3,7)*q(3,1)) &
                            /sqrt(q(1,7)*q(1,7) &
                            + q(2,7)*q(2,7) &
                            + q(3,7)*q(3,7)) &
                            /sqrt(q(1,1)*q(1,1) &
                            + q(2,1)*q(2,1) &
                            + q(3,1)*q(3,1))
              call rootadddouble(costheta7cm, "costheta7cm")

              ! calculate product of cos(theta_l+) and cos(theta_l-) in collider frame
              ct7ct5cm = costheta7cm*costheta5cm
              call rootadddouble(ct7ct5cm, "ct7ct5cm")

              ! calculate cos(phi_l) (lepton azimuthal angle)
              p5mag = sqrt(q(1,5)*q(1,5) + q(2,5)*q(2,5) + q(3,5)*q(3,5))

              ! p(1)^ is z^
              do i = 1, 3
                zp(i) = q(i,1)/sqrt(q(1,1)*q(1,1) + q(2,1)*q(2,1) + q(3,1)*q(3,1))
              end do

              ! p(5)_t^ is x^
              do i = 1, 2
                xp(i) = q356(i)/sqrt(q356(1)*q356(1) + q356(2)*q356(2))
              end do
              xp(3) = 0

              ! y^ obtained using cross product
              yp(1) = zp(2)*xp(3) - zp(3)*xp(2)
              yp(2) = zp(3)*xp(1) - zp(1)*xp(3)
              yp(3) = zp(1)*xp(2) - zp(2)*xp(1)

              p5xp = 0
              do i = 1, 3
                p5xp = p5xp + q(i,5)*xp(i)
              end do
              p5yp = 0
              do i = 1, 3
                p5yp = p5yp + q(i,5)*yp(i)
              end do
              p5zp = 0
              do i = 1, 3
                p5zp = p5zp + q(i,5)*zp(i)
              end do

              p5mp = sqrt(p5xp*p5xp + p5yp*p5yp + p5zp*p5zp)

              if (abs(p5mag - p5mp) >= 1e-11) print*, 'Error: coordinate transform mismatch.'

              phi_l = atan2(p5yp,p5xp)

              if (phi_l < 0)phi_l = phi_l + 2*pi
              call rootadddouble(phi_l, "fl")

              cosfl = cos(phi_l)
              call rootadddouble(cosfl, "cosphil")
            end if

            call debug("...complete.")

            call debug("Computing FB dsigmas...")

            if (costhetat_cm > 0.d0) then
              sigma_fb(+1,1,it) = sigma_fb(+1,1,it) + hist
              error_fb(+1,1,it) = error_fb(+1,1,it) + sigma_fb(+1,1,it)**2
            else if (costhetat_cm < 0.d0) then
              sigma_fb(-1,1,it) = sigma_fb(-1,1,it) + hist
              error_fb(-1,1,it) = error_fb(-1,1,it) + sigma_fb(-1,1,it)**2
            end if

            if (costhetat_star > 0.d0) then
              sigma_fb(+1,2,it) = sigma_fb(+1,2,it) + hist
              error_fb(+1,2,it) = error_fb(+1,2,it) + sigma_fb(+1,2,it)**2
            else if (costhetat_star < 0.d0) then
              sigma_fb(-1,2,it) = sigma_fb(-1,2,it) + hist
              error_fb(-1,2,it) = error_fb(-1,2,it) + sigma_fb(-1,2,it)**2
            end if

            if (yt > 0.d0) then
              sigma_fb(+1,3,it) = sigma_fb(+1,3,it) + hist
              error_fb(+1,3,it) = error_fb(+1,3,it) + sigma_fb(+1,3,it)**2
            else if (yt < 0.d0) then
              sigma_fb(-1,3,it) = sigma_fb(-1,3,it) + hist
              error_fb(-1,3,it) = error_fb(-1,3,it) + sigma_fb(-1,3,it)**2
            end if

            if (yt >= 0.d0) then
              sigma_fb(+1,4,it) = sigma_fb(+1,4,it) + hist
              error_fb(+1,4,it) = error_fb(+1,4,it) + sigma_fb(+1,4,it)**2
            end if
            if (ytb >= 0.d0) then
              sigma_fb(-1,4,it) = sigma_fb(-1,4,it) + hist
              error_fb(-1,4,it) = error_fb(-1,4,it) + sigma_fb(-1,4,it)**2
            end if

            if (delta_absy > 0.d0) then
              sigma_fb(+1,5,it) = sigma_fb(+1,5,it) + hist
              error_fb(+1,5,it) = error_fb(+1,5,it) + sigma_fb(+1,5,it)**2
            else if (delta_absy < 0.d0) then
              sigma_fb(-1,5,it) = sigma_fb(-1,5,it) + hist
              error_fb(-1,5,it) = error_fb(-1,5,it) + sigma_fb(-1,5,it)**2
            end if

            if (final_state > 0) then
              if (costhetat_star_reco > 0.d0) then
                sigma_fb(+1,6,it) = sigma_fb(+1,6,it) + hist
                error_fb(+1,6,it) = error_fb(+1,6,it) + sigma_fb(+1,6,it)**2
              else if (costhetat_star_reco < 0.d0) then
                sigma_fb(-1,6,it) = sigma_fb(-1,6,it) + hist
                error_fb(-1,6,it) = error_fb(-1,6,it) + sigma_fb(-1,6,it)**2
              end if

              if (abs(ytt_reco) > yttmin) then
                if (delta_absy == 0.d0) then
                  continue
                else if (delta_absy_reco > 0.d0) then
                  sigma_fb(+1,7,it) = sigma_fb(+1,7,it) + hist
                  error_fb(+1,7,it) = error_fb(+1,7,it) + sigma_fb(+1,7,it)**2
                else if (delta_absy_reco < 0.d0) then
                  sigma_fb(-1,7,it) = sigma_fb(-1,7,it) + hist
                  error_fb(-1,7,it) = error_fb(-1,7,it) + sigma_fb(-1,7,it)**2
                end if
              end if

              if (cosfl > 0.d0) then
                sigma_fb(+1,8,it) = sigma_fb(+1,8,it) + hist
                error_fb(+1,8,it) = error_fb(+1,8,it) + sigma_fb(+1,8,it)**2
              else if (cosfl < 0.d0) then
                sigma_fb(-1,8,it) = sigma_fb(-1,8,it) + hist
                error_fb(-1,8,it) = error_fb(-1,8,it) + sigma_fb(-1,8,it)**2
              end if

              if (costheta5cm > 0.d0) then
                sigma_fb(+1,9,it) = sigma_fb(+1,9,it) + hist
                error_fb(+1,9,it) = error_fb(+1,9,it) + sigma_fb(+1,9,it)**2
              else if (costheta5cm < 0.d0) then
                sigma_fb(-1,9,it) = sigma_fb(-1,9,it) + hist
                error_fb(-1,9,it) = error_fb(-1,9,it) + sigma_fb(-1,9,it)**2
              end if
            end if

            call debug("...complete.")
          end if

          ! convert results to different tt classifications
          call rootadddouble(hist*fac_ee,"weight_ee")
          call rootadddouble(hist*fac_emu,"weight_emu")
          call rootadddouble(hist*fac_eq,"weight_eq")
          call rootadddouble(hist*fac_qq,"weight_qq")
          call rootaddint(it,"iteration")
          call rootaddevent(hist)

          if (print_distributions == 1) then
            call debug('Filling distributions...')

            if (o_mtt == 1) call h_mtt%fill(mtt, hist)
            if (o_cost == 1) call h_cost%fill(cost, hist)
            if (o_delta_y == 1) call h_delta_y%fill(delta_absy, hist)

            if (final_state > 0) then
              if (o_mtt_reco == 1) call h_mtt_reco%fill(mtt_reco, hist)
              if (o_mt_reco == 1) call h_mt_reco%fill(m356_reco, hist)
    	        if (o_fl == 1) call h_fl%fill(phi_l, hist)
    	        if (o_cosfl == 1) call h_cosfl%fill(cosfl, hist)
    	        if (o_cost5 == 1) call h_cost5%fill(costheta5, hist)
    	        if (o_cost7 == 1) call h_cost7%fill(costheta7, hist)
    	        if (o_ct7ct5 == 1) call h_ct7ct5%fill(ct7ct5, hist)
         		end if

            call debug('...complete.')
            call debug('Filling asymmetry histograms...')

            if (o_asym(1) == 1) then
              if (o_sigp == 1) then
                ! generate distribution in sigp for all.
                sigp=ecm
                nbin=int((sigp-sigpmin)/sigpw)+1
                if (nbin >= (ndiv_sigp+1)) then
                  continue
                else if (nbin < 1) then
                  continue
                else
                  fxsigp(1,nbin,it)=fxsigp(1,nbin,it)+ &
                  (weight(+1,+1,it)+weight(-1,-1,it))   !ction happens
                end if
              end if
              if (o_sigm == 1) then
                ! generate distribution in sigm for all.
                sigm=ecm
                nbin=int((sigm-sigmmin)/sigmw)+1
                if (nbin >= (ndiv_sigm+1)) then
                  continue
                else if (nbin < 1) then
                  continue
                else
                  fxsigm(1,nbin,it)=fxsigm(1,nbin,it)+ &
                  (weight(+1,-1,it)+weight(-1,+1,it))
                end if
              end if
            end if

            if (o_asym(2) == 1) then
              if (o_sigp == 1) then
              ! generate distribution in sigp for al.
                sigp=ecm
                nbin=int((sigp-sigpmin)/sigpw)+1
                if (nbin >= (ndiv_sigp+1)) then
                  continue
                else if (nbin < 1) then
                  continue
                else
                  fxsigp(2,nbin,it)=fxsigp(2,nbin,it)+ &
                  (weight(-1,-1,it)+weight(-1,+1,it))
                end if
              end if
              if (o_sigm == 1) then
              ! generate distribution in sigm for al.
                sigm=ecm
                nbin=int((sigm-sigmmin)/sigmw)+1
                if (nbin >= (ndiv_sigm+1)) then
                  continue
                else if (nbin < 1) then
                  continue
                else
                  fxsigm(2,nbin,it)=fxsigm(2,nbin,it)+ &
                  (weight(+1,-1,it)+weight(+1,+1,it))
                end if
              end if
            end if

            if (o_asym(3) == 1) then
              if (o_sigp == 1) then
              ! generate distribution in sigp for apv.
                sigp=ecm
                nbin=int((sigp-sigpmin)/sigpw)+1
                if (nbin >= (ndiv_sigp+1)) then
                  continue
                else if (nbin < 1) then
                  continue
                else
                  fxsigp(3,nbin,it)=fxsigp(3,nbin,it)+ &
                  (weight(-1,-1,it))
                end if
              end if
              if (o_sigm == 1) then
              ! generate distribution in sigm for apv.
                sigm=ecm
                nbin=int((sigm-sigmmin)/sigmw)+1
                if (nbin >= (ndiv_sigm+1)) then
                  continue
                else if (nbin < 1) then
                  continue
                else
                  fxsigm(3,nbin,it)=fxsigm(3,nbin,it)+ &
                  (weight(+1,+1,it))
                end if
              end if
            end if

            if (o_asym(4) == 1) then
              if ((o_sigp == 1) .and. (costhetat_cm > 0.d0)) then
              ! generate distribution in sigp for afbcm.
                sigp=ecm
                nbin=int((sigp-sigpmin)/sigpw)+1
                if (nbin >= (ndiv_sigp+1)) then
                  continue
                else if (nbin < 1) then
                  continue
                else
                  fxsigp(4,nbin,it)=fxsigp(4,nbin,it)+hist
                end if
              end if
              if ((o_sigm == 1) .and. (costhetat_cm < 0.d0)) then
              ! generate distribution in sigm for afbcm.
                sigm=ecm
                nbin=int((sigm-sigmmin)/sigmw)+1
                if (nbin >= (ndiv_sigm+1)) then
                  continue
                else if (nbin < 1) then
                  continue
                else
                  fxsigm(4,nbin,it)=fxsigm(4,nbin,it)+hist
                end if
              end if
            end if

            if (o_asym(5) == 1) then
              if ((o_sigp == 1) .and. (costhetat_star > 0.d0)) then
              ! generate distribution in sigp for afbstar.
                sigp=ecm
                nbin=int((sigp-sigpmin)/sigpw)+1
                if (nbin >= (ndiv_sigp+1)) then
                  continue
                else if (nbin < 1) then
                  continue
                else
                  fxsigp(5,nbin,it)=fxsigp(5,nbin,it)+hist
                end if
              end if
              if ((o_sigm == 1) .and. (costhetat_star < 0.d0)) then
              ! generate distribution in sigm for afbstar.
                sigm=ecm
                nbin=int((sigm-sigmmin)/sigmw)+1
                if (nbin >= (ndiv_sigm+1)) then
                  continue
                else if (nbin < 1) then
                  continue
                else
                  fxsigm(5,nbin,it)=fxsigm(5,nbin,it)+hist
                end if
              end if
            end if

            if (o_asym(6) == 1) then
              if ((o_sigp == 1) .and. (costhetat_star_reco > 0.d0)) then
              ! generate distribution in sigp for afbstar reco.
                sigp=ecm
                nbin=int((sigp-sigpmin)/sigpw)+1
                if (nbin >= (ndiv_sigp+1)) then
                  continue
                else if (nbin < 1) then
                  continue
                else
                  fxsigp(6,nbin,it)=fxsigp(6,nbin,it)+hist
                end if
              end if
              if ((o_sigm == 1) .and. (costhetat_star_reco < 0.d0)) then
              ! generate distribution in sigm for afbstar.
                sigm=ecm
                nbin=int((sigm-sigmmin)/sigmw)+1
                if (nbin >= (ndiv_sigm+1)) then
                  continue
                else if (nbin < 1) then
                  continue
                else
                  fxsigm(6,nbin,it)=fxsigm(6,nbin,it)+hist
                end if
              end if
            end if

            if (o_asym(7) == 1) then
              if ((o_sigp == 1) .and. (yt > 0.d0)) then
              ! generate distribution in sigp for atfb.
                sigp=ecm
                nbin=int((sigp-sigpmin)/sigpw)+1
                if (nbin >= (ndiv_sigp+1)) then
                  continue
                else if (nbin < 1) then
                  continue
                else
                  fxsigp(7,nbin,it)=fxsigp(7,nbin,it)+hist
                end if
              end if
              if ((o_sigm == 1) .and. (yt < 0.d0)) then
              ! generate distribution in sigm for atfb.
                sigm=ecm
                nbin=int((sigm-sigmmin)/sigmw)+1
                if (nbin >= (ndiv_sigm+1)) then
                  continue
                else if (nbin < 1) then
                  continue
                else
                  fxsigm(7,nbin,it)=fxsigm(7,nbin,it)+hist
                end if
              end if
            end if

            if (o_asym(8) == 1) then
              if ((o_sigp == 1) .and. (yt >= 0.d0)) then
              ! generate distribution in sigp for a.
                sigp=ecm
                nbin=int((sigp-sigpmin)/sigpw)+1
                if (nbin >= (ndiv_sigp+1)) then
                  continue
                else if (nbin < 1) then
                  continue
                else
                  fxsigp(8,nbin,it)=fxsigp(8,nbin,it)+hist
                end if
              end if
              if ((o_sigm == 1) .and. (ytb >= 0.d0)) then
              ! generate distribution in sigm for a.
                sigm=ecm
                nbin=int((sigm-sigmmin)/sigmw)+1
                if (nbin >= (ndiv_sigm+1)) then
                  continue
                else if (nbin < 1) then
                  continue
                else
                  fxsigm(8,nbin,it)=fxsigm(8,nbin,it)+hist
                end if
              end if
            end if

            if (o_asym(9) == 1) then
              if ((o_sigp == 1) .and. (delta_absy > 0.d0)) then
              ! generate distribution in sigp for arfb.
                sigp=ecm
                nbin=int((sigp-sigpmin)/sigpw)+1
                if (nbin >= (ndiv_sigp+1)) then
                  continue
                else if (nbin < 1) then
                  continue
                else
                  if (abs(ytt) > yttmin)fxsigp(9,nbin,it)=fxsigp(9,nbin,it)+hist
                end if
              end if
              if ((o_sigm == 1) .and. (delta_absy < 0.d0)) then
              ! generate distribution in sigm for arfb.
                sigm=ecm
                nbin=int((sigm-sigmmin)/sigmw)+1
                if (nbin >= (ndiv_sigm+1)) then
                  continue
                else if (nbin < 1) then
                  continue
                else
                  if (abs(ytt) > yttmin)fxsigm(9,nbin,it)=fxsigm(9,nbin,it)+hist
                end if
              end if
            end if

            if (o_asym(10) == 1) then
              if ((o_sigp == 1) .and. (delta_absy_reco > 0.d0)) then
              ! generate distribution in sigp for arfb reco.
                sigp=ecm
                nbin=int((sigp-sigpmin)/sigpw)+1
                if (nbin >= (ndiv_sigp+1)) then
                  continue
                else if (nbin < 1) then
                  continue
                else
                  if (abs(ytt_reco) > yttmin)fxsigp(10,nbin,it)=fxsigp(10,nbin,it)+hist
                end if
              end if
              if ((o_sigm == 1) .and. (delta_absy_reco < 0.d0)) then
              ! generate distribution in sigm for arfb.
                sigm=ecm
                nbin=int((sigm-sigmmin)/sigmw)+1
                if (nbin >= (ndiv_sigm+1)) then
                  continue
                else if (nbin < 1) then
                  continue
                else
                  if (abs(ytt_reco) > yttmin)fxsigm(10,nbin,it)=fxsigm(10,nbin,it)+hist
                end if
              end if
            end if

            if (o_asym(11) == 1) then
              if ((o_sigp == 1) .and. (cosfl > 0.d0)) then
                ! generate distribution in sigp for a_l.
                sigp=ecm
                nbin=int((sigp-sigpmin)/sigpw)+1
                if (nbin >= (ndiv_sigp+1)) then
                  continue
                else if (nbin < 1) then
                  continue
                else
                  fxsigp(11,nbin,it)=fxsigp(11,nbin,it)+hist
                end if
              end if
              if ((o_sigm == 1) .and. (cosfl < 0.d0)) then
                ! generate distribution in sigm for a_l.
                sigm=ecm
                nbin=int((sigm-sigmmin)/sigmw)+1
                if (nbin >= (ndiv_sigm+1)) then
                  continue
                else if (nbin < 1) then
                  continue
                else
                  fxsigm(11,nbin,it)=fxsigm(11,nbin,it)+hist
                end if
              end if
            end if
          
            if (o_asym(12) == 1) then
              if ((o_sigp == 1) .and. (costheta5cm > 0.d0)) then
                ! generate distribution in sigp for alFB.
                sigp=ecm
                nbin=int((sigp-sigpmin)/sigpw)+1
                if (nbin >= (ndiv_sigp+1)) then
                  continue
                else if (nbin < 1) then
                  continue
                else
                  fxsigp(12,nbin,it)=fxsigp(12,nbin,it)+hist
                end if
              end if
              if ((o_sigm == 1) .and. (costheta5cm < 0.d0)) then
                ! generate distribution in sigm for alFB.
                sigm=ecm
                nbin=int((sigm-sigmmin)/sigmw)+1
                if (nbin >= (ndiv_sigm+1)) then
                  continue
                else if (nbin < 1) then
                  continue
                else
                  fxsigm(12,nbin,it)=fxsigm(12,nbin,it)+hist
                end if
              end if
            end if
            call debug('...complete.')
          end if